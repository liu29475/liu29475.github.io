<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Python操作码——BUILD_CONST_KEY_MAP</title>
      <link href="/python/python-opcode-BUILD_CONST_KEY_MAP.html"/>
      <url>/python/python-opcode-BUILD_CONST_KEY_MAP.html</url>
      
        <content type="html"><![CDATA[<p><code>BUILD_CONST_KEY_MAP</code> 的编号是156，是个带参数的操作码。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>dis.opmap[<span class="string">'BUILD_CONST_KEY_MAP'</span>]</span><br><span class="line"><span class="number">156</span></span><br></pre></td></tr></table></figure><a id="more"></a><p>这个操作码在 Python3.6 中引入，和 <code>BUILD_MAP</code> 一样用于创建字典，但是，只有键全部是 Python 中的不可变对象时才会生成这个操作码。一些示例如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>dis.dis(<span class="string">'&#123;1: 10&#125;'</span>)  <span class="comment"># 只包含一个键值对时直接使用BUILD_MAP</span></span><br><span class="line">  <span class="number">1</span>           <span class="number">0</span> LOAD_CONST               <span class="number">0</span> (<span class="number">1</span>)</span><br><span class="line">              <span class="number">2</span> LOAD_CONST               <span class="number">1</span> (<span class="number">10</span>)</span><br><span class="line">              <span class="number">4</span> BUILD_MAP                <span class="number">1</span></span><br><span class="line">              <span class="number">6</span> RETURN_VALUE</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dis.dis(<span class="string">"&#123;b'a': 10, b'b': 20&#125;"</span>)</span><br><span class="line">  <span class="number">1</span>           <span class="number">0</span> LOAD_CONST               <span class="number">0</span> (<span class="number">10</span>)</span><br><span class="line">              <span class="number">2</span> LOAD_CONST               <span class="number">1</span> (<span class="number">20</span>)</span><br><span class="line">              <span class="number">4</span> LOAD_CONST               <span class="number">2</span> ((<span class="string">b'a'</span>, <span class="string">b'b'</span>))</span><br><span class="line">              <span class="number">6</span> BUILD_CONST_KEY_MAP      <span class="number">2</span></span><br><span class="line">              <span class="number">8</span> RETURN_VALUE</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dis.dis(<span class="string">"&#123;b'a': 10, b'b': 20, (1, 2): 30&#125;"</span>)</span><br><span class="line">  <span class="number">1</span>           <span class="number">0</span> LOAD_CONST               <span class="number">0</span> (<span class="number">10</span>)</span><br><span class="line">              <span class="number">2</span> LOAD_CONST               <span class="number">1</span> (<span class="number">20</span>)</span><br><span class="line">              <span class="number">4</span> LOAD_CONST               <span class="number">2</span> (<span class="number">30</span>)</span><br><span class="line">              <span class="number">6</span> LOAD_CONST               <span class="number">3</span> ((<span class="string">b'a'</span>, <span class="string">b'b'</span>, (<span class="number">1</span>, <span class="number">2</span>)))</span><br><span class="line">              <span class="number">8</span> BUILD_CONST_KEY_MAP      <span class="number">3</span></span><br><span class="line">             <span class="number">10</span> RETURN_VALUE</span><br></pre></td></tr></table></figure><p>可以看到，与 <code>BUILD_MAP</code> 不同的是，所有的键被放到了一个元组中，且这个元组是最后压入值栈的，执行到 <code>BUILD_CONST_KEY_MAP</code> 时值栈栈顶的值就是这个元组。底层实现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">TARGET(BUILD_CONST_KEY_MAP) &#123;</span><br><span class="line">    Py_ssize_t i;</span><br><span class="line">    PyObject *<span class="built_in">map</span>;</span><br><span class="line">    PyObject *keys = TOP();</span><br><span class="line">    <span class="keyword">if</span> (!PyTuple_CheckExact(keys) ||</span><br><span class="line">        PyTuple_GET_SIZE(keys) != (Py_ssize_t)oparg) &#123;</span><br><span class="line">        PyErr_SetString(PyExc_SystemError,</span><br><span class="line">                        <span class="string">"bad BUILD_CONST_KEY_MAP keys argument"</span>);</span><br><span class="line">        <span class="keyword">goto</span> error;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">map</span> = _PyDict_NewPresized((Py_ssize_t)oparg);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">map</span> == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">goto</span> error;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = oparg; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">int</span> err;</span><br><span class="line">        PyObject *key = PyTuple_GET_ITEM(keys, oparg - i);</span><br><span class="line">        PyObject *value = PEEK(i + <span class="number">1</span>);</span><br><span class="line">        err = PyDict_SetItem(<span class="built_in">map</span>, key, value);</span><br><span class="line">        <span class="keyword">if</span> (err != <span class="number">0</span>) &#123;</span><br><span class="line">            Py_DECREF(<span class="built_in">map</span>);</span><br><span class="line">            <span class="keyword">goto</span> error;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Py_DECREF(POP());</span><br><span class="line">    <span class="keyword">while</span> (oparg--) &#123;</span><br><span class="line">        Py_DECREF(POP());</span><br><span class="line">    &#125;</span><br><span class="line">    PUSH(<span class="built_in">map</span>);</span><br><span class="line">    DISPATCH();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先获取值栈栈顶值，也就是所有的键组成的元组，然后检查这个值是否是真的元组，且元组长度等于操作码的参数值（操作码的参数值是键值对的数量）。如果不是则设置 <code>SystemError</code> 异常并跳转到错误处理。</p><p>往下，调用 <code>_PyDict_NewPresized</code> 创建字典，这个函数的分析参考 <code>BUILD_MAP</code>。如果创建失败则跳转到错误处理。创建成功则循环地从元组和值栈中获取对应的键和值，然后调用 <code>PyDict_SetItem</code> 为字典设置键值对，如果 <code>PyDict_SetItem</code> 执行过程中引发了异常则停止设置并跳转到错误处理。</p><p>最后将键组成的元组和所有的值从值栈中弹出，并将设置好的字典压入值栈中供后续的操作码使用。</p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python操作码——BUILD_LIST_UNPACK</title>
      <link href="/python/python-opcode-BUILD_LIST_UNPACK.html"/>
      <url>/python/python-opcode-BUILD_LIST_UNPACK.html</url>
      
        <content type="html"><![CDATA[<p><code>BUILD_LIST_UNPACK</code> 操作码的编号是149，是个带参数的操作码，这个操作码与 <code>BUILD_TUPLE_UNPACK</code> 和 <code>BUILD_TUPLE_UNPACK_WITH_CALL</code> 共用同一段处理语句，后两者的编号分别是152和158。</p><a id="more"></a><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>[dis.opmap[i] <span class="keyword">for</span> i <span class="keyword">in</span> (<span class="string">'BUILD_LIST_UNPACK'</span>,</span><br><span class="line">                            <span class="string">'BUILD_TUPLE_UNPACK'</span>,</span><br><span class="line">                            <span class="string">'BUILD_TUPLE_UNPACK_WITH_CALL'</span>)]</span><br><span class="line">[<span class="number">149</span>, <span class="number">152</span>, <span class="number">158</span>]</span><br></pre></td></tr></table></figure><p><code>BUILD_LIST_UNPACK</code> 与 <code>BUILD_TUPLE_UNPACK</code> 在 Python3.5 中引入而 <code>BUILD_TUPLE_UNPACK_WITH_CALL</code> 则是在 Python3.6 中引入。<code>BUILD_LIST_UNPACK</code> 对应的语法为 <code>[*iterable1, ...]</code>（这里的 <code>...</code> 表示省略，不是 Python 的 <code>Ellipsis</code>）。<code>BUILD_TUPLE_UNPACK</code> 非常类似，只是把方括号换成圆括号：<code>(*iterable1, ...)</code>。<code>BUILD_TUPLE_UNPACK_WITH_CALL</code> 则用于函数调用：<code>f(*iterable1, *iterable2, ...)</code>。一些示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>[*range(<span class="number">10</span>)]    <span class="comment"># range()函数返回一个iterable</span></span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[*range(<span class="number">2</span>), *range(<span class="number">4</span>)]</span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>(*range(<span class="number">10</span>),)   <span class="comment"># 注意：要加上逗号</span></span><br><span class="line">(<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dis.dis(<span class="string">'f(*(1, 2), *(3, 4))'</span>)  <span class="comment"># f是函数</span></span><br><span class="line">  <span class="number">1</span>           <span class="number">0</span> LOAD_NAME                <span class="number">0</span> (f)</span><br><span class="line">              <span class="number">2</span> LOAD_CONST               <span class="number">0</span> ((<span class="number">1</span>, <span class="number">2</span>))</span><br><span class="line">              <span class="number">4</span> LOAD_CONST               <span class="number">1</span> ((<span class="number">3</span>, <span class="number">4</span>))</span><br><span class="line">              <span class="number">6</span> BUILD_TUPLE_UNPACK_WITH_CALL     <span class="number">2</span></span><br><span class="line">              <span class="number">8</span> CALL_FUNCTION_EX         <span class="number">0</span></span><br><span class="line">             <span class="number">10</span> RETURN_VALUE</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dis.dis(<span class="string">'f(*[*range(2)], *(*range(3),))'</span>)   <span class="comment"># 3个组合</span></span><br><span class="line">  <span class="number">1</span>           <span class="number">0</span> LOAD_NAME                <span class="number">0</span> (f)</span><br><span class="line">              <span class="number">2</span> LOAD_NAME                <span class="number">1</span> (range)</span><br><span class="line">              <span class="number">4</span> LOAD_CONST               <span class="number">0</span> (<span class="number">2</span>)</span><br><span class="line">              <span class="number">6</span> CALL_FUNCTION            <span class="number">1</span></span><br><span class="line">              <span class="number">8</span> BUILD_LIST_UNPACK        <span class="number">1</span></span><br><span class="line">             <span class="number">10</span> LOAD_NAME                <span class="number">1</span> (range)</span><br><span class="line">             <span class="number">12</span> LOAD_CONST               <span class="number">1</span> (<span class="number">3</span>)</span><br><span class="line">             <span class="number">14</span> CALL_FUNCTION            <span class="number">1</span></span><br><span class="line">             <span class="number">16</span> BUILD_TUPLE_UNPACK       <span class="number">1</span></span><br><span class="line">             <span class="number">18</span> BUILD_TUPLE_UNPACK_WITH_CALL     <span class="number">2</span></span><br><span class="line">             <span class="number">20</span> CALL_FUNCTION_EX         <span class="number">0</span></span><br><span class="line">             <span class="number">22</span> RETURN_VALUE</span><br></pre></td></tr></table></figure><p>来看源码实现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">TARGET(BUILD_TUPLE_UNPACK_WITH_CALL)</span><br><span class="line">TARGET(BUILD_TUPLE_UNPACK)</span><br><span class="line">TARGET(BUILD_LIST_UNPACK) &#123;</span><br><span class="line">    <span class="keyword">int</span> convert_to_tuple = opcode != BUILD_LIST_UNPACK;</span><br><span class="line">    Py_ssize_t i;</span><br><span class="line">    PyObject *sum = PyList_New(<span class="number">0</span>);</span><br><span class="line">    PyObject *return_value;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sum == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">goto</span> error;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = oparg; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">        PyObject *none_val;</span><br><span class="line"></span><br><span class="line">        none_val = _PyList_Extend((PyListObject *)sum, PEEK(i));</span><br><span class="line">        <span class="keyword">if</span> (none_val == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (opcode == BUILD_TUPLE_UNPACK_WITH_CALL &amp;&amp;</span><br><span class="line">                PyErr_ExceptionMatches(PyExc_TypeError))</span><br><span class="line">            &#123;</span><br><span class="line">                check_args_iterable(PEEK(<span class="number">1</span> + oparg), PEEK(i));</span><br><span class="line">            &#125;</span><br><span class="line">            Py_DECREF(sum);</span><br><span class="line">            <span class="keyword">goto</span> error;</span><br><span class="line">        &#125;</span><br><span class="line">        Py_DECREF(none_val);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (convert_to_tuple) &#123;</span><br><span class="line">        return_value = PyList_AsTuple(sum);</span><br><span class="line">        Py_DECREF(sum);</span><br><span class="line">        <span class="keyword">if</span> (return_value == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">goto</span> error;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        return_value = sum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (oparg--)</span><br><span class="line">        Py_DECREF(POP());</span><br><span class="line">    PUSH(return_value);</span><br><span class="line">    DISPATCH();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现不算难，<code>convert_to_tuple</code> 变量用于确定操作码是否是 <code>BUILD_LIST_UNPACK</code>。<code>PyList_New</code> 传入0将创建一个长度为0的空列表，这个函数的分析参考 <code>BUILD_LIST</code>。如果创建失败则跳转到错误处理。往下，三个操作码的参数 <code>oparg</code> 都表示可迭代对象的数量，通过循环，使用 <code>PEEK</code> 从值栈中依次获取这些可迭代对象并将它们作为参数传入 <code>_PyList_Extend</code> 函数，这个函数对应列表的 <code>extend</code> 方法，相当于 <code>sum.extend(iterable)</code>。函数实现如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Objects/listobject.c */</span></span><br><span class="line"></span><br><span class="line">PyObject *</span><br><span class="line">_PyList_Extend(PyListObject *self, PyObject *iterable)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> list_extend(self, iterable);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数只是对 <code>list_extend</code> 函数的简单包装，继续查看 <code>list_extend</code> 的实现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Objects/listobject.c */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> PyObject *</span><br><span class="line">list_extend(PyListObject *self, PyObject *iterable)</span><br><span class="line">&#123;</span><br><span class="line">    PyObject *it;      <span class="comment">/* iter(v) */</span></span><br><span class="line">    Py_ssize_t m;                  <span class="comment">/* self的大小 */</span></span><br><span class="line">    Py_ssize_t n;                  <span class="comment">/* 猜测iterable的大小 */</span></span><br><span class="line">    Py_ssize_t mn;                 <span class="comment">/* m + n */</span></span><br><span class="line">    Py_ssize_t i;</span><br><span class="line">    PyObject *(*iternext)(PyObject *);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 特殊情况：</span></span><br><span class="line"><span class="comment">       1) 可以使用PySequence_Fast操作的列表和元组</span></span><br><span class="line"><span class="comment">       2) 扩展自身首先需要复制</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">if</span> (PyList_CheckExact(iterable) || PyTuple_CheckExact(iterable) ||</span><br><span class="line">                (PyObject *)self == iterable) &#123;</span><br><span class="line">        PyObject **src, **dest;</span><br><span class="line">        iterable = PySequence_Fast(iterable, <span class="string">"argument must be iterable"</span>);</span><br><span class="line">        <span class="keyword">if</span> (!iterable)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        n = PySequence_Fast_GET_SIZE(iterable);</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">/* 当iterable为空时短路 */</span></span><br><span class="line">            Py_DECREF(iterable);</span><br><span class="line">            Py_RETURN_NONE;</span><br><span class="line">        &#125;</span><br><span class="line">        m = Py_SIZE(self);</span><br><span class="line">        <span class="comment">/* 分配一个大到足以在任何相关平台上造成溢出的列表是不可能的*/</span></span><br><span class="line">        assert(m &lt; PY_SSIZE_T_MAX - n);</span><br><span class="line">        <span class="keyword">if</span> (list_resize(self, m + n) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            Py_DECREF(iterable);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* 注意，对于a.extend(a)的情况，我们仍有self == iterable，</span></span><br><span class="line"><span class="comment">         * 但是下面的代码在这种情况下也可以工作。只需确保在调</span></span><br><span class="line"><span class="comment">         * 用PySequence_Fast_ITEMS之前调整self的大小。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">/* 用iterable的项填充self的末尾 */</span></span><br><span class="line">        src = PySequence_Fast_ITEMS(iterable);</span><br><span class="line">        dest = self-&gt;ob_item + m;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            PyObject *o = src[i];</span><br><span class="line">            Py_INCREF(o);</span><br><span class="line">            dest[i] = o;</span><br><span class="line">        &#125;</span><br><span class="line">        Py_DECREF(iterable);</span><br><span class="line">        Py_RETURN_NONE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    it = PyObject_GetIter(iterable);</span><br><span class="line">    <span class="keyword">if</span> (it == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    iternext = *it-&gt;ob_type-&gt;tp_iternext;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 猜测结果列表的大小。 */</span></span><br><span class="line">    n = PyObject_LengthHint(iterable, <span class="number">8</span>);</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        Py_DECREF(it);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    m = Py_SIZE(self);</span><br><span class="line">    <span class="keyword">if</span> (m &gt; PY_SSIZE_T_MAX - n) &#123;</span><br><span class="line">        <span class="comment">/* m + n溢出;如果n说谎了，而且确实有足够的空间，忽略它。</span></span><br><span class="line"><span class="comment">         * 如果n说的是真话，我们最终会在循环中耗尽内存。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        mn = m + n;</span><br><span class="line">        <span class="comment">/* 腾出空间 */</span></span><br><span class="line">        <span class="keyword">if</span> (list_resize(self, mn) &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">goto</span> error;</span><br><span class="line">        <span class="comment">/* 把列表重新整理一下。 */</span></span><br><span class="line">        Py_SIZE(self) = m;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 运行迭代器直到耗尽。 */</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        PyObject *item = iternext(it);</span><br><span class="line">        <span class="keyword">if</span> (item == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (PyErr_Occurred()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (PyErr_ExceptionMatches(PyExc_StopIteration))</span><br><span class="line">                    PyErr_Clear();</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="keyword">goto</span> error;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (Py_SIZE(self) &lt; self-&gt;allocated) &#123;</span><br><span class="line">            <span class="comment">/* steals ref */</span></span><br><span class="line">            PyList_SET_ITEM(self, Py_SIZE(self), item);</span><br><span class="line">            ++Py_SIZE(self);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> status = app1(self, item);</span><br><span class="line">            Py_DECREF(item);  <span class="comment">/* append创建一个新的ref */</span></span><br><span class="line">            <span class="keyword">if</span> (status &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">goto</span> error;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 如果最初的猜测太大，减少结果列表。*/</span></span><br><span class="line">    <span class="keyword">if</span> (Py_SIZE(self) &lt; self-&gt;allocated) &#123;</span><br><span class="line">        <span class="keyword">if</span> (list_resize(self, Py_SIZE(self)) &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">goto</span> error;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Py_DECREF(it);</span><br><span class="line">    Py_RETURN_NONE;</span><br><span class="line"></span><br><span class="line">  error:</span><br><span class="line">    Py_DECREF(it);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是个大函数，函数开头是一些变量的声明。如果参数 <code>iterable</code> 是列表类型或者元组类型又或者 <code>self</code> 与 <code>iterable</code> 相同，则调用 <code>PySequence_Fast</code>，这个函数的定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Objects/abstract.c */</span></span><br><span class="line"></span><br><span class="line">PyObject *</span><br><span class="line">PySequence_Fast(PyObject *v, <span class="keyword">const</span> <span class="keyword">char</span> *m)</span><br><span class="line">&#123;</span><br><span class="line">    PyObject *it;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (v == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> null_error();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (PyList_CheckExact(v) || PyTuple_CheckExact(v)) &#123;</span><br><span class="line">        Py_INCREF(v);</span><br><span class="line">        <span class="keyword">return</span> v;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    it = PyObject_GetIter(v);</span><br><span class="line">    <span class="keyword">if</span> (it == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (PyErr_ExceptionMatches(PyExc_TypeError))</span><br><span class="line">            PyErr_SetString(PyExc_TypeError, m);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    v = PySequence_List(it);</span><br><span class="line">    Py_DECREF(it);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数很简单，如果参数 <code>v</code> 是 <code>NULL</code> 则设置 <code>PyExc_SystemError</code> 并返回 <code>NULL</code>。如果 <code>v</code> 是列表类型或者元组类型则增加其引用计数然后返回它本身。否则调用 <code>PyObject_GetIter</code> 获取 <code>v</code> 的迭代器，再调用 <code>PySequence_List</code> 将迭代器转换成列表返回。</p><p>回到 <code>list_extend</code>，如果 <code>PySequence_Fast</code> 的返回值为 <code>NULL</code> 则返回 <code>NULL</code>，否则调用宏 <code>PySequence_Fast_GET_SIZE</code> 获取返回值的大小 <code>n</code>，如果大小为0则减少其引用计数并返回 <code>None</code>（是 <code>None</code>，不是 <code>NULL</code>）。相关宏定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PySequence_Fast_GET_SIZE(o) \</span></span><br><span class="line">    (PyList_Check(o) ? PyList_GET_SIZE(o) : PyTuple_GET_SIZE(o))</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Py_RETURN_NONE return Py_INCREF(Py_None), Py_None</span></span><br></pre></td></tr></table></figure><p><code>n</code> 不为0，获取 <code>self</code> 的大小 <code>m</code>，确保 <code>m + n</code> 小于 <code>PY_SSIZE_T_MAX</code>，然后调用 <code>list_resize</code> 调整 <code>self</code> 的大小为 <code>m + n</code>，函数实现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">list_resize(PyListObject *self, Py_ssize_t newsize)</span><br><span class="line">&#123;</span><br><span class="line">    PyObject **items;</span><br><span class="line">    <span class="keyword">size_t</span> new_allocated, num_allocated_bytes;</span><br><span class="line">    Py_ssize_t allocated = self-&gt;allocated;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 当以前的超额分配足够大以容纳newsize时，绕过realloc()。</span></span><br><span class="line"><span class="comment">     * 如果newsize小于分配大小的一半，则继续使用realloc()来</span></span><br><span class="line"><span class="comment">     * 缩小列表。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (allocated &gt;= newsize &amp;&amp; newsize &gt;= (allocated &gt;&gt; <span class="number">1</span>)) &#123;</span><br><span class="line">        assert(self-&gt;ob_item != <span class="literal">NULL</span> || newsize == <span class="number">0</span>);</span><br><span class="line">        Py_SIZE(self) = newsize;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 这种超额分配与列表大小成比例，为进一步增长腾出空间。</span></span><br><span class="line"><span class="comment">     * 超额分配是轻度的，但在系统realloc()性能不佳的的情况下，</span></span><br><span class="line"><span class="comment">     * 足以在一长串appends()上给出线性时间平摊行为。</span></span><br><span class="line"><span class="comment">     * 增长模式是： 0, 4, 8, 16, 25, 35, 46, 58, 72, 88, ...</span></span><br><span class="line"><span class="comment">     * 注意：new_allocated不会溢出，因为可能的最大值是</span></span><br><span class="line"><span class="comment">     * PY_SSIZE_T_MAX * (9 / 8) + 6，它总是适合size_t。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    new_allocated = (<span class="keyword">size_t</span>)newsize + (newsize &gt;&gt; <span class="number">3</span>) + (newsize &lt; <span class="number">9</span> ? <span class="number">3</span> : <span class="number">6</span>);</span><br><span class="line">    <span class="keyword">if</span> (new_allocated &gt; (<span class="keyword">size_t</span>)PY_SSIZE_T_MAX / <span class="keyword">sizeof</span>(PyObject *)) &#123;</span><br><span class="line">        PyErr_NoMemory();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (newsize == <span class="number">0</span>)</span><br><span class="line">        new_allocated = <span class="number">0</span>;</span><br><span class="line">    num_allocated_bytes = new_allocated * <span class="keyword">sizeof</span>(PyObject *);</span><br><span class="line">    items = (PyObject **)PyMem_Realloc(self-&gt;ob_item, num_allocated_bytes);</span><br><span class="line">    <span class="keyword">if</span> (items == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        PyErr_NoMemory();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    self-&gt;ob_item = items;</span><br><span class="line">    Py_SIZE(self) = newsize;</span><br><span class="line">    self-&gt;allocated = new_allocated;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>列表的 <code>allocated</code> 字段保存的是总分配的大小，如果 <code>newsize</code> 大于等于 <code>allocated</code> 的二分之一且小于等于 <code>allocated</code>，则直接将列表的大小设置为 <code>newsize</code> 并返回0。否则，通过公式 <code>newsize + (newsize &gt;&gt; 3) + (newsize &lt; 9 ? 3 : 6)</code> 计算新的分配大小，再检查 <code>new_allocated</code> 是否会造成溢出。</p><p>往下，如果 <code>newsize</code> 为0则也把 <code>new_allocated</code> 设为0。接着计算需要分配的内存，因为列表保存的是对象的指针，所以用 <code>new_allocated</code> 乘以 <code>PyObject</code> 指针的大小。然后，调用 <code>PyMem_Realloc</code> 重新分配内存，分配失败则返回-1，分配成功则更新列表字段的值并返回0表示执行成功。</p><p>再次回到 <code>list_extend</code>，<code>list_resize</code> 执行成功则往下，通过 <code>PySequence_Fast_ITEMS</code> 宏获取 <code>iterable</code> 的 <code>ob_item</code> 字段的值：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PySequence_Fast_ITEMS(sf) \</span></span><br><span class="line">    (PyList_Check(sf) ? ((PyListObject *)(sf))-&gt;ob_item \</span><br><span class="line">                      : ((PyTupleObject *)(sf))-&gt;ob_item)</span><br></pre></td></tr></table></figure><p>通过 <code>self-&gt;ob_item + m</code> 定位到 <code>self</code> 的 <code>ob_item</code> 的末尾，然后循环地将 <code>iterable</code> 的 <code>ob_item</code> 中的值添加到 <code>self</code> 的 <code>ob_item</code> 的末尾。最后减少 <code>iterable</code> 的引用计数并返回 <code>None</code>。</p><p>以上就是 <code>iterable</code> 为列表或者元组类型或者 <code>iterable</code> 等于 <code>self</code> 的情况。其他情况下，通过 <code>PyObject_GetIter</code> 获取 <code>iterable</code> 的迭代器 <code>it</code>，并获取该迭代器类型的 <code>__next__()</code> 函数。接着调用 <code>PyObject_LengthHint</code> 获取 <code>iterable</code> 的大小，这个函数会调用对象的 <code>__len__()</code> 或者 <code>__length_hint__()</code> 方法返回一个非负的整数值，如果这两个方法都不存在则返回默认值（也就是第二个参数）。调用失败会返回-1。这个函数计算的大小不一定准确。</p><p>接下来获取 <code>self</code> 的大小，然后检查 <code>m + n</code> 是否溢出，溢出的话什么都不做，不溢出则调用 <code>list_resize</code> 调整 <code>self</code> 的大小。根据前面对 <code>list_resize</code> 的分析，它会将 <code>self</code> 的大小设置成 <code>mn</code>（即 <code>m + n</code>），但是，这里的 <code>n</code> 并不一定是一个准确的大小，所以先将 <code>self</code> 的大小重设为 <code>m</code>。</p><p>往下，使用迭代器 <code>it</code> 的 <code>__next__()</code> 函数生成值，只要 <code>item</code> 不为 <code>NULL</code>，检查 <code>self</code> 的大小是否小于分配的大小，小于则使用 <code>PyList_SET_ITEM</code> 将 <code>item</code> 添加到 <code>self</code> 的末尾，然后 <code>self</code> 的大小加1。当 <code>self</code> 的大小大于分配的大小时，说明 <code>n</code> 比猜想的要大，这时调用 <code>app1</code> 函数进行追加，函数定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">app1(PyListObject *self, PyObject *v)</span><br><span class="line">&#123;</span><br><span class="line">    Py_ssize_t n = PyList_GET_SIZE(self);</span><br><span class="line"></span><br><span class="line">    assert (v != <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (n == PY_SSIZE_T_MAX) &#123;</span><br><span class="line">        PyErr_SetString(PyExc_OverflowError,</span><br><span class="line">            <span class="string">"cannot add more objects to list"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (list_resize(self, n+<span class="number">1</span>) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    Py_INCREF(v);</span><br><span class="line">    PyList_SET_ITEM(self, n, v);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PyList_SET_ITEM(op,i,v)  \</span></span><br><span class="line">    (((PyListObject *)(op))-&gt;ob_item[i] = (v))</span><br></pre></td></tr></table></figure><p>这个函数会进行溢出检查，这样即使实际的 <code>m + n</code> 越界了也能检测并正确地引发异常。 最后，当 <code>item</code> 为 <code>NULL</code> 时说明引发了异常，如果是 <code>StopIteration</code>，表示迭代器耗尽了值，是正常现象，只需将异常清除并跳出循环。如果是其它类型的异常，则返回 <code>NULL</code>。</p><p>运行到函数的末尾，如果 <code>self</code> 的大小小于分配的大小，则再调用一次 <code>list_resize</code> 检查是否需要重新调整大小（这种情况下，只有在实际大小小于分配大小的一半才会重新调整大小）。最后，减少迭代器的引用计数，返回 <code>None</code> 表示执行成功。</p><p>回到操作码的执行，<code>none_val</code> 接收 <code>_PyList_Extend</code> 的返回值，如果 <code>none_val</code> 为 <code>NULL</code>，说明中间有异常发生。此时，如果操作码是 <code>BUILD_TUPLE_UNPACK_WITH_CALL</code> 且异常是 <code>TypeError</code>，则调用 <code>check_args_iterable</code> 函数，<code>PEEK(1 + oparg)</code> 是 Python 代码调用的函数，如文章开头示例的函数 <code>f</code>。<code>check_args_iterable</code> 的实现如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Python/ceval.c */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">check_args_iterable(PyObject *func, PyObject *args)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (args-&gt;ob_type-&gt;tp_iter == <span class="literal">NULL</span> &amp;&amp; !PySequence_Check(args)) &#123;</span><br><span class="line">        PyErr_Format(PyExc_TypeError,</span><br><span class="line">                     <span class="string">"%.200s%.200s argument after * "</span></span><br><span class="line">                     <span class="string">"must be an iterable, not %.200s"</span>,</span><br><span class="line">                     PyEval_GetFuncName(func),</span><br><span class="line">                     PyEval_GetFuncDesc(func),</span><br><span class="line">                     args-&gt;ob_type-&gt;tp_name);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果本应该是可迭代对象的 <code>args</code> 没有实现 <code>__iter__()</code> 方法且不是序列对象，则设置 <code>TypeError</code>。再次回到操作码的执行，此时还将跳转到错误处理。</p><p>如果 <code>_PyList_Extend</code> 返回的是 <code>None</code>，则表示成功执行。当循环结束，所有的可迭代对象中的值都被追加到了列表 <code>sum</code> 中。如果 <code>convert_to_tuple</code> 为真，也就是当前操作码不是 <code>BUILD_LIST_UNPACK</code>，则需要将列表转换为元组。这是 <code>PyList_AsTuple</code> 函数的工作，函数定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Objects/listobject.c */</span></span><br><span class="line"></span><br><span class="line">PyObject *</span><br><span class="line">PyList_AsTuple(PyObject *v)</span><br><span class="line">&#123;</span><br><span class="line">    PyObject *w;</span><br><span class="line">    PyObject **p, **q;</span><br><span class="line">    Py_ssize_t n;</span><br><span class="line">    <span class="keyword">if</span> (v == <span class="literal">NULL</span> || !PyList_Check(v)) &#123;</span><br><span class="line">        PyErr_BadInternalCall();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    n = Py_SIZE(v);</span><br><span class="line">    w = PyTuple_New(n);</span><br><span class="line">    <span class="keyword">if</span> (w == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    p = ((PyTupleObject *)w)-&gt;ob_item;</span><br><span class="line">    q = ((PyListObject *)v)-&gt;ob_item;</span><br><span class="line">    <span class="keyword">while</span> (--n &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        Py_INCREF(*q);</span><br><span class="line">        *p = *q;</span><br><span class="line">        p++;</span><br><span class="line">        q++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> w;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数很简单。忽略参数检查，其实就是创建一个新的元组，然后将列表中的值复制到元组中，最后再返回元组。回到操作码的执行，往下将从值栈中弹出 <code>oparg</code> 个值，再将新的列表/元组压入值栈供后续的操作码使用。</p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python操作码——BUILD_SET_UNPACK</title>
      <link href="/python/python-opcode-BUILD_SET_UNPACK.html"/>
      <url>/python/python-opcode-BUILD_SET_UNPACK.html</url>
      
        <content type="html"><![CDATA[<p><code>BUILD_SET_UNPACK</code> 操作码的编号是153，是个带参数的操作码。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>dis.opmap[<span class="string">'BUILD_SET_UNPACK'</span>]</span><br><span class="line"><span class="number">153</span></span><br></pre></td></tr></table></figure><a id="more"></a><p>这是 Python3.5 新增的操作码，诸如 <code>{*(1, 2, 3)}</code> 这样的语法会生成这个操作码，<code>*</code> 后面跟着的是一个可迭代的对象，这里相当于 <code>set((1, 2, 3))</code>。一些用法示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>&#123;*(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)&#125;</span><br><span class="line">&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dis.dis(<span class="string">'&#123;*(1, 2, 3)&#125;'</span>)</span><br><span class="line">  <span class="number">1</span>           <span class="number">0</span> LOAD_CONST               <span class="number">0</span> ((<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>))</span><br><span class="line">              <span class="number">2</span> BUILD_SET_UNPACK         <span class="number">1</span></span><br><span class="line">              <span class="number">4</span> RETURN_VALUE</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>             </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>&#123;*(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>), *(<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>)&#125;</span><br><span class="line">&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dis.dis(<span class="string">'&#123;*(1, 2, 3), *(4, 5, 6)&#125;'</span>)</span><br><span class="line">  <span class="number">1</span>           <span class="number">0</span> LOAD_CONST               <span class="number">0</span> ((<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>))</span><br><span class="line">              <span class="number">2</span> LOAD_CONST               <span class="number">1</span> ((<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>))</span><br><span class="line">              <span class="number">4</span> BUILD_SET_UNPACK         <span class="number">2</span></span><br><span class="line">              <span class="number">6</span> RETURN_VALUE      </span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>&#123;*(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>), <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;</span><br><span class="line">&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dis.dis(<span class="string">'&#123;*(1, 2, 3), 4, 5, 6&#125;'</span>)</span><br><span class="line">  <span class="number">1</span>           <span class="number">0</span> LOAD_CONST               <span class="number">0</span> ((<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>))</span><br><span class="line">              <span class="number">2</span> LOAD_CONST               <span class="number">1</span> (<span class="number">4</span>)</span><br><span class="line">              <span class="number">4</span> LOAD_CONST               <span class="number">2</span> (<span class="number">5</span>)</span><br><span class="line">              <span class="number">6</span> LOAD_CONST               <span class="number">3</span> (<span class="number">6</span>)</span><br><span class="line">              <span class="number">8</span> BUILD_SET                <span class="number">3</span></span><br><span class="line">             <span class="number">10</span> BUILD_SET_UNPACK         <span class="number">2</span></span><br><span class="line">             <span class="number">12</span> RETURN_VALUE</span><br></pre></td></tr></table></figure><p>来看它的具体实现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">TARGET(BUILD_SET_UNPACK) &#123;</span><br><span class="line">    Py_ssize_t i;</span><br><span class="line">    PyObject *sum = PySet_New(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (sum == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">goto</span> error;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = oparg; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (_PySet_Update(sum, PEEK(i)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            Py_DECREF(sum);</span><br><span class="line">            <span class="keyword">goto</span> error;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (oparg--)</span><br><span class="line">        Py_DECREF(POP());</span><br><span class="line">    PUSH(sum);</span><br><span class="line">    DISPATCH();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>开头会调用 <code>PySet_New</code> 函数并传入 <code>NULL</code> 创建空集合，<code>PySet_New</code> 的分析参考 <code>BUILD_SET</code> 操作码。如果返回值为 <code>NULL</code>，表示创建失败，跳转到错误处理。</p><p>往下，<code>oparg</code> 是操作码的参数，表示所有可迭代对象的数量。通过 <code>PEEK</code> 宏从值栈中获取这些可迭代对象，并将它们作为参数传入 <code>_PySet_Update</code> 函数更新集合 <code>sum</code>。函数实现如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Objects/setobject.c */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">_PySet_Update(PyObject *<span class="built_in">set</span>, PyObject *iterable)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!PySet_Check(<span class="built_in">set</span>)) &#123;</span><br><span class="line">        PyErr_BadInternalCall();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> set_update_internal((PySetObject *)<span class="built_in">set</span>, iterable);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数只是对 <code>set_update_internal</code> 函数的包装，在调用 <code>set_update_internal</code> 前对参数进行检查，确保第一个参数是集合类型或者是集合类型的子类。<code>set_update_internal</code> 的实现如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Objects/setobject.c */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">set_update_internal(PySetObject *so, PyObject *other)</span><br><span class="line">&#123;</span><br><span class="line">    PyObject *key, *it;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (PyAnySet_Check(other))</span><br><span class="line">        <span class="keyword">return</span> set_merge(so, other);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (PyDict_CheckExact(other)) &#123;</span><br><span class="line">        PyObject *value;</span><br><span class="line">        Py_ssize_t pos = <span class="number">0</span>;</span><br><span class="line">        Py_hash_t hash;</span><br><span class="line">        Py_ssize_t dictsize = PyDict_GET_SIZE(other);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 在开始时进行一次大的调整大小，而不是在插入新键时</span></span><br><span class="line"><span class="comment">         * 逐步调整大小。期望没有(或很少)重叠键。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (dictsize &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span> ((so-&gt;<span class="built_in">fill</span> + dictsize)*<span class="number">5</span> &gt;= so-&gt;mask*<span class="number">3</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (set_table_resize(so, (so-&gt;used + dictsize)*<span class="number">2</span>) != <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (_PyDict_Next(other, &amp;pos, &amp;key, &amp;value, &amp;hash)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (set_add_entry(so, key, hash))</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    it = PyObject_GetIter(other);</span><br><span class="line">    <span class="keyword">if</span> (it == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> ((key = PyIter_Next(it)) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (set_add_key(so, key)) &#123;</span><br><span class="line">            Py_DECREF(it);</span><br><span class="line">            Py_DECREF(key);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Py_DECREF(key);</span><br><span class="line">    &#125;</span><br><span class="line">    Py_DECREF(it);</span><br><span class="line">    <span class="keyword">if</span> (PyErr_Occurred())</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数开头通过 <code>PyAnySet_Check</code> 宏检查第二个参数 <code>other</code> 是否集合类型、集合类型的子类、冻结集合与冻结集合的子类中的一个，如果是则调用 <code>set_merge</code> 合并两个集合。<code>PySet_Check</code> 与 <code>PyAnySet_Check</code> 的区别如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PyAnySet_Check(ob) \</span></span><br><span class="line">    (Py_TYPE(ob) == &amp;PySet_Type || Py_TYPE(ob) == &amp;PyFrozenSet_Type || \</span><br><span class="line">      PyType_IsSubtype(Py_TYPE(ob), &amp;PySet_Type) || \</span><br><span class="line">      PyType_IsSubtype(Py_TYPE(ob), &amp;PyFrozenSet_Type))</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PySet_Check(ob) \</span></span><br><span class="line">    (Py_TYPE(ob) == &amp;PySet_Type || \</span><br><span class="line">    PyType_IsSubtype(Py_TYPE(ob), &amp;PySet_Type))</span><br></pre></td></tr></table></figure><p>往下，检查 <code>other</code> 是否是字典类型，如果是，获取它的大小 <code>dictsize</code>，然后检查 <code>fill</code> 字段的值和 <code>dictsize</code> 之和与 <code>mask</code> 字段的值的比例是否超过3/5，超过了则调用 <code>set_table_resize</code> 重新调整表的大小。调整成功，调用 <code>_PyDict_Next</code> 获取字典的键，然后再调用 <code>set_add_entry</code> 将键添加到集合中。</p><blockquote><p>集合的 <code>table</code>/<code>smalltable</code> 字段保存值，值有三种状态：Unused、Dummy、Active。设 sum 函数是求个状态值的数量则有如下关系：</p><ul><li><code>mask + 1 == sum(Unused) + sum(Dummy) + sum(Active)</code></li><li><code>used == sum(Active)</code></li><li><code>fill == sum(Active) + sum(Dummy)</code></li></ul></blockquote><p>如果 <code>other</code> 不是字典类型，调用 <code>PyObject_GetIter</code> 获取 <code>other</code> 的迭代器，相当于 <code>it = iter(other)</code>，迭代器为 <code>NULL</code> 则直接返回，否则调用 <code>PyIter_Next</code> 获取值，相当于 <code>key = next(it)</code>。只要 <code>key</code> 不为 <code>NULL</code> 且 <code>set_add_key</code> 调用成功，就不断地为集合添加值，如果中间添加失败则返回-1。最后，添加完毕，调用 <code>PyErr_Occurred</code> 检查整个函数的执行有没有引发异常，没有则返回0表示调用成功。</p><p>回到操作码的执行，如果 <code>_PySet_Update</code> 返回的是-1则跳转到错误处理。最后，新集合更新完毕，从值栈中弹出 <code>oparg</code> 个值，再将新集合 <code>sum</code> 压入值栈中供后续的操作码使用。</p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python操作码——BUILD_MAP</title>
      <link href="/python/python-opcode-BUILD_MAP.html"/>
      <url>/python/python-opcode-BUILD_MAP.html</url>
      
        <content type="html"><![CDATA[<p><code>BUILD_MAP</code> 操作码的编号是105，是个带参数的操作码。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>dis.opmap[<span class="string">'BUILD_MAP'</span>]</span><br><span class="line"><span class="number">105</span></span><br></pre></td></tr></table></figure><a id="more"></a><p>使用 <code>{}</code> 创建字典时会生成这个操作码，一个简单的示例如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>dis.dis(<span class="string">'a, b =1, 2;d = &#123;a: 10, b: 20&#125;'</span>)</span><br><span class="line">  <span class="number">1</span>           <span class="number">0</span> LOAD_CONST               <span class="number">0</span> ((<span class="number">1</span>, <span class="number">2</span>))</span><br><span class="line">              <span class="number">2</span> UNPACK_SEQUENCE          <span class="number">2</span></span><br><span class="line">              <span class="number">4</span> STORE_NAME               <span class="number">0</span> (a)</span><br><span class="line">              <span class="number">6</span> STORE_NAME               <span class="number">1</span> (b)</span><br><span class="line">              <span class="number">8</span> LOAD_NAME                <span class="number">0</span> (a)</span><br><span class="line">             <span class="number">10</span> LOAD_CONST               <span class="number">1</span> (<span class="number">10</span>)</span><br><span class="line">             <span class="number">12</span> LOAD_NAME                <span class="number">1</span> (b)</span><br><span class="line">             <span class="number">14</span> LOAD_CONST               <span class="number">2</span> (<span class="number">20</span>)</span><br><span class="line">             <span class="number">16</span> BUILD_MAP                <span class="number">2</span></span><br><span class="line">             <span class="number">18</span> STORE_NAME               <span class="number">2</span> (d)</span><br><span class="line">             <span class="number">20</span> LOAD_CONST               <span class="number">3</span> (<span class="literal">None</span>)</span><br><span class="line">             <span class="number">22</span> RETURN_VALUE</span><br></pre></td></tr></table></figure><p>从序号8开始，会将键值对依序压入值栈中，序号16的 <code>BUILD_MAP</code> 创建字典，这里操作码的参数为2，表示有两个键值对。来看它的实现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">TARGET(BUILD_MAP) &#123;</span><br><span class="line">    Py_ssize_t i;</span><br><span class="line">    PyObject *<span class="built_in">map</span> = _PyDict_NewPresized((Py_ssize_t)oparg);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">map</span> == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">goto</span> error;</span><br><span class="line">    <span class="keyword">for</span> (i = oparg; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">int</span> err;</span><br><span class="line">        PyObject *key = PEEK(<span class="number">2</span>*i);</span><br><span class="line">        PyObject *value = PEEK(<span class="number">2</span>*i - <span class="number">1</span>);</span><br><span class="line">        err = PyDict_SetItem(<span class="built_in">map</span>, key, value);</span><br><span class="line">        <span class="keyword">if</span> (err != <span class="number">0</span>) &#123;</span><br><span class="line">            Py_DECREF(<span class="built_in">map</span>);</span><br><span class="line">            <span class="keyword">goto</span> error;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (oparg--) &#123;</span><br><span class="line">        Py_DECREF(POP());</span><br><span class="line">        Py_DECREF(POP());</span><br><span class="line">    &#125;</span><br><span class="line">    PUSH(<span class="built_in">map</span>);</span><br><span class="line">    DISPATCH();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数 <code>_PyDict_NewPresized</code> 用于创建预分配内存的空字典，参数是字典包含的键值对的数量。在分析这个函数前，先来简单了解定义字典对象的结构体。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Objects/dict-common.h</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="comment">/* 缓存me_key的hash码 */</span></span><br><span class="line">    Py_hash_t me_hash;</span><br><span class="line">    PyObject *me_key;</span><br><span class="line">    PyObject *me_value; <span class="comment">/* 此字段仅对合并表有意义 */</span></span><br><span class="line">&#125; PyDictKeyEntry;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* dict_lookup_func()返回条目索引可以像DK_ENTRIES(dk)[index]那样使用。当没有找到条目时返回-1，当比较出现错误时返回-3。*/</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">Py_ssize_t</span> <span class="params">(*dict_lookup_func)</span></span></span><br><span class="line"><span class="function">    <span class="params">(PyDictObject *mp, PyObject *key, Py_hash_t hash, PyObject **value_addr)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DKIX_EMPTY (-1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DKIX_DUMMY (-2)  <span class="comment">/* 在内部使用 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DKIX_ERROR (-3)</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">dictkeysobject</span> &#123;</span></span><br><span class="line">    Py_ssize_t dk_refcnt;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* hash表(dk_indices)的大小，必须是2的乘方。*/</span></span><br><span class="line">    Py_ssize_t dk_size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 在hash表(dk_indices)中检查的函数：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       - lookdict()：通用的，当(且仅当)比较引发异常时，可能返回DKIX_ERROR。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       - lookdict_unicode()：专用于键是unicode字符串，它的比较永远不会引发异常，该函数永远不能返回DKIX_ERROR。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       - lookdict_unicode_nodummy()：类似于lookdict_unicode()，但专门用于键是unicode字符串而值不是&lt;dummy&gt;。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       - lookdict_split()；用于分割表的lookdict()版本。 */</span></span><br><span class="line">    dict_lookup_func dk_lookup;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* dk_entries中可用的条目的数量。*/</span></span><br><span class="line">    Py_ssize_t dk_usable;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* dk_entries中已用的条目的数量。 */</span></span><br><span class="line">    Py_ssize_t dk_nentries;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* dk_size条目的实际hash表。它保存dk_entries的索引或DKIX_EMPTY(-1)或DKIX_DUMMY(-2)。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       索引必须为：0 &lt;= indice &lt; USABLE_FRACTION(dk_size).</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       索引的字节大小取决于dk_size:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       - 1字节如果 dk_size &lt;= 0xff (char*)</span></span><br><span class="line"><span class="comment">       - 2字节如果 dk_size &lt;= 0xffff (int16_t*)</span></span><br><span class="line"><span class="comment">       - 4字节如果 dk_size &lt;= 0xffffffff (int32_t*)</span></span><br><span class="line"><span class="comment">       - 8字节 其他情况 (int64_t*)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       动态大小，最小值是SIZEOF_VOID_P。*/</span></span><br><span class="line">    <span class="keyword">char</span> dk_indices[];  <span class="comment">/* 必须为char以避免 strict aliasing. */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* "PyDictKeyEntry dk_entries[dk_usable];" 数组如下：参见DK_ENTRIES()宏 */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Include/dictobject.h</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">dictkeysobject</span> <span class="title">PyDictKeysObject</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 对于合并表，ma_values指针为空。</span></span><br><span class="line"><span class="comment"> * 对于分割表，ma_values指针指向PyObject*数组。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    PyObject_HEAD</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 字典中条目的数量 */</span></span><br><span class="line">    Py_ssize_t ma_used;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 字典版本:全局唯一，值在每次修改字典时改变。*/</span></span><br><span class="line">    <span class="keyword">uint64_t</span> ma_version_tag;</span><br><span class="line"></span><br><span class="line">    PyDictKeysObject *ma_keys;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 如果ma_values是NULL, 表是“合并的”：</span></span><br><span class="line"><span class="comment">     * 键和值都存储在ma_keys中。</span></span><br><span class="line"><span class="comment">     * 如果ma_values不是NULL, 表时分开的：</span></span><br><span class="line"><span class="comment">     * 键存储在ma_keys中而值存储在ma_values中。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    PyObject **ma_values;</span><br><span class="line">&#125; PyDictObject;</span><br></pre></td></tr></table></figure><p>根据源码的注释，这些字段的作用不言自明，字典主要有两种形式：</p><ul><li><p>合并表：<code>ma_values == NULL, dk_refcnt == 1</code>，值存储在 <code>PyDictKeysObject</code> 的 <code>me_value</code> 字段中。</p></li><li><p>分割表：<code>ma_values != NULL, dk_refcnt &gt;= 1</code>，值存储在 <code>ma_values</code> 数组中。键只能是字符串。</p></li></ul><p>表中有四种槽，槽即是索引（<code>index</code>），如果<code>index &gt;= 0</code>，则<code>DK_ENTRIES(key)[index])</code>，这四种槽分别为：</p><ol><li><p><strong>Unused</strong>。<code>index == DKIX_EMPTY</code>，从未保存过键值对。这是每个槽的初始状态，当插入键时将会转换成 <strong>Active</strong> 状态。</p></li><li><p><strong>Active</strong>。<code>index &gt;= 0, me_key != NULL, me_value != NULL</code>，保存活跃的键值对。<strong>Active</strong> 可以在删除键时转换为 <strong>Dummy</strong> 或 <strong>Pending</strong> 状态（分别用于合并表和分割表）。这是 <code>me_value != NULL</code> 的唯一情况。</p></li><li><p><strong>Dummy</strong>。<code>index == DKIX_DUMMY</code>（仅用于合并表），曾经保存一个活跃的键值对，但已删除，目前还没被活跃的键值对覆盖。插入键时 <strong>Dummy</strong> 可以转换成 <strong>Active</strong>。<strong>Dummy</strong> 槽不能再转换成 <strong>Unused</strong>，否则在碰撞的情况下探测序列将无法知道它们曾经是 <strong>Active</strong>。</p></li><li><p><strong>Pending</strong>。<code>index &gt;= 0, key != NULL, value == NULL</code>（仅用于分割表），分割表中尚未插入的槽。</p></li></ol><p>来看 <code>_PyDict_NewPresized</code> 函数的实现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Objects/dictobject.c</span></span><br><span class="line"></span><br><span class="line">PyObject *</span><br><span class="line">_PyDict_NewPresized(Py_ssize_t minused)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">const</span> Py_ssize_t max_presize = <span class="number">128</span> * <span class="number">1024</span>;</span><br><span class="line">    Py_ssize_t newsize;</span><br><span class="line">    PyDictKeysObject *new_keys;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 不能严格保证返回的dict在不调整大小的情况下可以</span></span><br><span class="line"><span class="comment">     * 包含minused大小的项。所以我们创建了中等大小的字典</span></span><br><span class="line"><span class="comment">     * 而不是非常大的字典或MemoryError。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (minused &gt; USABLE_FRACTION(max_presize)) &#123;</span><br><span class="line">        newsize = max_presize;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        Py_ssize_t minsize = ESTIMATE_SIZE(minused);</span><br><span class="line">        newsize = PyDict_MINSIZE;</span><br><span class="line">        <span class="keyword">while</span> (newsize &lt; minsize) &#123;</span><br><span class="line">            newsize &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    assert(IS_POWER_OF_2(newsize));</span><br><span class="line"></span><br><span class="line">    new_keys = new_keys_object(newsize);</span><br><span class="line">    <span class="keyword">if</span> (new_keys == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> new_dict(new_keys, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>max_presize</code> 是最大的预留大小，<code>USABLE_FRACTION</code> 是一个宏，用于计算字典的最大负载——为字典中槽的数量的2/3，字典中键值对的数量超过这个值时会重新调整大小。如果参数 <code>minused</code> 超过 <code>max_presize</code> 的2/3，则预留大小 <code>newsize</code> 直接等于 <code>max_presize</code>；否则，通过 <code>ESTIMATE_SIZE</code> 宏计算预留大小。<code>ESTIMATE_SIZE</code> 宏是 <code>USABLE_FRACTION</code> 宏的反向。<code>PyDict_MINSIZE</code> 也是一个宏，如果 <code>minsize</code> 大于 <code>newsize</code>，则不断将 <code>newsize</code> 左移一位直到它大于 <code>minsize</code>，这样保证了 <code>newsize</code> 是2的乘方。几个宏的定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> USABLE_FRACTION(n) (((n) &lt;&lt; 1)/3)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ESTIMATE_SIZE(n) (((n)*3+1) &gt;&gt; 1)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PyDict_MINSIZE 8</span></span><br></pre></td></tr></table></figure><p>往下，确保 <code>newsize</code> 是2的乘方，宏 <code>IS_POWER_OF_2</code> 定义如下：<code>#define IS_POWER_OF_2(x) (((x) &amp; (x-1)) == 0)</code>。然后，调用 <code>new_keys_object</code> 函数创建并初始化 <code>PyDictKeysObject</code> 结构。函数定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Objects/dictobject.c</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> PyDictKeysObject *<span class="title">new_keys_object</span><span class="params">(Py_ssize_t <span class="built_in">size</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    PyDictKeysObject *dk;</span><br><span class="line">    Py_ssize_t es, usable;</span><br><span class="line"></span><br><span class="line">    assert(<span class="built_in">size</span> &gt;= PyDict_MINSIZE);</span><br><span class="line">    assert(IS_POWER_OF_2(<span class="built_in">size</span>));</span><br><span class="line"></span><br><span class="line">    usable = USABLE_FRACTION(<span class="built_in">size</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">size</span> &lt;= <span class="number">0xff</span>) &#123;</span><br><span class="line">        es = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">size</span> &lt;= <span class="number">0xffff</span>) &#123;</span><br><span class="line">        es = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> SIZEOF_VOID_P &gt; 4</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">size</span> &lt;= <span class="number">0xffffffff</span>) &#123;</span><br><span class="line">        es = <span class="number">4</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        es = <span class="keyword">sizeof</span>(Py_ssize_t);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">size</span> == PyDict_MINSIZE &amp;&amp; numfreekeys &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        dk = keys_free_list[--numfreekeys];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        dk = PyObject_MALLOC(<span class="keyword">sizeof</span>(PyDictKeysObject)</span><br><span class="line">                             + es * <span class="built_in">size</span></span><br><span class="line">                             + <span class="keyword">sizeof</span>(PyDictKeyEntry) * usable);</span><br><span class="line">        <span class="keyword">if</span> (dk == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            PyErr_NoMemory();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    DK_DEBUG_INCREF dk-&gt;dk_refcnt = <span class="number">1</span>;</span><br><span class="line">    dk-&gt;dk_size = <span class="built_in">size</span>;</span><br><span class="line">    dk-&gt;dk_usable = usable;</span><br><span class="line">    dk-&gt;dk_lookup = lookdict_unicode_nodummy;</span><br><span class="line">    dk-&gt;dk_nentries = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(&amp;dk-&gt;dk_indices[<span class="number">0</span>], <span class="number">0xff</span>, es * <span class="built_in">size</span>);</span><br><span class="line">    <span class="built_in">memset</span>(DK_ENTRIES(dk), <span class="number">0</span>, <span class="keyword">sizeof</span>(PyDictKeyEntry) * usable);</span><br><span class="line">    <span class="keyword">return</span> dk;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数开头是一些变量的声明和参数的检查。接着，通过 <code>USABLE_FRACTION</code> 计算出参数 <code>size</code> 的2/3大小，这是初始状态下可用于存储键值对的大小。往下，通过比较 <code>size</code> 的值确定索引值所占的字节数。</p><p>再往下分析之前先简单了解 <code>PyDictKeysObject</code> 的实际布局。这个结构体的最后一个字段是未指定长度的数组，这是一个弹性数组成员，<code>sizeof(PyDictKeysObject)</code> 不包含它的大小。<code>PyDictKeysObject</code> 的实际布局如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">+---------------+</span></span><br><span class="line"><span class="comment">| dk_refcnt     |</span></span><br><span class="line"><span class="comment">| dk_size       |</span></span><br><span class="line"><span class="comment">| dk_lookup     |</span></span><br><span class="line"><span class="comment">| dk_usable     |</span></span><br><span class="line"><span class="comment">| dk_nentries   |</span></span><br><span class="line"><span class="comment">+---------------+</span></span><br><span class="line"><span class="comment">| dk_indices    |</span></span><br><span class="line"><span class="comment">|               |</span></span><br><span class="line"><span class="comment">+---------------+</span></span><br><span class="line"><span class="comment">| dk_entries    |</span></span><br><span class="line"><span class="comment">|               |</span></span><br><span class="line"><span class="comment">+---------------+</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p><code>dk_indices</code> 保存的是 <code>PyDictKeyEntry</code> 在 <code>dk_entries</code> 中的索引，<code>dk_entries</code> 通过 <code>DK_ENTRIES</code> 宏定位，定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DK_ENTRIES(dk) \</span></span><br><span class="line">    ((PyDictKeyEntry*)(&amp;((<span class="keyword">int8_t</span>*)((dk)-&gt;dk_indices))[DK_SIZE(dk) * DK_IXSIZE(dk)]))</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DK_SIZE(dk) ((dk)-&gt;dk_size)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> SIZEOF_VOID_P &gt; 4</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DK_IXSIZE(dk)                          \</span></span><br><span class="line">    (DK_SIZE(dk) &lt;= <span class="number">0xff</span> ?                     \</span><br><span class="line">        <span class="number">1</span> : DK_SIZE(dk) &lt;= <span class="number">0xffff</span> ?            \</span><br><span class="line">            <span class="number">2</span> : DK_SIZE(dk) &lt;= <span class="number">0xffffffff</span> ?    \</span><br><span class="line">                <span class="number">4</span> : <span class="keyword">sizeof</span>(<span class="keyword">int64_t</span>))</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DK_IXSIZE(dk)                          \</span></span><br><span class="line">    (DK_SIZE(dk) &lt;= <span class="number">0xff</span> ?                     \</span><br><span class="line">        <span class="number">1</span> : DK_SIZE(dk) &lt;= <span class="number">0xffff</span> ?            \</span><br><span class="line">            <span class="number">2</span> : <span class="keyword">sizeof</span>(<span class="keyword">int32_t</span>))</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>这个宏有点复杂，需要拆开来分析。<code>(int8_t*)((dk)-&gt;dk_indices)</code> 获取参数 <code>dk</code> 的 <code>dk_indices</code> 字段并将它转换成 <code>int8_t *</code> 类型，<code>int8_t</code> 大小是1个字节。接下来是索引操作 <code>((int8_t*)((dk)-&gt;dk_indices))[DK_SIZE(dk) * DK_IXSIZE(dk)]</code>，方括号中的内容计算的是保存所有索引所需的字节数。最后通过 <code>&amp;</code> 取地址并转换成 <code>PyDictKeyEntry *</code> 类型，以字典 <code>d = {&#39;one&#39;: 3, &#39;four&#39;: 4, &#39;seven&#39;: 5}</code> 为例，它的各个键的hash码与索引位置分别是：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>hashcode = [hash(i) <span class="keyword">for</span> i <span class="keyword">in</span> d.keys()]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>hashcode</span><br><span class="line">[<span class="number">8958378740847757116</span>, <span class="number">-6692500557144227041</span>, <span class="number">-9200291166673549691</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>idx = [i % <span class="number">8</span> <span class="keyword">for</span> i <span class="keyword">in</span> hashcode]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>idx</span><br><span class="line">[<span class="number">4</span>, <span class="number">7</span>, <span class="number">5</span>]</span><br></pre></td></tr></table></figure><p>它的 <code>dk_indices</code> 字段的内存布局为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">+----+</span><br><span class="line">| -1 |  0  &lt;---- (dk)-&gt;dk_indices</span><br><span class="line">+----+</span><br><span class="line">| -1 |  1</span><br><span class="line">+----+  </span><br><span class="line">| -1 |  2</span><br><span class="line">+----+</span><br><span class="line">| -1 |  3</span><br><span class="line">+----+</span><br><span class="line">| 0  |  4</span><br><span class="line">+----+</span><br><span class="line">| 2  |  5</span><br><span class="line">+----+</span><br><span class="line">| -1 |  6</span><br><span class="line">+----+</span><br><span class="line">| 1  |  7</span><br><span class="line">+----+-----------------+---------+-----+</span><br><span class="line">| 8958378740847757116  | &apos;red&apos;   | 25  |    0  &lt;--- DK_ENTRIES(dk)</span><br><span class="line">+----------------------+---------+-----+</span><br><span class="line">| -6692500557144227041 | &apos;green&apos; | 125 |    1</span><br><span class="line">+----------------------+---------+-----+</span><br><span class="line">| -9200291166673549691 | &apos;blue&apos;  | 225 |    2</span><br><span class="line">+----------------------+---------+-----+</span><br><span class="line">|                      |         |     |    3</span><br><span class="line">+----------------------+---------+-----+</span><br><span class="line">|                      |         |     |    4</span><br><span class="line">+----------------------+---------+-----+</span><br></pre></td></tr></table></figure><p>继续函数的分析，如果 <code>size</code> 为8且 <code>numfreekeys</code> 大于0，则直接从 <code>keys_free_list</code> 数组中取出缓存的 <code>PyDictKeysObject</code>。缓存相关的函数和变量的定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> PyDict_MAXFREELIST</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PyDict_MAXFREELIST 80</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> PyDictKeysObject *keys_free_list[PyDict_MAXFREELIST];</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> numfreekeys = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">free_keys_object(PyDictKeysObject *keys)</span><br><span class="line">&#123;</span><br><span class="line">    PyDictKeyEntry *entries = DK_ENTRIES(keys);</span><br><span class="line">    Py_ssize_t i, n;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>, n = keys-&gt;dk_nentries; i &lt; n; i++) &#123;</span><br><span class="line">        Py_XDECREF(entries[i].me_key);</span><br><span class="line">        Py_XDECREF(entries[i].me_value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (keys-&gt;dk_size == PyDict_MINSIZE &amp;&amp; numfreekeys &lt; PyDict_MAXFREELIST) &#123;</span><br><span class="line">        keys_free_list[numfreekeys++] = keys;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    PyObject_FREE(keys);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，只有 <code>dk_size</code> 字段的值为8才会缓存，这样可以减少小字典 <code>malloc</code> 和 <code>free</code> 的次数。</p><p>进入 <code>else</code> 子句，调用 <code>PyObject_MALLOC</code> 函数为 <code>PyDictKeysObject</code> 结构体分配内存，分配的大小是 <code>PyDictKeysObject</code> 部分的大小、索引部分的大小与 <code>PyDictKeyEntry</code> 部分的大小之和。分配成功后对字段进行初始化然后返回。分配失败则返回 <code>NULL</code>。</p><p>回到 <code>_PyDict_NewPresized</code> 函数，如果返回值为 <code>NULL</code> 则函数直接返回 <code>NULL</code>，否则调用 <code>new_dict</code> 函数创建字典对象，函数定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> PyObject *</span><br><span class="line">new_dict(PyDictKeysObject *keys, PyObject **values)</span><br><span class="line">&#123;</span><br><span class="line">    PyDictObject *mp;</span><br><span class="line">    assert(keys != <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (numfree) &#123;</span><br><span class="line">        mp = free_list[--numfree];</span><br><span class="line">        assert (mp != <span class="literal">NULL</span>);</span><br><span class="line">        assert (Py_TYPE(mp) == &amp;PyDict_Type);</span><br><span class="line">        _Py_NewReference((PyObject *)mp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        mp = PyObject_GC_New(PyDictObject, &amp;PyDict_Type);</span><br><span class="line">        <span class="keyword">if</span> (mp == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            DK_DECREF(keys);</span><br><span class="line">            free_values(values);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    mp-&gt;ma_keys = keys;</span><br><span class="line">    mp-&gt;ma_values = values;</span><br><span class="line">    mp-&gt;ma_used = <span class="number">0</span>;</span><br><span class="line">    mp-&gt;ma_version_tag = DICT_NEXT_VERSION();</span><br><span class="line">    assert(_PyDict_CheckConsistency(mp));</span><br><span class="line">    <span class="keyword">return</span> (PyObject *)mp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数不算复杂，<code>numfree</code> 和 <code>free_list</code> <code>与字典缓存相关，numfree</code> 大于0说明 <code>free_list</code> 中存有释放过的字典缓存，简单地取出重用即可。相关的变量和函数定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> PyDictObject *free_list[PyDict_MAXFREELIST];</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> numfree = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">dict_dealloc(PyDictObject *mp)</span><br><span class="line">&#123;</span><br><span class="line">    PyObject **values = mp-&gt;ma_values;</span><br><span class="line">    PyDictKeysObject *keys = mp-&gt;ma_keys;</span><br><span class="line">    Py_ssize_t i, n;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* bpo-31095: UnTrack is needed before calling any callbacks */</span></span><br><span class="line">    PyObject_GC_UnTrack(mp);</span><br><span class="line">    Py_TRASHCAN_SAFE_BEGIN(mp)</span><br><span class="line">    <span class="keyword">if</span> (values != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (values != empty_values) &#123;</span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">0</span>, n = mp-&gt;ma_keys-&gt;dk_nentries; i &lt; n; i++) &#123;</span><br><span class="line">                Py_XDECREF(values[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            free_values(values);</span><br><span class="line">        &#125;</span><br><span class="line">        DK_DECREF(keys);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (keys != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        assert(keys-&gt;dk_refcnt == <span class="number">1</span>);</span><br><span class="line">        DK_DECREF(keys);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 看这里 */</span></span><br><span class="line">    <span class="keyword">if</span> (numfree &lt; PyDict_MAXFREELIST &amp;&amp; Py_TYPE(mp) == &amp;PyDict_Type)</span><br><span class="line">        free_list[numfree++] = mp;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        Py_TYPE(mp)-&gt;tp_free((PyObject *)mp);</span><br><span class="line">    Py_TRASHCAN_SAFE_END(mp)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>缓存相关的部分已在源码中标出，只要缓存的数量没有达到上限且释放的是字典类型则将其保存到 <code>free_list</code> 中，否则释放其内存。</p><p>如果缓存不存在，则调用 <code>PyObject_GC_New</code> 分配内存，分配成功则进行字段初始化并返回，失败则返回 <code>NULL</code>。<code>DICT_NEXT_VERSION</code> 是个宏：<code>#define DICT_NEXT_VERSION() (++pydict_global_version)</code>，<code>pydict_global_version</code> 是个全局静态变量，在字典创建和每次修改时都会递增。</p><p>回到操作码的执行，如果 <code>_PyDict_NewPresized</code> 的返回值为 <code>NULL</code> 则跳转到错误处理。从值栈中获取键和值并调用 <code>PyDict_SetItem</code> 为空字典 <code>map</code> 设置条目。<br><code>PyDict_SetItem</code> 执行失败时会返回-1，所以如果 <code>err</code> 不为0则会跳转到错误处理。最后，全部设置成功，从值栈中弹出所有的键和值并将字典压入值栈中供之后执行的操作码使用。</p><p>简单图解 <code>PEEK</code> 宏：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PEEK(n) (stack_pointer[-(n)])</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">假设创建的字典为 &#123;k1: v1, k2: v2, k3: v3&#125;，oparg = 3，则值栈为：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">|       |   &lt;--- stack_pointer</span></span><br><span class="line"><span class="comment">+-------+-------------------------------------------</span></span><br><span class="line"><span class="comment">|  v3   |   PEEK(1) =&gt; stack_pointer - 1  </span></span><br><span class="line"><span class="comment">+-------+                                  i = 1</span></span><br><span class="line"><span class="comment">|  k3   |   PEEK(2) =&gt; stack_pointer - 2  </span></span><br><span class="line"><span class="comment">+-------+-------------------------------------------</span></span><br><span class="line"><span class="comment">|  v2   |   PEEK(3) =&gt; stack_pointer - 3  </span></span><br><span class="line"><span class="comment">+-------+                                  i = 2</span></span><br><span class="line"><span class="comment">|  k2   |   PEEK(4) =&gt; stack_pointer - 4  </span></span><br><span class="line"><span class="comment">+-------+-------------------------------------------</span></span><br><span class="line"><span class="comment">|  v1   |   PEEK(5) =&gt; stack_pointer - 5  </span></span><br><span class="line"><span class="comment">+-------+                                  i = 3</span></span><br><span class="line"><span class="comment">|  k1   |   PEEK(6) =&gt; stack_pointer - 6  </span></span><br><span class="line"><span class="comment">+-------+-------------------------------------------</span></span><br><span class="line"><span class="comment">|  ...  |</span></span><br><span class="line"><span class="comment">+-------+</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python操作码——BUILD_SET</title>
      <link href="/python/python-opcode-BUILD_SET.html"/>
      <url>/python/python-opcode-BUILD_SET.html</url>
      
        <content type="html"><![CDATA[<p><code>BUILD_SET</code> 操作码的编号是104，是个带参数的操作码。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>dis.opmap[<span class="string">'BUILD_SET'</span>]</span><br><span class="line"><span class="number">104</span></span><br></pre></td></tr></table></figure><a id="more"></a><p>使用 <code>{}</code> 创建集合是会生成这个操作码，注意，<code>{}</code> 中一定要包含值，否则创建出来的是空字典。要创建空集合需要调用构造器 <code>set()</code>，不过调用 <code>set()</code> 生成的操作码是 <code>CALL_FUNCTION</code> 而不是 <code>BUILD_SET</code>。</p><p>来看看它的实现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">TARGET(BUILD_SET) &#123;</span><br><span class="line">    PyObject *<span class="built_in">set</span> = PySet_New(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">int</span> err = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">set</span> == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">goto</span> error;</span><br><span class="line">    <span class="keyword">for</span> (i = oparg; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">        PyObject *item = PEEK(i);</span><br><span class="line">        <span class="keyword">if</span> (err == <span class="number">0</span>)</span><br><span class="line">            err = PySet_Add(<span class="built_in">set</span>, item);</span><br><span class="line">        Py_DECREF(item);</span><br><span class="line">    &#125;</span><br><span class="line">    STACKADJ(-oparg);</span><br><span class="line">    <span class="keyword">if</span> (err != <span class="number">0</span>) &#123;</span><br><span class="line">        Py_DECREF(<span class="built_in">set</span>);</span><br><span class="line">        <span class="keyword">goto</span> error;</span><br><span class="line">    &#125;</span><br><span class="line">    PUSH(<span class="built_in">set</span>);</span><br><span class="line">    DISPATCH();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>开头直接调用了 <code>PySet_New</code>，这是底层创建集合对象的函数，传入参数 <code>NULL</code> 表示创建一个空集合。来看看这个函数的实现，在 Objects/setobject.c 中定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">PyObject *</span><br><span class="line">PySet_New(PyObject *iterable)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> make_new_set(&amp;PySet_Type, iterable);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到这个函数只是对 <code>make_new_set</code> 的简单包装，创建集合和冻结集合都会调用这个函数，它的第一个参数表示类型。这里传入的就是集合类型。</p><p>在分析这个函数之前先来看看定义集合类型的结构体：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PySet_MINSIZE 8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    PyObject *key;</span><br><span class="line">    Py_hash_t hash;             <span class="comment">/* 缓存key的哈希码 */</span></span><br><span class="line">&#125; setentry;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    PyObject_HEAD</span><br><span class="line"></span><br><span class="line">    Py_ssize_t <span class="built_in">fill</span>;            <span class="comment">/* 有效的和虚拟的条目的数量 */</span></span><br><span class="line">    Py_ssize_t used;            <span class="comment">/* 有效的条目的数量 */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 表中包含mask + 1个槽，且是2的乘方。</span></span><br><span class="line"><span class="comment">     * 我们保存mask而不是表的大小是因为mask更常用。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Py_ssize_t mask;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 如果表较小则table指向固定大小的smalltable。</span></span><br><span class="line"><span class="comment">     * 如果表较大则指向额外分配的内存。</span></span><br><span class="line"><span class="comment">     * table指针不会为空，这使我们避免了重复的运行时null测试。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    setentry *table;</span><br><span class="line">    Py_hash_t hash;             <span class="comment">/* 仅用于frozenset对象 */</span></span><br><span class="line">    Py_ssize_t finger;          <span class="comment">/* 用于pop()的搜索指针 */</span></span><br><span class="line"></span><br><span class="line">    setentry smalltable[PySet_MINSIZE];</span><br><span class="line">    PyObject *weakreflist;      <span class="comment">/* 弱引用列表 */</span></span><br><span class="line">&#125; PySetObject;</span><br></pre></td></tr></table></figure><p>简单解释一些字段，<code>setentry</code> 是存储集合对象单个元素的结构体。集合的所有元素保存在 <code>table</code> 中，当集合中的元素的数量不大于8时，则会保存在 <code>smalltable</code> 中，此时 <code>table</code> 会指向 <code>smalltable</code>。如果集合中元素的数量大于8，则 <code>table</code> 会指向额外分配的内存。<code>table</code> 的总大小是 <code>mask + 1</code>，集合对象元素的数量由 <code>used</code> 维护，<code>fill</code> 字段则是集合元素的数量与 <code>table</code> 中被标记为 <code>dummy</code> 的槽的数量的和。</p><p>现在开始 <code>make_new_set</code> 函数的分析。先来看它的实现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> PyObject *</span><br><span class="line">make_new_set(PyTypeObject *type, PyObject *iterable)</span><br><span class="line">&#123;</span><br><span class="line">    PySetObject *so;</span><br><span class="line"></span><br><span class="line">    so = (PySetObject *)type-&gt;tp_alloc(type, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (so == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    so-&gt;<span class="built_in">fill</span> = <span class="number">0</span>;</span><br><span class="line">    so-&gt;used = <span class="number">0</span>;</span><br><span class="line">    so-&gt;mask = PySet_MINSIZE - <span class="number">1</span>;</span><br><span class="line">    so-&gt;table = so-&gt;smalltable;</span><br><span class="line">    so-&gt;hash = <span class="number">-1</span>;</span><br><span class="line">    so-&gt;finger = <span class="number">0</span>;</span><br><span class="line">    so-&gt;weakreflist = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (iterable != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (set_update_internal(so, iterable)) &#123;</span><br><span class="line">            Py_DECREF(so);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (PyObject *)so;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>type-&gt;tp_alloc</code> 指向的是 <code>PyType_GenericAlloc</code> 函数，这是 Python 底层通用的对象内存分配函数，第二个参数是元素的数量，这里要创建的是空集合，所以为0。如果函数返回 <code>NULL</code> 则说明内存分配失败，所以 <code>make_new_set</code> 也返回 <code>NULL</code>。不为 <code>NULL</code> 说明内存分配成功，所以往下对结构体的字段进行设置。再往下检查参数 <code>iterable</code> 的值，不为 <code>NULL</code> 会调用 <code>set_update_internal</code> 为这个新创建的集合对象设置值。这里 <code>iterable</code> 为 <code>NULL</code>，暂时不深入这个函数（有空我会写一遍文章详细分析所有的步骤）。最后，返回集合对象。</p><p>回到操作码的执行，返回值 <code>set</code> 为 <code>NULL</code> 则直接跳转到错误处理。往下，<code>oparg</code> 是操作码的参数，表示要创建的集合对象的元素的数量。集合中的元素早已先压入了值栈，这里通过一个循环，使用 <code>PEEK</code> 宏：<code>#define PEEK(n) (stack_pointer[-(n)])</code> 获取值栈中属于集合的元素，调用 <code>PySet_Add</code> 函数为集合设置值。<code>PySet_Add</code> 执行成功时返回值为0，所以只要返回值为0就会执行直到设置完成。</p><p>设置完成，使用 <code>STACKADJ</code> 宏调整值栈栈顶指针，将值栈中的集合的元素全部弹出。如果 <code>err</code> 不为0，说明设置值的过程中引发了异常，所以跳转到错误处理；否则，将集合对象压入值栈中，供后面的操作码使用。</p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python操作码——BUILD_STRING</title>
      <link href="/python/python-opcode-BUILD_STRING.html"/>
      <url>/python/python-opcode-BUILD_STRING.html</url>
      
        <content type="html"><![CDATA[<p><code>BUILD_STRING</code> 操作码的编号是157，是个带参数的操作码。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>dis.opmap[<span class="string">'BUILD_STRING'</span>]</span><br><span class="line"><span class="number">157</span></span><br></pre></td></tr></table></figure><a id="more"></a><p>使用字面量创建字符串并不会生成这个操作码，字符串作为不可变对象，会在生成字节码之前创建以优化字节码的执行。这个操作码是 Python3.6 新增的，用于优化 f-string。一个简单的示例如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>dis.dis(<span class="string">'f"&#123;123&#125;" "456"'</span>)</span><br><span class="line">  <span class="number">1</span>           <span class="number">0</span> LOAD_CONST               <span class="number">0</span> (<span class="number">123</span>)</span><br><span class="line">              <span class="number">2</span> FORMAT_VALUE             <span class="number">0</span></span><br><span class="line">              <span class="number">4</span> LOAD_CONST               <span class="number">1</span> (<span class="string">'456'</span>)</span><br><span class="line">              <span class="number">6</span> BUILD_STRING             <span class="number">2</span></span><br><span class="line">              <span class="number">8</span> RETURN_VALUE</span><br></pre></td></tr></table></figure><p>来看操作码的实现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">TARGET(BUILD_STRING) &#123;</span><br><span class="line">    PyObject *str;</span><br><span class="line">    PyObject *empty = PyUnicode_New(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (empty == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">goto</span> error;</span><br><span class="line">    &#125;</span><br><span class="line">    str = _PyUnicode_JoinArray(empty, stack_pointer - oparg, oparg);</span><br><span class="line">    Py_DECREF(empty);</span><br><span class="line">    <span class="keyword">if</span> (str == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">goto</span> error;</span><br><span class="line">    <span class="keyword">while</span> (--oparg &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        PyObject *item = POP();</span><br><span class="line">        Py_DECREF(item);</span><br><span class="line">    &#125;</span><br><span class="line">    PUSH(str);</span><br><span class="line">    DISPATCH();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>PyUnicode_New</code> 是底层用于创建字符串对象的函数，这里传入的两个参数都为0表示创建空字符串对象。<code>PyUnicode_New</code> 函数涉及的知识点较多，这里暂时不展开，函数调用成功会返回一个空字符串，由 <code>empty</code> 接收。如果 <code>empty</code> 为 <code>NULL</code> 则跳转到错误处理部分。</p><p>往下，将调用函数 <code>_PyUnicode_JoinArray</code>。这是底层执行字符串拼接的函数，字符串的 <code>join</code> 方法最后也会调用这个函数。这里 <code>oparg</code> 是操作码的参数，表示要拼接的字符串的数量。<code>stack_pointer - oparg</code> 则是所有要拼接的字符串。这个函数的调用就相当于 <code>&#39;&#39;.join([str1, str2, ...])</code>，函数执行成功会返回拼接好的字符串，失败则会返回 <code>NULL</code>。</p><p>接下来，<code>empty</code> 在后面已经没有用了，减少其引用计数，如果 <code>str</code> 为 <code>NULL</code>，跳转到错误处理。否则，从值栈中弹出 <code>oparg</code> 个值，并减少它们的引用计数。最后将 <code>str</code> 压入值栈中供后面的操作码使用。</p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python操作码——BUILD_TUPLE</title>
      <link href="/python/python-opcode-BUILD_TUPLE.html"/>
      <url>/python/python-opcode-BUILD_TUPLE.html</url>
      
        <content type="html"><![CDATA[<p><code>BUILD_TUPLE</code> 操作码的编号是102，是个带参数的操作码。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>dis.opmap[<span class="string">'BUILD_LIST'</span>]</span><br><span class="line"><span class="number">103</span></span><br></pre></td></tr></table></figure><a id="more"></a><p>在 Python 中使用 <code>()</code> 创建元组时会生成这个字节码。当然，说使用 <code>()</code> 创建元组有点不大准确，当元组包含多个元素时，只使用 <code>,</code> 分隔元素也能创建元组，比如：<code>a = 1, 2</code>。不过有一点要注意的是，要创建只包含一个元素的元组时不能这么写：<code>a = (1)</code>，这种写法等价于 <code>a = 1</code>，需要使用 <code>a = (1,)</code> 或者 <code>a = 1,</code> 这种写法。还有一点需要注意的是，当元组中的元素全部是 Python 中的不可变类型的字面量时，将不会生成这个操作码，而是会提前创建出来，比如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>dis.dis(<span class="string">'a = 1, 2, (3, 4)'</span>)</span><br><span class="line">  <span class="number">1</span>           <span class="number">0</span> LOAD_CONST               <span class="number">6</span> ((<span class="number">1</span>, <span class="number">2</span>, (<span class="number">3</span>, <span class="number">4</span>)))</span><br><span class="line">              <span class="number">2</span> STORE_NAME               <span class="number">0</span> (a)</span><br><span class="line">              <span class="number">4</span> LOAD_CONST               <span class="number">4</span> (<span class="literal">None</span>)</span><br><span class="line">              <span class="number">6</span> RETURN_VALUE</span><br></pre></td></tr></table></figure><p>可以看到元组 <code>(1, 2, (3, 4))</code> 已经创建好了，这是 Python 底层所做的优化，这里不过多地讨论，有兴趣的可以查阅 Python/peephole.c 文件的 <code>PyCode_Optimize</code> 函数。</p><p>来看操作码的实现吧！</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">TARGET(BUILD_TUPLE) &#123;</span><br><span class="line">    PyObject *tup = PyTuple_New(oparg);</span><br><span class="line">    <span class="keyword">if</span> (tup == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">goto</span> error;</span><br><span class="line">    <span class="keyword">while</span> (--oparg &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        PyObject *item = POP();</span><br><span class="line">        PyTuple_SET_ITEM(tup, oparg, item);</span><br><span class="line">    &#125;</span><br><span class="line">    PUSH(tup);</span><br><span class="line">    DISPATCH();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和 <code>BUILD_LIST</code> 非常地类似，操作码的参数 <code>oparg</code> 的值也同样是元组中元素的数量。<code>PyTuple_New</code> 是 Python 底层创建元组所用的函数。先来看看定义元组类型的结构体，在 Include/tupleobject.h 中声明：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PyObject_VAR_HEAD      PyVarObject ob_base;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    PyObject ob_base;</span><br><span class="line">    Py_ssize_t ob_size; <span class="comment">/* 保存元组的长度 */</span></span><br><span class="line">&#125; PyVarObject;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    PyObject_VAR_HEAD</span><br><span class="line">    PyObject *ob_item[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* ob_item 包含'ob_size'元素的空间。项通常不能为空，</span></span><br><span class="line"><span class="comment">     * 除非在构造过程中元组在构造它的函数之外还不可见。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">&#125; PyTupleObject;</span><br></pre></td></tr></table></figure><p><code>ob_item</code> 保存元组中的元素，和列表直接声明为 <code>PyObject **ob_item</code> 不同，这里声明为了 <code>PyObject *ob_item[1]</code>。整个结构体和列表相比少了一个 <code>allocated</code> 字段，因为元组是不可变类型，并不需要预分配内存。来看 <code>PyTuple_New</code> 函数，在 Objects/tupleobject.c 中定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">PyObject *</span><br><span class="line">PyTuple_New(Py_ssize_t <span class="built_in">size</span>)</span><br><span class="line">&#123;</span><br><span class="line">    PyTupleObject *op;</span><br><span class="line">    Py_ssize_t i;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">size</span> &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        PyErr_BadInternalCall();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> PyTuple_MAXSAVESIZE &gt; 0</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">size</span> == <span class="number">0</span> &amp;&amp; free_list[<span class="number">0</span>]) &#123;</span><br><span class="line">        op = free_list[<span class="number">0</span>];</span><br><span class="line">        Py_INCREF(op);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> COUNT_ALLOCS</span></span><br><span class="line">        tuple_zero_allocs++;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        <span class="keyword">return</span> (PyObject *) op;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">size</span> &lt; PyTuple_MAXSAVESIZE &amp;&amp; (op = free_list[<span class="built_in">size</span>]) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        free_list[<span class="built_in">size</span>] = (PyTupleObject *) op-&gt;ob_item[<span class="number">0</span>];</span><br><span class="line">        numfree[<span class="built_in">size</span>]--;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> COUNT_ALLOCS</span></span><br><span class="line">        fast_tuple_allocs++;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        <span class="comment">/* Inline PyObject_InitVar */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> Py_TRACE_REFS</span></span><br><span class="line">        Py_SIZE(op) = <span class="built_in">size</span>;</span><br><span class="line">        Py_TYPE(op) = &amp;PyTuple_Type;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        _Py_NewReference((PyObject *)op);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">#endif</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* Check for overflow */</span></span><br><span class="line">        <span class="keyword">if</span> ((<span class="keyword">size_t</span>)<span class="built_in">size</span> &gt; ((<span class="keyword">size_t</span>)PY_SSIZE_T_MAX - <span class="keyword">sizeof</span>(PyTupleObject) -</span><br><span class="line">                    <span class="keyword">sizeof</span>(PyObject *)) / <span class="keyword">sizeof</span>(PyObject *)) &#123;</span><br><span class="line">            <span class="keyword">return</span> PyErr_NoMemory();</span><br><span class="line">        &#125;</span><br><span class="line">        op = PyObject_GC_NewVar(PyTupleObject, &amp;PyTuple_Type, <span class="built_in">size</span>);</span><br><span class="line">        <span class="keyword">if</span> (op == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>; i &lt; <span class="built_in">size</span>; i++)</span><br><span class="line">        op-&gt;ob_item[i] = <span class="literal">NULL</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> PyTuple_MAXSAVESIZE &gt; 0</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">size</span> == <span class="number">0</span>) &#123;</span><br><span class="line">        free_list[<span class="number">0</span>] = op;</span><br><span class="line">        ++numfree[<span class="number">0</span>];</span><br><span class="line">        Py_INCREF(op);          <span class="comment">/* extra INCREF so that this is never freed */</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> SHOW_TRACK_COUNT</span></span><br><span class="line">    count_tracked++;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    _PyObject_GC_TRACK(op);</span><br><span class="line">    <span class="keyword">return</span> (PyObject *) op;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参数 <code>size</code> 表示要创建的元组的长度，小于0肯定不合理所以返回 <code>NULL</code>。接着检查宏 <code>PyTuple_MAXSAVESIZE</code>，这是个跟元组缓存相关的宏，连带的一系列宏和变量声明如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> PyTuple_MAXSAVESIZE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PyTuple_MAXSAVESIZE     20  <span class="comment">/* 空闲列表中要保存的最大元组 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> PyTuple_MAXFREELIST</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PyTuple_MAXFREELIST  2000  <span class="comment">/* 每个大小要保存的的最大元组数 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> PyTuple_MAXSAVESIZE &gt; 0</span></span><br><span class="line"><span class="comment">/* 值1到 PyTuple_MAXSAVESIZE 是空闲列表，值0是空的元组，最多分配一个实例。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> PyTupleObject *free_list[PyTuple_MAXSAVESIZE];</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> numfree[PyTuple_MAXSAVESIZE];</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p><code>PyTuple_MAXSAVESIZE</code> 大于0时，已经使用过的被释放的长度小于 <code>PyTuple_MAXSAVESIZE</code> 的元组都会被缓存在 <code>free_list</code> 数组中，<code>free_list</code> 的大小和 <code>PyTuple_MAXSAVESIZE</code> 一致，<code>free_list[1]</code> 到 <code>free_list[PyTuple_MAXSAVESIZE - 1]</code> 会缓存长度与索引大小对应的元组，有多个需要缓存的大小相等的元组时，会使用单链表连接。单个大小最多缓存 <code>PyTuple_MAXFREELIST</code> 个，数量由 <code>numfree</code> 数组统计。<code>free_list[0]</code> 缓存的是空元组，空元组只会分配一次。看个例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = ()          <span class="comment"># 创建空元组 a</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = ()          <span class="comment"># 创建空元组 b</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>id(a) == id(b)  <span class="comment"># 地址一样，是同一个对象</span></span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure><p>两个空元组的地址相同，它们是同一个对象。继续 <code>PyTuple_New</code> 的执行，如果 <code>size</code> 为0且 <code>free_list[0]</code> 不为 <code>NULL</code>，增加它的引用计数并将其返回。<code>COUNT_ALLOCS</code> 是调试相关的宏，本文都将忽略它。</p><p>往下，说明 <code>size</code> 大于0或者 <code>free_list[0]</code> 为 <code>NULL</code>。当 <code>size</code> 小于 <code>PyTuple_MAXSAVESIZE</code> 且 <code>free_list[size]</code> 不为 <code>NULL</code> 时，将执行 <code>free_list[size] = (PyTupleObject *) op-&gt;ob_item[0]</code>，为什么会给 <code>free_list[size]</code> 赋值呢？要解释清楚得先看释放元组的函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">tupledealloc(PyTupleObject *op)</span><br><span class="line">&#123;</span><br><span class="line">    Py_ssize_t i;</span><br><span class="line">    Py_ssize_t len =  Py_SIZE(op);</span><br><span class="line">    PyObject_GC_UnTrack(op);</span><br><span class="line">    Py_TRASHCAN_SAFE_BEGIN(op)</span><br><span class="line">    <span class="keyword">if</span> (len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        i = len;</span><br><span class="line">        <span class="keyword">while</span> (--i &gt;= <span class="number">0</span>)</span><br><span class="line">            Py_XDECREF(op-&gt;ob_item[i]);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> PyTuple_MAXSAVESIZE &gt; 0</span></span><br><span class="line">        <span class="keyword">if</span> (len &lt; PyTuple_MAXSAVESIZE &amp;&amp;</span><br><span class="line">            numfree[len] &lt; PyTuple_MAXFREELIST &amp;&amp;</span><br><span class="line">            Py_TYPE(op) == &amp;PyTuple_Type)</span><br><span class="line">        &#123;</span><br><span class="line">            op-&gt;ob_item[<span class="number">0</span>] = (PyObject *) free_list[len];</span><br><span class="line">            numfree[len]++;</span><br><span class="line">            free_list[len] = op;</span><br><span class="line">            <span class="keyword">goto</span> done; <span class="comment">/* return */</span></span><br><span class="line">        &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    &#125;</span><br><span class="line">    Py_TYPE(op)-&gt;tp_free((PyObject *)op);</span><br><span class="line">done:</span><br><span class="line">    Py_TRASHCAN_SAFE_END(op)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>传入的 <code>op</code> 就是要释放的元组。这个函数先减少 <code>op</code> 中元素的引用计数，关键是 <code>PyTuple_MAXSAVESIZE &gt; 0</code> 条件包裹的语句。如果 <code>op</code> 长度小于 <code>PyTuple_MAXSAVESIZE</code> 且该长度当前缓存的数量小于 <code>PyTuple_MAXFREELIST</code> 且释放的是元组类型而非其子类，则将当前 <code>free_list</code> 中的这个长度的缓存存到 <code>op</code> 的 <code>ob_item[0]</code> 中。接着，将缓存数量加1，再将 <code>free_list[len]</code> 设置为当前释放的元组 <code>op</code>。也就是说多个长度相同的缓存元组通过 <code>ob_item[0]</code> 连接在一起形成了一个单链表，类似这样：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">free_list: </span></span><br><span class="line"><span class="comment">    +--------+------+--------+</span></span><br><span class="line"><span class="comment">    | ...... |  op  | ...... |</span></span><br><span class="line"><span class="comment">    +--------+---|--+--------+</span></span><br><span class="line"><span class="comment">                 V</span></span><br><span class="line"><span class="comment">                ob_item[0] = op1</span></span><br><span class="line"><span class="comment">                              |</span></span><br><span class="line"><span class="comment">                              V</span></span><br><span class="line"><span class="comment">                            ob_item[0] = op2</span></span><br><span class="line"><span class="comment">                                          |</span></span><br><span class="line"><span class="comment">                                          V</span></span><br><span class="line"><span class="comment">                                        ob_item[0] = op3</span></span><br><span class="line"><span class="comment">                                                      |</span></span><br><span class="line"><span class="comment">                                                      V</span></span><br><span class="line"><span class="comment">                                                    ob_item[0] = NULL</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><blockquote><p>同列表的缓存一样，这里的单链表作为栈来使用，确保优先重用最近释放的元组。</p></blockquote><p>回到 <code>PyTuple_New</code>，给 <code>free_list[size]</code> 赋值的原因显而易见。因为前面通过 <code>op = free_list[size]</code> 取出了缓存元组，所以要将保存在 <code>op</code> 的 <code>ob_item[0]</code> 中的缓存元组放回 <code>free_list[size]</code> 中。往下，当前长度的缓存数量减1。再往下就是一些字段的设置。</p><p>进入下面的 <code>else</code> 子句。首先检查长度 <code>size</code> 是否会造成内存溢出，<code>PY_SSIZE_T_MAX</code> 的值可以通过 <code>sys</code> 模块的 <code>maxsize</code> 属性查看：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> sys</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sys.maxsize     <span class="comment"># 64位环境下</span></span><br><span class="line"><span class="number">9223372036854775807</span></span><br></pre></td></tr></table></figure><p>接下来调用 <code>PyObject_GC_NewVar</code> 函数给 <code>op</code> 分配内存，这是一个宏：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PyObject_GC_NewVar(type,typeobj,n) \</span></span><br><span class="line">    ( (type *) _PyObject_GC_NewVar((typeobj), (n)) )</span><br></pre></td></tr></table></figure><p><code>_PyObject_GC_NewVar</code> 函数在 Modules/gcmodule.c 中定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">PyVarObject *</span><br><span class="line">_PyObject_GC_NewVar(PyTypeObject *tp, Py_ssize_t nitems)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">size_t</span> <span class="built_in">size</span>;</span><br><span class="line">    PyVarObject *op;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (nitems &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        PyErr_BadInternalCall();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">size</span> = _PyObject_VAR_SIZE(tp, nitems);</span><br><span class="line">    op = (PyVarObject *) _PyObject_GC_Malloc(<span class="built_in">size</span>);</span><br><span class="line">    <span class="keyword">if</span> (op != <span class="literal">NULL</span>)</span><br><span class="line">        op = PyObject_INIT_VAR(op, tp, nitems);</span><br><span class="line">    <span class="keyword">return</span> op;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数的工作就是计算要需要分配的内存然后调用 <code>_PyObject_GC_Malloc</code> 分配内存再进行一些字段的初始化，分配内存的函数这里不深入。</p><p>往下，将 <code>ob_item</code> 中的项全部设置为 <code>NULL</code>。再往下执行又是与缓存相关的操作，如果 <code>size</code> 为0还执行到了这里说明 <code>free_list[0]</code> 当前为 <code>NULL</code>。于是将当前的 <code>op</code> 保存到 <code>free_list[0]</code> 中，再额外增加一次引用计数，保证它不会被释放掉。前面也提到过，底层只会分配一个 <code>size</code> 为0的空元组实例。</p><p>最后，将 <code>op</code> 转换为 <code>PyObject *</code> 类型返回。返回前的 <code>_PyObject_GC_TRACK</code> 宏处理循环引用 GC 相关的初始化。</p><p>回到操作码的执行，返回值为 <code>NULL</code> 则跳转到错误处理。不为 <code>NULL</code> 则从值栈中依次弹出 <code>oparg</code> 个值，并相应地给元组赋值。<code>PyTuple_SET_ITEM</code> 宏定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PyTuple_SET_ITEM(op,i,v) (((PyTupleObject *)(op))-&gt;ob_item[i] = v)</span></span><br></pre></td></tr></table></figure><p>完成赋值操作后将元组压入值栈中供后面的操作码使用。</p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python操作码——BUILD_LIST</title>
      <link href="/python/python-opcode-BUILD_LIST.html"/>
      <url>/python/python-opcode-BUILD_LIST.html</url>
      
        <content type="html"><![CDATA[<p><code>BUILD_LIST</code> 操作码的编号是103，是个带参数的操作码。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>dis.opmap[<span class="string">'BUILD_LIST'</span>]</span><br><span class="line"><span class="number">103</span></span><br></pre></td></tr></table></figure><a id="more"></a><p>在 Python 中使用 <code>[]</code> 创建列表会生成这个操作码，参数的值是列表的长度。一个简单的示例如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; dis.dis(&apos;a = [1, 2, 3]&apos;)</span><br><span class="line">  1           0 LOAD_CONST               0 (1)</span><br><span class="line">              2 LOAD_CONST               1 (2)</span><br><span class="line">              4 LOAD_CONST               2 (3)</span><br><span class="line">              6 BUILD_LIST               3</span><br><span class="line">              8 STORE_NAME               0 (a)</span><br><span class="line">             10 LOAD_CONST               3 (None)</span><br><span class="line">             12 RETURN_VALUE</span><br></pre></td></tr></table></figure><p>从这个例子中可以看到，Python 会首先将列表中的元素依次压入值栈供 <code>BUILD_LIST</code> 使用，后面的参数3表示有三个元素。来看看这个操作码的实现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">TARGET(BUILD_LIST) &#123;</span><br><span class="line">    PyObject *<span class="built_in">list</span> = PyList_New(oparg);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">list</span> == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">goto</span> error;</span><br><span class="line">    <span class="keyword">while</span> (--oparg &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        PyObject *item = POP();</span><br><span class="line">        PyList_SET_ITEM(<span class="built_in">list</span>, oparg, item);</span><br><span class="line">    &#125;</span><br><span class="line">    PUSH(<span class="built_in">list</span>);</span><br><span class="line">    DISPATCH();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>开头直接调用了 <code>PyList_New</code> 函数，这是 Python 底层用于创建空列表的函数，参数表示空列表可容纳的元素的个数。来简单分析这个函数的实现，函数在 Objects/listobject.c 中定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">PyObject *</span><br><span class="line">PyList_New(Py_ssize_t <span class="built_in">size</span>)</span><br><span class="line">&#123;</span><br><span class="line">    PyListObject *op;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> SHOW_ALLOC_COUNT</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> initialized = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (!initialized) &#123;</span><br><span class="line">        Py_AtExit(show_alloc);</span><br><span class="line">        initialized = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">size</span> &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        PyErr_BadInternalCall();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (numfree) &#123;</span><br><span class="line">        numfree--;</span><br><span class="line">        op = free_list[numfree];</span><br><span class="line">        _Py_NewReference((PyObject *)op);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> SHOW_ALLOC_COUNT</span></span><br><span class="line">        count_reuse++;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        op = PyObject_GC_New(PyListObject, &amp;PyList_Type);</span><br><span class="line">        <span class="keyword">if</span> (op == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> SHOW_ALLOC_COUNT</span></span><br><span class="line">        count_alloc++;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">size</span> &lt;= <span class="number">0</span>)</span><br><span class="line">        op-&gt;ob_item = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        op-&gt;ob_item = (PyObject **) PyMem_Calloc(<span class="built_in">size</span>, <span class="keyword">sizeof</span>(PyObject *));</span><br><span class="line">        <span class="keyword">if</span> (op-&gt;ob_item == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            Py_DECREF(op);</span><br><span class="line">            <span class="keyword">return</span> PyErr_NoMemory();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Py_SIZE(op) = <span class="built_in">size</span>;</span><br><span class="line">    op-&gt;allocated = <span class="built_in">size</span>;</span><br><span class="line">    _PyObject_GC_TRACK(op);</span><br><span class="line">    <span class="keyword">return</span> (PyObject *) op;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在讲解这个函数前，首先先来看定义列表类型的结构体：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PyObject_VAR_HEAD      PyVarObject ob_base;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    PyObject ob_base;</span><br><span class="line">    Py_ssize_t ob_size; <span class="comment">/* 列表元素的个数。 */</span></span><br><span class="line">&#125; PyVarObject;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="comment">/* 所有表示 Python 对象的结构体的第一个字段</span></span><br><span class="line"><span class="comment">     * 都会是 PyObject_VAR_HEAD 和 PyObject_HEAD 之一。</span></span><br><span class="line"><span class="comment">     * PyObject_VAR_HEAD 是 PyObject_HEAD 的拓展版本。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    PyObject_VAR_HEAD</span><br><span class="line">    <span class="comment">/* PyObject * 类型的数组，用于保存列表的元素。list[0] 即是 ob_item[0]。 */</span></span><br><span class="line">    PyObject **ob_item;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 所分配的列表的元素的个数。列表的实现类似于动态数组，当需要扩容时，</span></span><br><span class="line"><span class="comment">     * 会多分配一些空间。</span></span><br><span class="line"><span class="comment">     * 一些不变式：</span></span><br><span class="line"><span class="comment">     *      0 &lt;= ob_size &lt;= allocated</span></span><br><span class="line"><span class="comment">     *      len(list) = ob_size</span></span><br><span class="line"><span class="comment">     *      ob_item == NULL ==&gt; ob_size == allocated == 0</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Py_ssize_t allocated;</span><br><span class="line">&#125; PyListObject;</span><br></pre></td></tr></table></figure><p>回到 <code>PyList_New</code>，忽略开头的宏，往下会检查参数 <code>size</code>，小于0明显不合理所以直接返回 <code>NULL</code>。接着检查 <code>numfree</code>，这是一个 <code>int</code> 类型的静态变量，表示 <code>free_list</code> 中的元素的数量。<code>free_list</code> 是一个 <code>PyListObject *</code> 类型的数组，用于缓存曾经使用过的已经释放的列表，这是 Python 底层优化内存的一种方式。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> PyList_MAXFREELIST</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PyList_MAXFREELIST 80</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="keyword">static</span> PyListObject *free_list[PyList_MAXFREELIST];</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> numfree = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>如果 <code>numfree</code> 不为0，则从 <code>free_list</code> 取出缓存的列表，然后调用 <code>_Py_NewReference</code> 增加其引用计数并进行一些全局变量的设置。而如果 <code>numfree</code> 为0，则调用 <code>PyObject_GC_New</code> 为列表对象分配内存。</p><blockquote><p>注意这里的 <code>free_list</code> 是当做栈来使用，这样会优先使用最近释放的列表。</p></blockquote><p>往下，如果 <code>size</code> 为0，则将 <code>ob_item</code> 字段值设为 <code>NULL</code>。否则，调用 <code>PyMem_Calloc</code> 为 <code>ob_item</code> 字段分配内存，返回的内存大小为 <code>sizeof(PyObject *) * 3</code>。接下来设置各个字段的值，<code>Py_SIZE(op)</code> 相当于 <code>(((PyVarObject*)(op))-&gt;ob_size)</code>，<code>_PyObject_GC_TRACK</code> 是跟循环引用 GC 相关的宏，这里不展开。最后，将 <code>PyListObject *</code> 类型的指针转换成 <code>PyObject *</code> 类型并返回。</p><p>回到操作码的执行，如果返回值为 <code>NULL</code> 就直接跳转到错误处理。否则，根据操作码的参数 <code>oparg</code> 从值栈中弹出对应的值，并将它们保存到列表中。<code>PyList_SET_ITEM</code> 是一个宏：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PyList_SET_ITEM(op, i, v) (((PyListObject *)(op))-&gt;ob_item[i] = (v))</span></span><br></pre></td></tr></table></figure><p>最后，将列表压入值栈中，供后面的操作码使用。</p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python操作码——BINARY_OR</title>
      <link href="/python/python-opcode-BINARY_OR.html"/>
      <url>/python/python-opcode-BINARY_OR.html</url>
      
        <content type="html"><![CDATA[<p><code>BINARY_OR</code> 操作码的编号是66，是个不带参数的操作码。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>dis.opmap[<span class="string">'BINARY_OR'</span>]</span><br><span class="line"><span class="number">66</span></span><br></pre></td></tr></table></figure><a id="more"></a><p>这个操作码对应 Python 的双目运算符 <code>|</code>，一般用于位运算“或”操作，注意不是关键字 <code>or</code>。实现如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">TARGET(BINARY_OR) &#123;</span><br><span class="line">    PyObject *right = POP();</span><br><span class="line">    PyObject *left = TOP();</span><br><span class="line">    PyObject *res = PyNumber_Or(left, right);</span><br><span class="line">    Py_DECREF(left);</span><br><span class="line">    Py_DECREF(right);</span><br><span class="line">    SET_TOP(res);</span><br><span class="line">    <span class="keyword">if</span> (res == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">goto</span> error;</span><br><span class="line">    DISPATCH();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关键函数 <code>PyNumber_Or</code>，在 Objects/abstract.c 中定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BINARY_FUNC(func, op, op_name) \</span></span><br><span class="line">    PyObject * \</span><br><span class="line">    func(PyObject *v, PyObject *w) &#123; \</span><br><span class="line">        <span class="keyword">return</span> binary_op(v, w, NB_SLOT(op), op_name); \</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">BINARY_FUNC(PyNumber_Or, nb_or, <span class="string">"|"</span>)</span><br></pre></td></tr></table></figure><p>宏展开之后是：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NB_SLOT(x) offsetof(PyNumberMethods, x)</span></span><br><span class="line"></span><br><span class="line">PyObject *</span><br><span class="line">PyNumber_Or(PyObject *v, PyObject *w) &#123;</span><br><span class="line">    <span class="keyword">return</span> binary_op(v, w, offsetof(PyNumberMethods, nb_or), <span class="string">"|"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对 <code>binary_op</code> 的分析参考 <code>BINARY_MATRIX_MULTIPLY</code>。</p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python操作码——BINARY_XOR</title>
      <link href="/python/python-opcode-BINARY_XOR.html"/>
      <url>/python/python-opcode-BINARY_XOR.html</url>
      
        <content type="html"><![CDATA[<p><code>BINARY_XOR</code> 操作码的编号是65，是个不带参数的操作码。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>dis.opmap[<span class="string">'BINARY_XOR'</span>]</span><br><span class="line"><span class="number">65</span></span><br></pre></td></tr></table></figure><a id="more"></a><p>这个操作码对应 Python 的双目运算符 <code>^</code>，一般用于位运算“异或”操作。实现如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">TARGET(BINARY_XOR) &#123;</span><br><span class="line">    PyObject *right = POP();</span><br><span class="line">    PyObject *left = TOP();</span><br><span class="line">    PyObject *res = PyNumber_Xor(left, right);</span><br><span class="line">    Py_DECREF(left);</span><br><span class="line">    Py_DECREF(right);</span><br><span class="line">    SET_TOP(res);</span><br><span class="line">    <span class="keyword">if</span> (res == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">goto</span> error;</span><br><span class="line">    DISPATCH();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关键函数 <code>PyNumber_Xor</code>。在 Objects/abstract.c 中定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BINARY_FUNC(func, op, op_name) \</span></span><br><span class="line">    PyObject * \</span><br><span class="line">    func(PyObject *v, PyObject *w) &#123; \</span><br><span class="line">        <span class="keyword">return</span> binary_op(v, w, NB_SLOT(op), op_name); \</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">BINARY_FUNC(PyNumber_Xor, nb_xor, <span class="string">"^"</span>)</span><br></pre></td></tr></table></figure><p>宏展开之后是：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NB_SLOT(x) offsetof(PyNumberMethods, x)</span></span><br><span class="line"></span><br><span class="line">PyObject *</span><br><span class="line">PyNumber_Xor(PyObject *v, PyObject *w) &#123;</span><br><span class="line">    <span class="keyword">return</span> binary_op(v, w, offsetof(PyNumberMethods, nb_xor), <span class="string">"^"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对 <code>binary_op</code> 的分析参考 <code>BINARY_MATRIX_MULTIPLY</code>。</p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python操作码——BINARY_AND</title>
      <link href="/python/python-opcode-BINARY_AND.html"/>
      <url>/python/python-opcode-BINARY_AND.html</url>
      
        <content type="html"><![CDATA[<p><code>BINARY_AND</code> 操作码的编号是64，是个不带参数的操作码。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>dis.opmap[<span class="string">'BINARY_AND'</span>]</span><br><span class="line"><span class="number">64</span></span><br></pre></td></tr></table></figure><a id="more"></a><p>这个操作码对应 Python 的双目运算符 <code>&amp;</code>，一般用于位运算“与”操作，注意不是关键字 <code>and</code>。实现如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">TARGET(BINARY_AND) &#123;</span><br><span class="line">    PyObject *right = POP();</span><br><span class="line">    PyObject *left = TOP();</span><br><span class="line">    PyObject *res = PyNumber_And(left, right);</span><br><span class="line">    Py_DECREF(left);</span><br><span class="line">    Py_DECREF(right);</span><br><span class="line">    SET_TOP(res);</span><br><span class="line">    <span class="keyword">if</span> (res == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">goto</span> error;</span><br><span class="line">    DISPATCH();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直接来看关键的 <code>PyNumber_And</code> 函数吧。在 Objects/abstract.c 中定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BINARY_FUNC(func, op, op_name) \</span></span><br><span class="line">    PyObject * \</span><br><span class="line">    func(PyObject *v, PyObject *w) &#123; \</span><br><span class="line">        <span class="keyword">return</span> binary_op(v, w, NB_SLOT(op), op_name); \</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">BINARY_FUNC(PyNumber_And, nb_and, <span class="string">"&amp;"</span>)</span><br></pre></td></tr></table></figure><p>宏展开之后是：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NB_SLOT(x) offsetof(PyNumberMethods, x)</span></span><br><span class="line"></span><br><span class="line">PyObject *</span><br><span class="line">PyNumber_And(PyObject *v, PyObject *w) &#123;</span><br><span class="line">    <span class="keyword">return</span> binary_op(v, w, offsetof(PyNumberMethods, nb_and), <span class="string">"&amp;"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对 <code>binary_op</code> 的分析参考 <code>BINARY_MATRIX_MULTIPLY</code>。</p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python操作码——BINARY_RSHIFT</title>
      <link href="/python/python-opcode-BINARY_RSHIFT.html"/>
      <url>/python/python-opcode-BINARY_RSHIFT.html</url>
      
        <content type="html"><![CDATA[<p><code>BINARY_RSHIFT</code> 操作码的编号是63，是个不带参数的操作码。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>dis.opmap[<span class="string">'BINARY_RSHIFT'</span>]</span><br><span class="line"><span class="number">63</span></span><br></pre></td></tr></table></figure><a id="more"></a><p>这个操作码对应 Python 的双目运算符 <code>&gt;&gt;</code>，一般用于向右移位操作，实现如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">TARGET(BINARY_RSHIFT) &#123;</span><br><span class="line">    PyObject *right = POP();</span><br><span class="line">    PyObject *left = TOP();</span><br><span class="line">    PyObject *res = PyNumber_Rshift(left, right);</span><br><span class="line">    Py_DECREF(left);</span><br><span class="line">    Py_DECREF(right);</span><br><span class="line">    SET_TOP(res);</span><br><span class="line">    <span class="keyword">if</span> (res == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">goto</span> error;</span><br><span class="line">    DISPATCH();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>来看关键的 <code>PyNumber_Rshift</code> 函数，在 Objects/abstract.c 中定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BINARY_FUNC(func, op, op_name) \</span></span><br><span class="line">    PyObject * \</span><br><span class="line">    func(PyObject *v, PyObject *w) &#123; \</span><br><span class="line">        <span class="keyword">return</span> binary_op(v, w, NB_SLOT(op), op_name); \</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">BINARY_FUNC(PyNumber_Rshift, nb_rshift, <span class="string">"&gt;&gt;"</span>)</span><br></pre></td></tr></table></figure><p>宏展开之后是：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NB_SLOT(x) offsetof(PyNumberMethods, x)</span></span><br><span class="line"></span><br><span class="line">PyObject *</span><br><span class="line">PyNumber_Rshift(PyObject *v, PyObject *w) &#123;</span><br><span class="line">    <span class="keyword">return</span> binary_op(v, w, offsetof(PyNumberMethods, nb_rshift), <span class="string">"&gt;&gt;"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然已经在 <code>BINARY_MATRIX_MULTIPLY</code> 中分析过了 <code>binary_op</code>，但是这里还是要提一点，先来看这个函数的实现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> PyObject *</span><br><span class="line">binary_op(PyObject *v, PyObject *w, <span class="keyword">const</span> <span class="keyword">int</span> op_slot, <span class="keyword">const</span> <span class="keyword">char</span> *op_name)</span><br><span class="line">&#123;</span><br><span class="line">    PyObject *result = binary_op1(v, w, op_slot);</span><br><span class="line">    <span class="keyword">if</span> (result == Py_NotImplemented) &#123;</span><br><span class="line">        Py_DECREF(result);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (op_slot == NB_SLOT(nb_rshift) &amp;&amp;</span><br><span class="line">            PyCFunction_Check(v) &amp;&amp;</span><br><span class="line">            <span class="built_in">strcmp</span>(((PyCFunctionObject *)v)-&gt;m_ml-&gt;ml_name, <span class="string">"print"</span>) == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            PyErr_Format(PyExc_TypeError,</span><br><span class="line">                <span class="string">"unsupported operand type(s) for %.100s: "</span></span><br><span class="line">                <span class="string">"'%.100s' and '%.100s'. Did you mean \"print(&lt;message&gt;, "</span></span><br><span class="line">                <span class="string">"file=&lt;output_stream&gt;)\"?"</span>,</span><br><span class="line">                op_name,</span><br><span class="line">                v-&gt;ob_type-&gt;tp_name,</span><br><span class="line">                w-&gt;ob_type-&gt;tp_name);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> binop_type_error(v, w, op_name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>result == Py_NotImplemented</code> 的条件里，当运算符是 <code>&gt;&gt;</code> 且左操作数是 <code>print</code> 函数的时候，会设置一个特别的 <code>TypeError</code>，来看个示例：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> &gt;&gt; <span class="number">1</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">TypeError: unsupported operand type(s) for &gt;&gt;: 'builtin_function_or_method' and 'int'. Did you mean "print(&lt;message&gt;, file=&lt;output_stream&gt;)"?</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python操作码——BINARY_LSHIFT</title>
      <link href="/python/python-opcode-BINARY_LSHIFT.html"/>
      <url>/python/python-opcode-BINARY_LSHIFT.html</url>
      
        <content type="html"><![CDATA[<p><code>BINARY_LSHIFT</code> 操作码的编号是62，是个不带参数的操作码。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>dis.opmap[<span class="string">'BINARY_LSHIFT'</span>]</span><br><span class="line"><span class="number">62</span></span><br></pre></td></tr></table></figure><a id="more"></a><p>这个操作码对应 Python 的双目运算符 <code>&lt;&lt;</code>，一般用于向左移位操作，实现如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">TARGET(BINARY_LSHIFT) &#123;</span><br><span class="line">    PyObject *right = POP();</span><br><span class="line">    PyObject *left = TOP();</span><br><span class="line">    PyObject *res = PyNumber_Lshift(left, right);</span><br><span class="line">    Py_DECREF(left);</span><br><span class="line">    Py_DECREF(right);</span><br><span class="line">    SET_TOP(res);</span><br><span class="line">    <span class="keyword">if</span> (res == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">goto</span> error;</span><br><span class="line">    DISPATCH();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和其它二元运算符操作码的实现非常类似，关键在于 <code>PyNumber_Lshift</code>，这个函数在 Objects/abstract.c 中定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">BINARY_FUNC(PyNumber_Lshift, nb_lshift, <span class="string">"&lt;&lt;"</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BINARY_FUNC(func, op, op_name) \</span></span><br><span class="line">    PyObject * \</span><br><span class="line">    func(PyObject *v, PyObject *w) &#123; \</span><br><span class="line">        <span class="keyword">return</span> binary_op(v, w, NB_SLOT(op), op_name); \</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>宏展开后发现就是简单地调用了 <code>binary_op</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NB_SLOT(x) offsetof(PyNumberMethods, x)</span></span><br><span class="line"></span><br><span class="line">PyObject *</span><br><span class="line">PyNumber_Lshift(PyObject *v, PyObject *w) &#123;</span><br><span class="line">    <span class="keyword">return</span> binary_op(v, w, offsetof(PyNumberMethods, nb_lshift), <span class="string">"&lt;&lt;"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对 <code>binary_op</code> 的分析参考 <code>BINARY_MATRIX_MULTIPLY</code>。</p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python操作码——BINARY_SUBSCR</title>
      <link href="/python/python-opcode-BINARY_SUBSCR.html"/>
      <url>/python/python-opcode-BINARY_SUBSCR.html</url>
      
        <content type="html"><![CDATA[<p><code>BINARY_SUBSCR</code> 操作码的编号是25，是个不带参数的操作码。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>dis.opmap[<span class="string">'BINARY_SUBSCR'</span>]</span><br><span class="line"><span class="number">25</span></span><br></pre></td></tr></table></figure><a id="more"></a><p>这个操作码对应 Python 的下标运算 <code>[]</code>，左操作数一般是某个容器对象，右操作数则是方括号中的值。实现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">TARGET(BINARY_SUBSCR) &#123;</span><br><span class="line">    PyObject *sub = POP();</span><br><span class="line">    PyObject *container = TOP();</span><br><span class="line">    PyObject *res = PyObject_GetItem(container, sub);</span><br><span class="line">    Py_DECREF(container);</span><br><span class="line">    Py_DECREF(sub);</span><br><span class="line">    SET_TOP(res);</span><br><span class="line">    <span class="keyword">if</span> (res == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">goto</span> error;</span><br><span class="line">    DISPATCH();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和其它二元运算符很类似，不同之处在于 <code>PyObject_GetItem</code>，这个函数在 Objects/abstract.c 文件中定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">PyObject *</span><br><span class="line">PyObject_GetItem(PyObject *o, PyObject *key)</span><br><span class="line">&#123;</span><br><span class="line">    PyMappingMethods *m;</span><br><span class="line">    PySequenceMethods *ms;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (o == <span class="literal">NULL</span> || key == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> null_error();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    m = o-&gt;ob_type-&gt;tp_as_mapping;</span><br><span class="line">    <span class="keyword">if</span> (m &amp;&amp; m-&gt;mp_subscript) &#123;</span><br><span class="line">        PyObject *item = m-&gt;mp_subscript(o, key);</span><br><span class="line">        assert((item != <span class="literal">NULL</span>) ^ (PyErr_Occurred() != <span class="literal">NULL</span>));</span><br><span class="line">        <span class="keyword">return</span> item;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ms = o-&gt;ob_type-&gt;tp_as_sequence;</span><br><span class="line">    <span class="keyword">if</span> (ms &amp;&amp; ms-&gt;sq_item) &#123;</span><br><span class="line">        <span class="keyword">if</span> (PyIndex_Check(key)) &#123;</span><br><span class="line">            Py_ssize_t key_value;</span><br><span class="line">            key_value = PyNumber_AsSsize_t(key, PyExc_IndexError);</span><br><span class="line">            <span class="keyword">if</span> (key_value == <span class="number">-1</span> &amp;&amp; PyErr_Occurred())</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">            <span class="keyword">return</span> PySequence_GetItem(o, key_value);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> type_error(<span class="string">"sequence index must "</span></span><br><span class="line">                              <span class="string">"be integer, not '%.200s'"</span>, key);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (PyType_Check(o)) &#123;</span><br><span class="line">        PyObject *meth, *result, *<span class="built_in">stack</span>[<span class="number">1</span>] = &#123;key&#125;;</span><br><span class="line">        _Py_IDENTIFIER(__class_getitem__);</span><br><span class="line">        <span class="keyword">if</span> (_PyObject_LookupAttrId(o, &amp;PyId___class_getitem__, &amp;meth) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (meth) &#123;</span><br><span class="line">            result = _PyObject_FastCall(meth, <span class="built_in">stack</span>, <span class="number">1</span>);</span><br><span class="line">            Py_DECREF(meth);</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> type_error(<span class="string">"'%.200s' object is not subscriptable"</span>, o);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>PyMappingMethods</code> 和 <code>PySequenceMethods</code> 分别是定义映射协议和序列协议的结构体。往下，检查参数 <code>o</code> 和 <code>key</code> 的合法性，其中一个为 <code>NULL</code> 则调用 <code>null_error</code> 设置 <code>SystemError</code> 并返回 <code>NULL</code>。</p><p>接下来，获取 <code>o</code> 的 <code>ob_type</code> 的 <code>tp_as_mapping</code> 字段的值，如果 <code>m</code> 和 <code>m-&gt;mp_subscript</code> 的值不为 <code>NULL</code>，则调用 <code>mp_subscript</code> <code>指向的函数。然后，对调用的返回值进行判定，PyErr_Occurred</code> 在没有异常被设置时返回 <code>NULL</code>。注意这里用了异或运算，<code>item</code> 为 <code>NULL</code> 时表示有异常被设置，此时第一个条件为0，第二个条件为1，根据同零异一的原则，这里会返回 <code>NULL</code>（<code>item</code> 为 <code>NULL</code>）。<code>item</code> 不为 <code>NULL</code> 则表示取到了值，没有异常被设置，此时第一个条件为1，第二条件为0，返回取到的值 <code>item</code>。</p><p>往下，说明 <code>m</code> 或者 <code>m-&gt;mp_subscript</code> 的值为 <code>NULL</code>，则获取 <code>tp_as_sequence</code> 的值 <code>ms</code>。如果 <code>ms</code> 和 <code>ms-&gt;sq_item</code> 不为 <code>NULL</code>，检查参数 <code>key</code> 的是否实现了数字协议的 <code>nb_index</code> 槽：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PyIndex_Check(obj)                              \</span></span><br><span class="line">    ((obj)-&gt;ob_type-&gt;tp_as_number != <span class="literal">NULL</span> &amp;&amp;            \</span><br><span class="line">     (obj)-&gt;ob_type-&gt;tp_as_number-&gt;nb_index != <span class="literal">NULL</span>)</span><br></pre></td></tr></table></figure><p>如果条件为真，调用 <code>PyNumber_AsSsize_t</code> 将 <code>PyObject *</code> 类型的 <code>key</code> 转换为 <code>Py_ssize_t</code> <code>类型。sq_item</code> 指向的函数的签名是 <code>typedef PyObject *(*ssizeargfunc)(PyObject *, Py_ssize_t)</code>，看下面 <code>else</code> 子句就知道，序列索引值必须是整数。只要 <code>PyNumber_AsSsize_t</code> 没有发生异常，就会调用 <code>PySequence_GetItem</code>，这个函数同样在 Objects/abstract.c 中定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">PyObject *</span><br><span class="line">PySequence_GetItem(PyObject *s, Py_ssize_t i)</span><br><span class="line">&#123;</span><br><span class="line">    PySequenceMethods *m;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (s == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> null_error();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    m = s-&gt;ob_type-&gt;tp_as_sequence;</span><br><span class="line">    <span class="keyword">if</span> (m &amp;&amp; m-&gt;sq_item) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (m-&gt;sq_length) &#123;</span><br><span class="line">                Py_ssize_t l = (*m-&gt;sq_length)(s);</span><br><span class="line">                <span class="keyword">if</span> (l &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    assert(PyErr_Occurred());</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                i += l;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> m-&gt;sq_item(s, i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> type_error(<span class="string">"'%.200s' object does not support indexing"</span>, s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>忽略一些错误处理，可以看到，核心其实就是在处理索引值为负数的情况，索引值为负数时，会加上序列的长度，序列长度由 <code>sq_length</code> 指向的函数计算，之后再调用 <code>sq_item</code> 指向的函数取值。</p><p>回到 <code>PyObject_GetItem</code>，往下执行说明该对象可能没有实现映射协议或者序列协议对应的方法，或者协议方法没有返回期望的值。接着，使用 <code>PyType_Check</code> 宏检查参数 <code>o</code> 的类型是否是 <code>type</code> 的子类，宏定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PyType_Check(op) \</span></span><br><span class="line">    PyType_FastSubclass(Py_TYPE(op), Py_TPFLAGS_TYPE_SUBCLASS)</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Py_TYPE(ob)             (((PyObject*)(ob))-&gt;ob_type)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Py_TPFLAGS_TYPE_SUBCLASS        (1UL &lt;&lt; 31)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PyType_FastSubclass(t,f)  PyType_HasFeature(t,f)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PyType_HasFeature(t,f)  (((t)-&gt;tp_flags &amp; (f)) != 0)</span></span><br></pre></td></tr></table></figure><p>条件为真，进入 <code>if</code> 语句块，<code>_Py_IDENTIFIER</code> 是一个宏，用于初始化一个 <code>_Py_Identifier</code> 类型的静态变量：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _Py_IDENTIFIER(varname) _Py_static_string(PyId_##varname, #varname)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _Py_static_string_init(value) &#123; .next = NULL, .string = value, .object = NULL &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _Py_static_string(varname, value)  static _Py_Identifier varname = _Py_static_string_init(value)</span></span><br></pre></td></tr></table></figure><p>宏展开相当于：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> _Py_Identifier PyId___class_getitem__ = &#123; .next = <span class="literal">NULL</span>, .<span class="built_in">string</span> = <span class="string">"__class_getitem__"</span>, .object = <span class="literal">NULL</span> &#125;</span><br></pre></td></tr></table></figure><p><code>_Py_Identifier</code> 是一个结构体，在 Include/object.h 中声明，用于帮助管理静态字符串。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">Py_Identifier</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">Py_Identifier</span> *<span class="title">next</span>;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* <span class="built_in">string</span>;</span><br><span class="line">    PyObject *object;</span><br><span class="line">&#125; _Py_Identifier;</span><br></pre></td></tr></table></figure><p>由这个结构体管理的字符串会进行驻留操作，并且使用 <code>next</code> 字段连接在一起，只有在解释器关闭时才会进行释放。<code>__class_getitem__</code> 在 Python 中是一个魔法方法，也是一个类方法，用于模拟泛型类型。关于这个方法的详情参考 <a href="https://www.python.org/dev/peps/pep-0484" target="_blank" rel="noopener">PEP 484</a>。</p><p>接下来将调用位于 Objects/object.c 中的 <code>_PyObject_LookupAttrId</code> 函数进行属性查找，注意这里传入了 <code>meth</code> 的地址接收查找到的方法，如果函数返回值小于0，说明函数调用链中引生了异常，直接返回 <code>NULL</code>。否则，检查 <code>meth</code> 是否为 <code>NULL</code>，不为 <code>NULL</code> 则调用 <code>_PyObject_FastCall</code> 执行 <code>meth</code> 方法，最后减少 <code>meth</code> 的引用计数并将结果返回。</p><p>函数走到最后，说明对象不支持下标运算，调用 <code>type_error</code> 函数设置 <code>TypeError</code> 并返回 <code>NULL</code>。</p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python操作码——BINARY_SUBTRACT</title>
      <link href="/python/python-opcode-BINARY_SUBTRACT.html"/>
      <url>/python/python-opcode-BINARY_SUBTRACT.html</url>
      
        <content type="html"><![CDATA[<p><code>BINARY_SUBTRACT</code> 操作码的编号是24，是个不带参数的操作码。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>dis.opmap[<span class="string">'BINARY_SUBTRACT'</span>]</span><br><span class="line"><span class="number">24</span></span><br></pre></td></tr></table></figure><a id="more"></a><p>这个操作码对应 Python 中的双目运算符 <code>-</code>，实现如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">TARGET(BINARY_SUBTRACT) &#123;</span><br><span class="line">    PyObject *right = POP();</span><br><span class="line">    PyObject *left = TOP();</span><br><span class="line">    PyObject *diff = PyNumber_Subtract(left, right);</span><br><span class="line">    Py_DECREF(right);</span><br><span class="line">    Py_DECREF(left);</span><br><span class="line">    SET_TOP(diff);</span><br><span class="line">    <span class="keyword">if</span> (diff == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">goto</span> error;</span><br><span class="line">    DISPATCH();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个操作码与其它的二元运算操作码如 <code>BINARY_MULTIPLY</code> 的区别就是 <code>PyNumber_Subtract</code> 函数，来看这个函数，同样是在 Objects/abstract.c 中定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">BINARY_FUNC(PyNumber_Subtract, nb_subtract, <span class="string">"-"</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BINARY_FUNC(func, op, op_name) \</span></span><br><span class="line">    PyObject * \</span><br><span class="line">    func(PyObject *v, PyObject *w) &#123; \</span><br><span class="line">        <span class="keyword">return</span> binary_op(v, w, NB_SLOT(op), op_name); \</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>宏展开之后就变成了：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">PyObject *</span><br><span class="line">PyNumber_Subtract(PyObject *v, PyObject *w) &#123;</span><br><span class="line">    <span class="keyword">return</span> binary_op(v, w, NB_SLOT(nb_subtract), <span class="string">"-"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就是对 <code>binary_op</code> 函数的包装，这个函数已经在 <code>BINARY_MATRIX_MULTIPLY</code> 中分析过了，这里不再重复。<code>NB_SLOT(nb_subtract)</code> 求的是 <code>nb_subtract</code> 字段在 <code>PyNumberMethods</code> 结构体中的偏移量。</p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python操作码——BINARY_ADD</title>
      <link href="/python/python-opcode-BINARY_ADD.html"/>
      <url>/python/python-opcode-BINARY_ADD.html</url>
      
        <content type="html"><![CDATA[<p><code>BINARY_ADD</code> 操作码的编号是23，是个不带参数的操作码。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>dis.opmap[<span class="string">'BINARY_ADD'</span>]</span><br><span class="line"><span class="number">23</span></span><br></pre></td></tr></table></figure><a id="more"></a><p>这个操作码对应 Python 的双目运算符 <code>+</code>，实现如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">TARGET(BINARY_ADD) &#123;</span><br><span class="line">    PyObject *right = POP();</span><br><span class="line">    PyObject *left = TOP();</span><br><span class="line">    PyObject *sum;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (PyUnicode_CheckExact(left) &amp;&amp;</span><br><span class="line">                PyUnicode_CheckExact(right)) &#123;</span><br><span class="line">        sum = unicode_concatenate(left, right, f, next_instr);</span><br><span class="line">        <span class="comment">/* unicode_concatenate consumed the ref to left */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        sum = PyNumber_Add(left, right);</span><br><span class="line">        Py_DECREF(left);</span><br><span class="line">    &#125;</span><br><span class="line">    Py_DECREF(right);</span><br><span class="line">    SET_TOP(sum);</span><br><span class="line">    <span class="keyword">if</span> (sum == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">goto</span> error;</span><br><span class="line">    DISPATCH();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先从值栈中获取左右操作数 <code>left</code> 和 <code>right</code>，并定义了一个变量 <code>sum</code> 用于接收结果。接下来，和其它二元运算的操作码不同的是，这里会判断左右操作数是否都是字符串对象，如果是，则调用 <code>unicode_concatenate</code> 进行字符串拼接操作，否则调用 <code>PyNumber_Add</code>，接下来的操作与其它二元运算的操作码非常类似，减少引用计数，设置值栈栈顶值为 <code>sum</code>，如果 <code>sum</code> 为 <code>NULL</code> 就跳转到错误处理，否则执行下一个操作码。</p><p><code>unicode_concatenate</code> 的分析参考 <code>INPLACE_ADD</code>，这个函数会消耗掉 <code>left</code> 的引用计数，所以这里没有再减少 <code>left</code> 的引用计数。</p><p>下面来看 <code>PyNumber_Add</code>，在 Objects/abstract.c 中定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">PyObject *</span><br><span class="line">PyNumber_Add(PyObject *v, PyObject *w)</span><br><span class="line">&#123;</span><br><span class="line">    PyObject *result = binary_op1(v, w, NB_SLOT(nb_add));</span><br><span class="line">    <span class="keyword">if</span> (result == Py_NotImplemented) &#123;</span><br><span class="line">        PySequenceMethods *m = v-&gt;ob_type-&gt;tp_as_sequence;</span><br><span class="line">        Py_DECREF(result);</span><br><span class="line">        <span class="keyword">if</span> (m &amp;&amp; m-&gt;sq_concat) &#123;</span><br><span class="line">            <span class="keyword">return</span> (*m-&gt;sq_concat)(v, w);</span><br><span class="line">        &#125;</span><br><span class="line">        result = binop_type_error(v, w, <span class="string">"+"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数首先调用 <code>binary_op1</code>，<code>NB_SLOT(nb_add)</code> 是求 <code>nb_add</code> 字段在 <code>PyNumberMethods</code> 结构体中的偏移量。在这个函数已经在 <code>BINARY_MULTIPLY</code> 中分析过了，这里不再重复。如果返回值 <code>result</code> 是 <code>NotImplemented</code>，说明有可能是列表拼接（列表的 <code>tp_as_number</code> 字段为 <code>NULL</code>），接下来获取左操作数的 <code>ob_type</code> 的 <code>tp_as_sequence</code> 字段的值 <code>m</code>，并减少 <code>result</code> 的引用计数。然后，检查 <code>m</code> 和 <code>m-&gt;sq_concat</code> 字段是否为 <code>NULL</code>，不是则调用它指向的函数（列表的这个字段指向的函数是<code>list_concat</code>），并将拼接的值返回。如果 <code>m</code> 或者 <code>m-&gt;sq_concat</code> 为 <code>NULL</code>，调用 <code>binop_type_error</code> 设置 <code>TypeError</code>，最后将值返回。</p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python操作码——BINARY_MODULO</title>
      <link href="/python/python-opcode-BINARY_MODULO.html"/>
      <url>/python/python-opcode-BINARY_MODULO.html</url>
      
        <content type="html"><![CDATA[<p><code>BINARY_MODULO</code> 的编号是22，是个不带参数的操作码。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>dis.opmap[<span class="string">'BINARY_MODULO'</span>]</span><br><span class="line"><span class="number">22</span></span><br></pre></td></tr></table></figure><a id="more"></a><p>这个操作码对应 Python 的双目运算符 <code>%</code>，一般用于取模运算或者字符串格式化。实现如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">TARGET(BINARY_MODULO) &#123;</span><br><span class="line">    PyObject *divisor = POP();</span><br><span class="line">    PyObject *dividend = TOP();</span><br><span class="line">    PyObject *res;</span><br><span class="line">    <span class="keyword">if</span> (PyUnicode_CheckExact(dividend) &amp;&amp; (</span><br><span class="line">            !PyUnicode_Check(divisor) || PyUnicode_CheckExact(divisor))) &#123;</span><br><span class="line">        <span class="comment">// fast path; string formatting, but not if the RHS is a str subclass</span></span><br><span class="line">        <span class="comment">// (see issue28598)</span></span><br><span class="line">        res = PyUnicode_Format(dividend, divisor);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        res = PyNumber_Remainder(dividend, divisor);</span><br><span class="line">    &#125;</span><br><span class="line">    Py_DECREF(divisor);</span><br><span class="line">    Py_DECREF(dividend);</span><br><span class="line">    SET_TOP(res);</span><br><span class="line">    <span class="keyword">if</span> (res == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">goto</span> error;</span><br><span class="line">    DISPATCH();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>按照惯例，首先获取左右操作数。接下来，和其它双目运算符不同的是，这里会进行判断，是否左操作数是一个字符串对象且右操作数是一个字符串或者是非字符串子类的对象，注意 <code>PyUnicode_Check</code> 和 <code>PyUnicode_CheckExact</code> 的区别（<em>exact</em> 有“精确的”意思）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PyUnicode_CheckExact(op) (Py_TYPE(op) == &amp;PyUnicode_Type)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PyUnicode_Check(op) \</span></span><br><span class="line">    PyType_FastSubclass(Py_TYPE(op), Py_TPFLAGS_UNICODE_SUBCLASS)</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PyType_FastSubclass(t,f)  PyType_HasFeature(t,f)    </span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PyType_HasFeature(t,f)  (((t)-&gt;tp_flags &amp; (f)) != 0)</span></span><br></pre></td></tr></table></figure><p>如果整个 <code>if</code> 条件为真，将会调用 <code>PyUnicode_Format</code> 进行字符串格式化，否则调用 <code>PyNumber_Remainder</code> 进行运算。往下，减少左右操作数的引用计数，将值栈栈顶的值设为函数的返回值 <code>res</code>，接着检查 <code>res</code> 以确定是跳转到错误处理还是执行下一个操作码。</p><p><code>PyUnicode_Format</code> 在 Objects/unicodeobject.c 中定义，这里不展开。主要来看 <code>PyNumber_Remainder</code>，在 Objects/abstract.c 中定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">PyObject *</span><br><span class="line">PyNumber_Remainder(PyObject *v, PyObject *w)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> binary_op(v, w, NB_SLOT(nb_remainder), <span class="string">"%"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，这个函数就是对 <code>binary_op</code> 的包装，<code>NB_SLOT(nb_remainder)</code> 是获取 <code>nb_remainder</code> 在 <code>PyNumberMethods</code> 结构体中的偏移量。对 <code>binary_op</code> 的分析参考 <code>BINARY_MATRIX_MULTIPLY</code>。</p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python操作码——BINARY_FLOOR_DIVIDE</title>
      <link href="/python/python-opcode-BINARY_FLOOR_DIVIDE.html"/>
      <url>/python/python-opcode-BINARY_FLOOR_DIVIDE.html</url>
      
        <content type="html"><![CDATA[<p><code>BINARY_FLOOR_DIVIDE</code> 操作码的编号是26，是个不带参数的操作码。</p><a id="more"></a><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>dis.opmap[<span class="string">'BINARY_FLOOR_DIVIDE'</span>]</span><br><span class="line"><span class="number">26</span></span><br></pre></td></tr></table></figure><p>这个操作码对应 Python 的双目运算符 <code>//</code>，一般用于整除操作，实现如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">TARGET(BINARY_FLOOR_DIVIDE) &#123;</span><br><span class="line">    PyObject *divisor = POP();</span><br><span class="line">    PyObject *dividend = TOP();</span><br><span class="line">    PyObject *quotient = PyNumber_FloorDivide(dividend, divisor);</span><br><span class="line">    Py_DECREF(dividend);</span><br><span class="line">    Py_DECREF(divisor);</span><br><span class="line">    SET_TOP(quotient);</span><br><span class="line">    <span class="keyword">if</span> (quotient == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">goto</span> error;</span><br><span class="line">    DISPATCH();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和 <code>BINARY_TRUE_DIVIDE</code> 的唯一区别就是 <code>PyNumber_FloorDivide</code>，来看这个函数，在 Objects/abstract.c 中实现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">PyObject *</span><br><span class="line">PyNumber_FloorDivide(PyObject *v, PyObject *w)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> binary_op(v, w, NB_SLOT(nb_floor_divide), <span class="string">"//"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也是对 <code>binary_op</code> 的包装，<code>NB_SLOT(nb_floor_divide)</code> 获取 <code>nb_floor_divide</code> 字段在结构体 <code>PyNumberMethods</code> 中的偏移量。</p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python操作码——BINARY_TRUE_DIVIDE</title>
      <link href="/python/python-opcode-BINARY_TRUE_DIVIDE.html"/>
      <url>/python/python-opcode-BINARY_TRUE_DIVIDE.html</url>
      
        <content type="html"><![CDATA[<p><code>BINARY_TRUE_DIVIDE</code> 操作码的编号是27， 是个不带参数的操作码。</p><a id="more"></a><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>dis.opmap[<span class="string">'BINARY_TRUE_DIVIDE'</span>]</span><br><span class="line"><span class="number">27</span></span><br></pre></td></tr></table></figure><p>这个操作码对应 Python 的双目运算符 <code>/</code>，实现如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">TARGET(BINARY_TRUE_DIVIDE) &#123;</span><br><span class="line">    PyObject *divisor = POP();</span><br><span class="line">    PyObject *dividend = TOP();</span><br><span class="line">    PyObject *quotient = PyNumber_TrueDivide(dividend, divisor);</span><br><span class="line">    Py_DECREF(dividend);</span><br><span class="line">    Py_DECREF(divisor);</span><br><span class="line">    SET_TOP(quotient);</span><br><span class="line">    <span class="keyword">if</span> (quotient == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">goto</span> error;</span><br><span class="line">    DISPATCH();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>与其它双目运算符的实现非常类似，直接来看关键函数 <code>PyNumber_TrueDivide</code>，在 Objects/abstract.c 中实现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">PyObject *</span><br><span class="line">PyNumber_TrueDivide(PyObject *v, PyObject *w)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> binary_op(v, w, NB_SLOT(nb_true_divide), <span class="string">"/"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也是对 <code>binary_op</code> 的包装，<code>NB_SLOT(nb_true_divide)</code> 求 <code>nb_true_divide</code> 字段在结构体 <code>PyNumberMethods</code> 中的偏移量。对 <code>binary_op</code> 函数的分析参考 <code>BINARY_MATRIX_MULTIPLY</code>。</p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python操作码——BINARY_MATRIX_MULTIPLY</title>
      <link href="/python/python-opcode-BINARY_MATRIX_MULTIPLY.html"/>
      <url>/python/python-opcode-BINARY_MATRIX_MULTIPLY.html</url>
      
        <content type="html"><![CDATA[<p><code>BINARY_MATRIX_MULTIPLY</code> 操作码的编号是16， 是个不带参数的操作码。</p><a id="more"></a><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>dis.opmap[<span class="string">'BINARY_MATRIX_MULTIPLY'</span>]</span><br><span class="line"><span class="number">16</span></span><br></pre></td></tr></table></figure><p>这个操作码对象 Python 的双目运算符 <code>@</code>，一般用于矩阵点乘。实现如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">TARGET(BINARY_MATRIX_MULTIPLY) &#123;</span><br><span class="line">    PyObject *right = POP();</span><br><span class="line">    PyObject *left = TOP();</span><br><span class="line">    PyObject *res = PyNumber_MatrixMultiply(left, right);</span><br><span class="line">    Py_DECREF(left);</span><br><span class="line">    Py_DECREF(right);</span><br><span class="line">    SET_TOP(res);</span><br><span class="line">    <span class="keyword">if</span> (res == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">goto</span> error;</span><br><span class="line">    DISPATCH();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从值栈中获取左右操作数 <code>left</code> 和 <code>right</code>，将它们作为参数调用 <code>PyNumber_MatrixMultiply</code> 函数，减少 <code>left</code> 和 <code>right</code> 的引用计数，将值栈栈顶的值设为函数的返回值 <code>res</code>，如果 <code>res</code> 为 <code>NULL</code> 就跳转到错误处理，否则执行下一个操作码。可以看到，<code>PyNumber_MatrixMultiply</code> 是这段代码的关键，它在 Objects/abstract.c 中定义，实现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">PyObject *</span><br><span class="line">PyNumber_MatrixMultiply(PyObject *v, PyObject *w)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> binary_op(v, w, NB_SLOT(nb_matrix_multiply), <span class="string">"@"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数是对 <code>binary_op</code> 的包装，<code>NB_SLOT(nb_matrix_multiply)</code> 是获取 <code>nb_matrix_multiply</code> 字段在 <code>PyNumberMethods</code> 结构体中的偏移量。来看 <code>binary_op</code> 的实现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> PyObject *</span><br><span class="line">binary_op(PyObject *v, PyObject *w, <span class="keyword">const</span> <span class="keyword">int</span> op_slot, <span class="keyword">const</span> <span class="keyword">char</span> *op_name)</span><br><span class="line">&#123;</span><br><span class="line">    PyObject *result = binary_op1(v, w, op_slot);</span><br><span class="line">    <span class="keyword">if</span> (result == Py_NotImplemented) &#123;</span><br><span class="line">        Py_DECREF(result);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (op_slot == NB_SLOT(nb_rshift) &amp;&amp;</span><br><span class="line">            PyCFunction_Check(v) &amp;&amp;</span><br><span class="line">            <span class="built_in">strcmp</span>(((PyCFunctionObject *)v)-&gt;m_ml-&gt;ml_name, <span class="string">"print"</span>) == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            PyErr_Format(PyExc_TypeError,</span><br><span class="line">                <span class="string">"unsupported operand type(s) for %.100s: "</span></span><br><span class="line">                <span class="string">"'%.100s' and '%.100s'. Did you mean \"print(&lt;message&gt;, "</span></span><br><span class="line">                <span class="string">"file=&lt;output_stream&gt;)\"?"</span>,</span><br><span class="line">                op_name,</span><br><span class="line">                v-&gt;ob_type-&gt;tp_name,</span><br><span class="line">                w-&gt;ob_type-&gt;tp_name);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> binop_type_error(v, w, op_name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数开头会调用 <code>binary_op1</code>，这个函数在 <code>BINARY_MULTIPLY</code> 中已经分析过了，这里不再重复。如果返回值 <code>result</code> 是 <code>NotImplemented</code>，减少 <code>result</code> 的引用计数，接着检查 <code>opslot</code> 是否是 <code>nb_rshift</code> 且 <code>v</code> 是内置的 <code>print</code> 函数，如果条件为真，设置 <code>TypeError</code>，返回 <code>NULL</code>，不为真则通过 <code>binop_type_error</code> 设置 <code>TypeError</code> 并返回 <code>NULL</code>。注意这两个 <code>TypeError</code> 的提示信息是不一样的。最后，如果 <code>result</code> 不是 <code>NotImplemented</code> 就直接返回 <code>result</code>。</p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python操作码——BINARY_MULTIPLY</title>
      <link href="/python/python-opcode-BINARY_MULTIPLY.html"/>
      <url>/python/python-opcode-BINARY_MULTIPLY.html</url>
      
        <content type="html"><![CDATA[<p><code>BINARY_MULTIPLY</code> 的编号是20，是一个不带参数的操作码。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>dis.opmap[<span class="string">'BINARY_MULTIPLY'</span>]</span><br><span class="line"><span class="number">20</span></span><br></pre></td></tr></table></figure><a id="more"></a><p>这个操作码对应 Python 的双目运算符 <code>*</code>，实现如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">TARGET(BINARY_MULTIPLY) &#123;</span><br><span class="line">    PyObject *right = POP();</span><br><span class="line">    PyObject *left = TOP();</span><br><span class="line">    PyObject *res = PyNumber_Multiply(left, right);</span><br><span class="line">    Py_DECREF(left);</span><br><span class="line">    Py_DECREF(right);</span><br><span class="line">    SET_TOP(res);</span><br><span class="line">    <span class="keyword">if</span> (res == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">goto</span> error;</span><br><span class="line">    DISPATCH();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先从值栈获取双目运算的右操作数 <code>right</code> 和 左操作数 <code>left</code>，将它们作为参数调用 <code>PyNumber_Multiply</code>，这个是实际执行 <code>*</code> 操作的函数，在 Objects/abstract.c 文件中定义，实现如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">PyObject *</span><br><span class="line">PyNumber_Multiply(PyObject *v, PyObject *w)</span><br><span class="line">&#123;</span><br><span class="line">    PyObject *result = binary_op1(v, w, NB_SLOT(nb_multiply));</span><br><span class="line">    <span class="keyword">if</span> (result == Py_NotImplemented) &#123;</span><br><span class="line">        PySequenceMethods *mv = v-&gt;ob_type-&gt;tp_as_sequence;</span><br><span class="line">        PySequenceMethods *mw = w-&gt;ob_type-&gt;tp_as_sequence;</span><br><span class="line">        Py_DECREF(result);</span><br><span class="line">        <span class="keyword">if</span>  (mv &amp;&amp; mv-&gt;sq_repeat) &#123;</span><br><span class="line">            <span class="keyword">return</span> sequence_repeat(mv-&gt;sq_repeat, v, w);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (mw &amp;&amp; mw-&gt;sq_repeat) &#123;</span><br><span class="line">            <span class="keyword">return</span> sequence_repeat(mw-&gt;sq_repeat, w, v);</span><br><span class="line">        &#125;</span><br><span class="line">        result = binop_type_error(v, w, <span class="string">"*"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数一开始会调用 <code>binary_op1</code>，<code>NB_SLOT</code> 宏定义为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NB_SLOT(x) offsetof(PyNumberMethods, x)</span></span><br></pre></td></tr></table></figure><p><code>NB_SLOT(nb_multiply)</code> 就是求 <code>nb_multiply</code> 字段在 <code>PyNumberMethods</code> 结构体中的偏移量。来看 <code>binary_op1</code> 的实现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> PyObject *</span><br><span class="line">binary_op1(PyObject *v, PyObject *w, <span class="keyword">const</span> <span class="keyword">int</span> op_slot)</span><br><span class="line">&#123;</span><br><span class="line">    PyObject *x;</span><br><span class="line">    binaryfunc slotv = <span class="literal">NULL</span>;</span><br><span class="line">    binaryfunc slotw = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (v-&gt;ob_type-&gt;tp_as_number != <span class="literal">NULL</span>)</span><br><span class="line">        slotv = NB_BINOP(v-&gt;ob_type-&gt;tp_as_number, op_slot);</span><br><span class="line">    <span class="keyword">if</span> (w-&gt;ob_type != v-&gt;ob_type &amp;&amp;</span><br><span class="line">        w-&gt;ob_type-&gt;tp_as_number != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        slotw = NB_BINOP(w-&gt;ob_type-&gt;tp_as_number, op_slot);</span><br><span class="line">        <span class="keyword">if</span> (slotw == slotv)</span><br><span class="line">            slotw = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (slotv) &#123;</span><br><span class="line">        <span class="keyword">if</span> (slotw &amp;&amp; PyType_IsSubtype(w-&gt;ob_type, v-&gt;ob_type)) &#123;</span><br><span class="line">            x = slotw(v, w);</span><br><span class="line">            <span class="keyword">if</span> (x != Py_NotImplemented)</span><br><span class="line">                <span class="keyword">return</span> x;</span><br><span class="line">            Py_DECREF(x); <span class="comment">/* can't do it */</span></span><br><span class="line">            slotw = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        x = slotv(v, w);</span><br><span class="line">        <span class="keyword">if</span> (x != Py_NotImplemented)</span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        Py_DECREF(x); <span class="comment">/* can't do it */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (slotw) &#123;</span><br><span class="line">        x = slotw(v, w);</span><br><span class="line">        <span class="keyword">if</span> (x != Py_NotImplemented)</span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        Py_DECREF(x); <span class="comment">/* can't do it */</span></span><br><span class="line">    &#125;</span><br><span class="line">    Py_RETURN_NOTIMPLEMENTED;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数先检查 <code>v</code> 的 <code>ob_type</code> 字段的 <code>tp_as_number</code> 是否为 <code>NULL</code>， 不是则通过宏 <code>NB_BINOP</code> 获取其 <code>nb_multiply</code> 字段指向的函数赋给 <code>slotv</code>。<code>NB_BINOP</code> 定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NB_BINOP(nb_methods, slot) \</span></span><br><span class="line">        (*(binaryfunc*)(&amp; ((<span class="keyword">char</span>*)nb_methods)[slot]))</span><br></pre></td></tr></table></figure><p>接着判断 <code>w</code> 和 <code>v</code> 是否不是同一类型且 <code>w</code> 的 <code>ob_type</code> 字段的 <code>tp_as_number</code> 字段不为 <code>NULL</code>，条件为真则也获取其 <code>nb_multiply</code> 字段 指向的函数赋给 <code>slotw</code>，如果两个值相等，则将 <code>slotw</code> 设为 <code>NULL</code>。</p><p>往下，如果 <code>slotv</code> 不为 <code>NULL</code>，再进一步判断，如果 <code>slotw</code> 不为 <code>NULL</code> 且 <code>w</code> 是 <code>v</code> 的子类，调用 <code>slotw</code>。如果返回值 <code>x</code> 不是 <code>NotImplemented</code>，返回 <code>x</code>。否则减少 <code>x</code> 的引用计数，将 <code>slotw</code> 设为 <code>NULL</code>。既然没返回，接着调用 <code>slotv</code> 再像前面一样判断返回值。</p><p>如果再往下执行，说明前面 <code>v-&gt;ob_type-&gt;tp_as_number</code> 为 <code>NULL</code>，接下来要判断 <code>w</code>，如果不为 <code>NULL</code>，调用 <code>slotw</code>，再对返回值做同样的判断处理。到了这里还是没返回的话，最后只能返回 <code>NotImplemented</code> 了。<code>Py_RETURN_NOTIMPLEMENTED</code> 宏做的事就是增加 <code>NotImplemented</code> 的引用计数并返回它，定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Py_RETURN_NOTIMPLEMENTED return Py_INCREF(Py_NotImplemented), Py_NotImplemented</span></span><br></pre></td></tr></table></figure><p>回到 <code>PyNumber_Multiply</code>，如果返回值是 <code>NotImplemented</code>，获取 <code>v</code> 和 <code>w</code> 的 <code>ob_type</code> 的 <code>tp_as_sequence</code> 字段的值，这是 <code>PySequenceMethods *</code> 类型的值，<code>PySequenceMethods</code> 结构体是定义序列协议的结构体，由一系列的函数指针类型和 <code>void *</code> 类型的字段组成：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    lenfunc sq_length;</span><br><span class="line">    binaryfunc sq_concat;</span><br><span class="line">    ssizeargfunc sq_repeat;</span><br><span class="line">    ssizeargfunc sq_item;</span><br><span class="line">    <span class="keyword">void</span> *was_sq_slice;</span><br><span class="line">    ssizeobjargproc sq_ass_item;</span><br><span class="line">    <span class="keyword">void</span> *was_sq_ass_slice;</span><br><span class="line">    objobjproc sq_contains;</span><br><span class="line"></span><br><span class="line">    binaryfunc sq_inplace_concat;</span><br><span class="line">    ssizeargfunc sq_inplace_repeat;</span><br><span class="line">&#125; PySequenceMethods;</span><br></pre></td></tr></table></figure><p>往下，减少 <code>result</code> （这里是 <code>NotImplemented</code>）的引用计数。接着，检查 <code>sq_repeat</code> 字段的值，不为 <code>NULL</code> 则调用 <code>sequence_repeat</code> 并将结果返回，这个函数定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> PyObject *</span><br><span class="line">sequence_repeat(ssizeargfunc repeatfunc, PyObject *seq, PyObject *n)</span><br><span class="line">&#123;</span><br><span class="line">    Py_ssize_t count;</span><br><span class="line">    <span class="keyword">if</span> (PyIndex_Check(n)) &#123;</span><br><span class="line">        count = PyNumber_AsSsize_t(n, PyExc_OverflowError);</span><br><span class="line">        <span class="keyword">if</span> (count == <span class="number">-1</span> &amp;&amp; PyErr_Occurred())</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> type_error(<span class="string">"can't multiply sequence by "</span></span><br><span class="line">                          <span class="string">"non-int of type '%.200s'"</span>, n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (*repeatfunc)(seq, count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>PyIndex_Check</code> 是一个宏，定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PyIndex_Check(obj)                              \</span></span><br><span class="line">    ((obj)-&gt;ob_type-&gt;tp_as_number != <span class="literal">NULL</span> &amp;&amp;            \</span><br><span class="line">     (obj)-&gt;ob_type-&gt;tp_as_number-&gt;nb_index != <span class="literal">NULL</span>)</span><br></pre></td></tr></table></figure><p>对参数 <code>n</code>（这里是传入的 <code>w</code>）进行检查，为真则调用 <code>PyNumber_AsSsize_t</code> 检查 <code>n</code> 是否溢出，溢出则设置 <code>OverflowError</code> 并返回 <code>NULL</code>；为假说明 <code>n</code> 不是 <code>int</code> 类型，将返回 <code>TypeError</code>，最后，没有异常发生，调用 <code>repeatfunc</code> 并返回结果。</p><p>再次回到 <code>PyNumber_Multiply</code>，往下执行说明 <code>mv</code> 和 <code>mw</code> 或者它们的 <code>sq_repeat</code> 字段都是 <code>NULL</code>，调用 <code>binop_type_error</code> 设置 <code>TypeError</code> 异常并将 <code>result</code> 设为 <code>NULL</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> PyObject *</span><br><span class="line">binop_type_error(PyObject *v, PyObject *w, <span class="keyword">const</span> <span class="keyword">char</span> *op_name)</span><br><span class="line">&#123;</span><br><span class="line">    PyErr_Format(PyExc_TypeError,</span><br><span class="line">                 <span class="string">"unsupported operand type(s) for %.100s: "</span></span><br><span class="line">                 <span class="string">"'%.100s' and '%.100s'"</span>,</span><br><span class="line">                 op_name,</span><br><span class="line">                 v-&gt;ob_type-&gt;tp_name,</span><br><span class="line">                 w-&gt;ob_type-&gt;tp_name);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到了这里说明左右操作数都不支持双目运算符 <code>*</code>。最后，将 <code>result</code> 返回， <code>PyNumber_Multiply</code> 函数就此结束。</p><p>回到操作码的执行，<code>res</code> 接收返回值，接着减少 <code>left</code> 和 <code>right</code> 的引用计数，并将值栈栈顶值设为 <code>res</code>，如果 <code>res</code> 为 <code>NULL</code>，跳转到错误处理，否则执行下一个操作码。</p><p>试着用一个实例简单走一遍执行过程，Python 的列表支持 <code>*</code> 操作，如 <code>[1] * 5</code> 的结果是 <code>[1, 1, 1, 1, 1]</code>，这个例子中，左操作数是列表对象 <code>[1]</code>，右操作数是 <code>int</code> 对象 <code>5</code>，传入 <code>PyNumber_Multiply</code>，然后来到 <code>binary_op1</code>，列表的 <code>tp_as_number</code> 字段为 <code>NULL</code>，所以 <code>slotv</code> 为 <code>NULL</code>，<code>int</code> 对象的 <code>tp_as_number</code> 对象有值，<code>slotw</code> 不为 <code>NULL</code>。于是直接跳过了 <code>if (slotv)</code> 的分支，进入 <code>if (slotw)</code> 的分支。调用 <code>slotw</code>，对应 Objects/longobject.c 文件中的 <code>long_mul</code> 函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> PyObject *</span><br><span class="line">long_mul(PyLongObject *a, PyLongObject *b)</span><br><span class="line">&#123;</span><br><span class="line">    PyLongObject *z;</span><br><span class="line"></span><br><span class="line">    CHECK_BINOP(a, b);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 后面的省略...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>CHECK_BINOP</code> 是一个宏，检查两个操作数的类型：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CHECK_BINOP(v,w) do &#123; <span class="meta-keyword">if</span> (!PyLong_Check(v) || !PyLong_Check(w)) Py_RETURN_NOTIMPLEMENTED; &#125; while(0)</span></span><br></pre></td></tr></table></figure><p>两个操作数都必须是 <code>int</code> 对象（<code>int</code> 对象在 Python 底层叫 <code>PyLongObject</code>）。很明显 <code>v</code> 是不是 <code>int</code> 对象，于是返回 <code>NotImplemented</code>。回到 <code>binary_op1</code>，它也返回 <code>NotImplemented</code>，再回到 <code>PyNumber_Multiply</code>，获取 <code>ob_type</code> 的 <code>tp_as_sequence</code> 的值，列表对象存在这个值而 <code>int</code> 对象的这个值为 <code>NULL</code>，于是进入 <code>sequence_repeat</code> 函数。检查 <code>n</code>，这里 <code>n</code> 为 <code>5</code>，所以直接调用 <code>sq_repeat</code> 指向的函数，对应 Objects/listobject.c 的 <code>list_repeat</code>，就是这个函数实现了列表的双目运算符 <code>*</code> 操作。这里不再列出该函数，有兴趣的自行查看。分析至此结束。</p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python操作码——BINARY_POWER</title>
      <link href="/python/python-opcode-BINARY_POWER.html"/>
      <url>/python/python-opcode-BINARY_POWER.html</url>
      
        <content type="html"><![CDATA[<p><code>BINARY_POWER</code> 操作码的编号是19，是个不带参数的操作码。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>dis.opmap[<span class="string">'BINARY_POWER'</span>]</span><br><span class="line"><span class="number">19</span></span><br></pre></td></tr></table></figure><a id="more"></a><p>这个操作码对应 Python 的双目运算符 <code>**</code>，常用于数字的幂运算。底层实现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">TARGET(BINARY_POWER) &#123;</span><br><span class="line">    PyObject *<span class="built_in">exp</span> = POP();</span><br><span class="line">    PyObject *base = TOP();</span><br><span class="line">    PyObject *res = PyNumber_Power(base, <span class="built_in">exp</span>, Py_None);</span><br><span class="line">    Py_DECREF(base);</span><br><span class="line">    Py_DECREF(<span class="built_in">exp</span>);</span><br><span class="line">    SET_TOP(res);</span><br><span class="line">    <span class="keyword">if</span> (res == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">goto</span> error;</span><br><span class="line">    DISPATCH();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先从值栈中获取幂运算的指数 <code>exp</code> 和底数 <code>base</code>，它们被压入值栈中的顺序是先底数后指数，所以获取时顺序相反，看个例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>dis.dis(<span class="string">'a = 2; a**2'</span>)</span><br><span class="line">  <span class="number">1</span>           <span class="number">0</span> LOAD_CONST               <span class="number">0</span> (<span class="number">2</span>)</span><br><span class="line">              <span class="number">2</span> STORE_NAME               <span class="number">0</span> (a)</span><br><span class="line">              <span class="number">4</span> LOAD_NAME                <span class="number">0</span> (a)</span><br><span class="line">              <span class="number">6</span> LOAD_CONST               <span class="number">0</span> (<span class="number">2</span>)</span><br><span class="line">              <span class="number">8</span> BINARY_POWER</span><br><span class="line">             <span class="number">10</span> POP_TOP</span><br><span class="line">             <span class="number">12</span> LOAD_CONST               <span class="number">1</span> (<span class="literal">None</span>)</span><br><span class="line">             <span class="number">14</span> RETURN_VALUE</span><br></pre></td></tr></table></figure><p>从第三列开始，<code>LOAD_NAME</code> 将底数 <code>a</code> 对应的值压入值栈中，<code>LOAD_CONST</code> 将指数2压入值栈中。接着执行 <code>BINARY_POWER</code>。</p><p>往下，获取底数和指数之后，将它们作为参数调用 <code>PyNumber_Power</code>，这个函数在 Objects/abstract.c 中定义，具体实现如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">PyObject *</span><br><span class="line">PyNumber_Power(PyObject *v, PyObject *w, PyObject *z)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> PyNumberMethods(v, w, z, NB_SLOT(nb_power), <span class="string">"** or pow()"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到这个函数就是对 <code>ternary_op</code> 的简单包装，先来看传给 <code>ternary_op</code> 函数的参数。<code>v</code> 是底数，<code>w</code> 是指数，<code>z</code> 是 <code>None</code>，<code>NB_SLOT</code>，一个宏，定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NB_SLOT(x) offsetof(PyNumberMethods, x)</span></span><br></pre></td></tr></table></figure><p>使用 C 库的 <code>offsetof</code> 宏求 <code>x</code> 在 <code>PyNumberMethods</code> 结构体中的偏移量，这里求的是 <code>nb_power</code>。最后一个参数是一个常量字符串。接下来来看看 <code>ternary_op</code> 函数的实现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> PyObject *</span><br><span class="line">ternary_op(PyObject *v,</span><br><span class="line">           PyObject *w,</span><br><span class="line">           PyObject *z,</span><br><span class="line">           <span class="keyword">const</span> <span class="keyword">int</span> op_slot,</span><br><span class="line">           <span class="keyword">const</span> <span class="keyword">char</span> *op_name)</span><br><span class="line">&#123;</span><br><span class="line">    PyNumberMethods *mv, *mw, *mz;</span><br><span class="line">    PyObject *x = <span class="literal">NULL</span>;</span><br><span class="line">    ternaryfunc slotv = <span class="literal">NULL</span>;</span><br><span class="line">    ternaryfunc slotw = <span class="literal">NULL</span>;</span><br><span class="line">    ternaryfunc slotz = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    mv = v-&gt;ob_type-&gt;tp_as_number;</span><br><span class="line">    mw = w-&gt;ob_type-&gt;tp_as_number;</span><br><span class="line">    <span class="keyword">if</span> (mv != <span class="literal">NULL</span>)</span><br><span class="line">        slotv = NB_TERNOP(mv, op_slot);</span><br><span class="line">    <span class="keyword">if</span> (w-&gt;ob_type != v-&gt;ob_type &amp;&amp;</span><br><span class="line">        mw != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        slotw = NB_TERNOP(mw, op_slot);</span><br><span class="line">        <span class="keyword">if</span> (slotw == slotv)</span><br><span class="line">            slotw = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (slotv) &#123;</span><br><span class="line">        <span class="keyword">if</span> (slotw &amp;&amp; PyType_IsSubtype(w-&gt;ob_type, v-&gt;ob_type)) &#123;</span><br><span class="line">            x = slotw(v, w, z);</span><br><span class="line">            <span class="keyword">if</span> (x != Py_NotImplemented)</span><br><span class="line">                <span class="keyword">return</span> x;</span><br><span class="line">            Py_DECREF(x); <span class="comment">/* can't do it */</span></span><br><span class="line">            slotw = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        x = slotv(v, w, z);</span><br><span class="line">        <span class="keyword">if</span> (x != Py_NotImplemented)</span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        Py_DECREF(x); <span class="comment">/* can't do it */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (slotw) &#123;</span><br><span class="line">        x = slotw(v, w, z);</span><br><span class="line">        <span class="keyword">if</span> (x != Py_NotImplemented)</span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        Py_DECREF(x); <span class="comment">/* can't do it */</span></span><br><span class="line">    &#125;</span><br><span class="line">    mz = z-&gt;ob_type-&gt;tp_as_number;</span><br><span class="line">    <span class="keyword">if</span> (mz != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        slotz = NB_TERNOP(mz, op_slot);</span><br><span class="line">        <span class="keyword">if</span> (slotz == slotv || slotz == slotw)</span><br><span class="line">            slotz = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">if</span> (slotz) &#123;</span><br><span class="line">            x = slotz(v, w, z);</span><br><span class="line">            <span class="keyword">if</span> (x != Py_NotImplemented)</span><br><span class="line">                <span class="keyword">return</span> x;</span><br><span class="line">            Py_DECREF(x); <span class="comment">/* can't do it */</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (z == Py_None)</span><br><span class="line">        PyErr_Format(</span><br><span class="line">            PyExc_TypeError,</span><br><span class="line">            <span class="string">"unsupported operand type(s) for ** or pow(): "</span></span><br><span class="line">            <span class="string">"'%.100s' and '%.100s'"</span>,</span><br><span class="line">            v-&gt;ob_type-&gt;tp_name,</span><br><span class="line">            w-&gt;ob_type-&gt;tp_name);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        PyErr_Format(</span><br><span class="line">            PyExc_TypeError,</span><br><span class="line">            <span class="string">"unsupported operand type(s) for pow(): "</span></span><br><span class="line">            <span class="string">"'%.100s', '%.100s', '%.100s'"</span>,</span><br><span class="line">            v-&gt;ob_type-&gt;tp_name,</span><br><span class="line">            w-&gt;ob_type-&gt;tp_name,</span><br><span class="line">            z-&gt;ob_type-&gt;tp_name);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数开头定义了三个 <code>PyNumberMethods *</code> 类型的变量 <code>mv</code>、<code>mw</code>、<code>mz</code>，一个 <code>PyObject *</code> 类型的变量 <code>x</code> 和三个 <code>ternaryfunc</code> 函数指针类型的变量 <code>slotv</code>、<code>slotw</code>、<code>slotz</code>。接下来分别获取 <code>v</code> 和 <code>w</code> 的 <code>ob_type</code> 的 <code>tp_as_number</code> 字段的值。如果 <code>mv</code> 不为 <code>NULL</code>，使用 <code>NB_TERNOP</code> 宏获取它的 <code>nb_power</code> 字段指向的函数并赋值给 slotv。宏的定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NB_TERNOP(nb_methods,slot) \</span></span><br><span class="line">        (*(ternaryfunc*)(&amp; ((<span class="keyword">char</span>*)nb_methods)[slot]))</span><br></pre></td></tr></table></figure><blockquote><p>简单解释这个宏，这里传进来的 <code>nb_methods</code> 是一个 <code>PyNumberMethods *</code> 类型的值，而 <code>slot</code> 是个 <code>int</code> 类型的值，表示偏移量。<code>(char *)nb_methods</code> 将 <code>nb_methods</code> 转换成了 <code>char *</code> 类型，后面的下标运算相当于 <code>((char *)nb_methods) + slot</code>，于是取到了 <code>nb_power</code> 在 <code>PyNumberMethods</code> 的首地址对应的值。但是，这里需要的是地址，所以就有了 <code>&amp;</code> 取地址符。拿到了地址之后，转换成 <code>ternaryfunc *</code> 的形式读取，最后用 <code>*</code> 解引用得到了 <code>nb_power</code> 指向的那个函数。</p></blockquote><p>接下来判断 <code>w</code> 和 <code>v</code> 是否是不同类型，如果不是且 <code>mv</code> 不为 <code>NULL</code>，同样使用宏获取它的 <code>nb_power</code> 指向的函数并赋值给 <code>slotw</code>，如果 <code>slotw</code> 和 <code>slotv</code> 是同一个函数，就将 <code>slotw</code> 设为 <code>NULL</code>。</p><p>往下，<code>slotv</code> 不为 <code>NULL</code> 的情况，如果 <code>slotw</code> 也不为 <code>NULL</code> 且 <code>w</code> 是 <code>v</code> 的子类，直接将 <code>v</code>、<code>w</code>、<code>z</code> 作为参数调用 <code>slotw</code>，如果返回值 <code>x</code> 不是 <code>NotImplemented</code>，直接将 <code>x</code> 返回。否则，减少 <code>x</code> 的引用计数并将 <code>slotw</code> 设为 <code>NULL</code>。再往下，调用 <code>slotv</code>，然后再次判断结果决定是否返回。</p><p>没有返回，继续往下执行，如果 <code>slotw</code> 不为 <code>NULL</code>，调用 <code>slotw</code> 然后重复上述过程。如果函数还是没返回，获取 <code>z</code> 的 <code>ob_type</code> 的 <code>tp_as_number</code> 字段的值 <code>mz</code>，接下来的工作和前面非常类似，这里不再解释。如果函数还是没返回，接下来将检查 <code>z</code> 是否为 <code>None</code> 以设置不同提示的 <code>TypeError</code>，最后返回 <code>NULL</code>。</p><p>回到操作码的执行，结果由 <code>res</code> 接收。接下来减少 <code>base</code> 和 <code>exp</code> 的引用计数，并将值栈栈顶值设为 <code>res</code>，如果 <code>res</code> 为 <code>NULL</code>，跳转到错误处理部分，否则执行下一个操作码。</p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python操作码——UNARY_INVERT</title>
      <link href="/python/python-opcode-UNARY_INVERT.html"/>
      <url>/python/python-opcode-UNARY_INVERT.html</url>
      
        <content type="html"><![CDATA[<p><code>UNARY_INVERT</code> 操作码的编号是15，是个不带参数的操作码。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>dis.opmap[<span class="string">'UNARY_INVERT'</span>]</span><br><span class="line"><span class="number">15</span></span><br></pre></td></tr></table></figure><a id="more"></a><p>这个操作码对应 Python 的单目运算符 <code>~</code>，底层实现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">TARGET(UNARY_INVERT) &#123;</span><br><span class="line">    PyObject *value = TOP();</span><br><span class="line">    PyObject *res = PyNumber_Invert(value);</span><br><span class="line">    Py_DECREF(value);</span><br><span class="line">    SET_TOP(res);</span><br><span class="line">    <span class="keyword">if</span> (res == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">goto</span> error;</span><br><span class="line">    DISPATCH();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先获取值栈栈顶的值 <code>value</code>，然后将其作为参数调用 <code>PyNumber_Invert</code>，在 Objects/abstract.c 中定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">PyObject *</span><br><span class="line">PyNumber_Invert(PyObject *o)</span><br><span class="line">&#123;</span><br><span class="line">    PyNumberMethods *m;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (o == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> null_error();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    m = o-&gt;ob_type-&gt;tp_as_number;</span><br><span class="line">    <span class="keyword">if</span> (m &amp;&amp; m-&gt;nb_invert)</span><br><span class="line">        <span class="keyword">return</span> (*m-&gt;nb_invert)(o);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> type_error(<span class="string">"bad operand type for unary ~: '%.200s'"</span>, o);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数的核心是检查对象 <code>o</code> 的 <code>ob_type</code> 字段的 <code>tp_as_number</code> 的 <code>nb_invert</code> 字段的值是否为 <code>NULL</code>，这个字段的值是一个函数指针，如果不为 <code>NULL</code> 则调用它并将结果返回，否则设置 <code>TypeError</code> 并返回 <code>NULL</code>。</p><p>回到操作码的执行，返回值由 <code>res</code> 接收，往下会减少 <code>value</code> 的引用计数，并将值栈栈顶的值设置成 <code>res</code>， 如果 <code>res</code> 为 <code>NULL</code>，跳转到错误处理，否则执行下一个操作码。</p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python操作码——UNARY_NOT</title>
      <link href="/python/python-opcode-UNARY_NOT.html"/>
      <url>/python/python-opcode-UNARY_NOT.html</url>
      
        <content type="html"><![CDATA[<p>操作码 <code>UNARY_NOT</code> 的编号是12，是一个不带参数的操作码。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>dis.opmap[<span class="string">'UNARY_NOT'</span>]</span><br><span class="line"><span class="number">12</span></span><br></pre></td></tr></table></figure><a id="more"></a><p>这个操作码对应 Python 的 <code>not</code> 运算符，实现如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">TARGET(UNARY_NOT) &#123;</span><br><span class="line">    PyObject *value = TOP();</span><br><span class="line">    <span class="keyword">int</span> err = PyObject_IsTrue(value);</span><br><span class="line">    Py_DECREF(value);</span><br><span class="line">    <span class="keyword">if</span> (err == <span class="number">0</span>) &#123;</span><br><span class="line">        Py_INCREF(Py_True);</span><br><span class="line">        SET_TOP(Py_True);</span><br><span class="line">        DISPATCH();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (err &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        Py_INCREF(Py_False);</span><br><span class="line">        SET_TOP(Py_False);</span><br><span class="line">        DISPATCH();</span><br><span class="line">    &#125;</span><br><span class="line">    STACKADJ(<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">goto</span> error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先获取值栈栈顶的值 <code>value</code>，然后将其作为参数调用 <code>PyObject_IsTrue</code>，这个函数位于 Objects/object.c，实现如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span></span><br><span class="line">PyObject_IsTrue(PyObject *v)</span><br><span class="line">&#123;</span><br><span class="line">    Py_ssize_t res;</span><br><span class="line">    <span class="keyword">if</span> (v == Py_True)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (v == Py_False)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (v == Py_None)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (v-&gt;ob_type-&gt;tp_as_number != <span class="literal">NULL</span> &amp;&amp;</span><br><span class="line">             v-&gt;ob_type-&gt;tp_as_number-&gt;nb_bool != <span class="literal">NULL</span>)</span><br><span class="line">        res = (*v-&gt;ob_type-&gt;tp_as_number-&gt;nb_bool)(v);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (v-&gt;ob_type-&gt;tp_as_mapping != <span class="literal">NULL</span> &amp;&amp;</span><br><span class="line">             v-&gt;ob_type-&gt;tp_as_mapping-&gt;mp_length != <span class="literal">NULL</span>)</span><br><span class="line">        res = (*v-&gt;ob_type-&gt;tp_as_mapping-&gt;mp_length)(v);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (v-&gt;ob_type-&gt;tp_as_sequence != <span class="literal">NULL</span> &amp;&amp;</span><br><span class="line">             v-&gt;ob_type-&gt;tp_as_sequence-&gt;sq_length != <span class="literal">NULL</span>)</span><br><span class="line">        res = (*v-&gt;ob_type-&gt;tp_as_sequence-&gt;sq_length)(v);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="comment">/* if it is negative, it should be either -1 or -2 */</span></span><br><span class="line">    <span class="keyword">return</span> (res &gt; <span class="number">0</span>) ? <span class="number">1</span> : Py_SAFE_DOWNCAST(res, Py_ssize_t, <span class="keyword">int</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数的逻辑比较简单，如果参数 <code>v</code> 是 <code>True</code> 返回1，是 <code>False</code> 返回0。如果是 <code>None</code> 也返回0，否则会依序检查参数的 <code>ob_type</code> 的 <code>tp_as_number</code> 的 <code>nb_bool</code> 字段（一个函数指针），<code>tp_as_mapping</code> 的 <code>mp_length</code> 字段和 <code>tp_as_sequence</code> 的 <code>sq_length</code> 字段，不为 <code>NULL</code> 则调用它们指向的函数。如果以上条件都不符合，则认为这个对象是真值，直接返回1。最后，如果上述的某个函数指针不为 <code>NULL</code>，会对其函数调用的结果 <code>res</code> 进行判断，如果 <code>res</code> 大于0，则认为这个对象是真值，返回1。如果 <code>res</code> 小于0，那么它应该是-1或者-2，将 <code>res</code> 转换成 <code>int</code> 类型返回。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> Py_DEBUG</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Py_SAFE_DOWNCAST(VALUE, WIDE, NARROW) \</span></span><br><span class="line">    (assert((WIDE)(NARROW)(VALUE) == (VALUE)), (NARROW)(VALUE))</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Py_SAFE_DOWNCAST(VALUE, WIDE, NARROW) (NARROW)(VALUE)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>回到操作码的执行，首先会减少 <code>value</code> 的引用计数，接着对调用 <code>PyObject_IsTrue</code> 的结果 <code>err</code> 进行判断，如果为0，说明 <code>value</code> 是假值，对假值进行 <code>not</code> 操作，那么结果是一个真值，所以这里会增加 <code>True</code> 的引用计数并将其设置为值栈栈顶的值。同理，如果 <code>err</code> 大于0，说明 <code>value</code> 是真值，对真值进行 <code>not</code> 操作，结果就是假值，所以要增加 <code>False</code> 的引用计数并将其设为值栈栈顶的值。<code>Py_True</code> 和 <code>Py_False</code> 是 <code>True</code> 和 <code>False</code> 在 Python 底层的表示。最后如果以上结果都不是，调整 <code>stack_pointer</code> 指针，跳转到错误处理。</p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python操作码——UNARY_NEGATIVE</title>
      <link href="/python/python-opcode-UNARY_NEGATIVE.html"/>
      <url>/python/python-opcode-UNARY_NEGATIVE.html</url>
      
        <content type="html"><![CDATA[<p><code>UNARY_NEGATIVE</code> 的编号是11，是一个不带参数的操作码。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>dis.opmap[<span class="string">'UNARY_NEGATIVE'</span>]</span><br><span class="line"><span class="number">11</span></span><br></pre></td></tr></table></figure><a id="more"></a><p>这个操作码对应 Python 的单目运算符 <code>-</code>，底层实现如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">TARGET(UNARY_NEGATIVE) &#123;</span><br><span class="line">    PyObject *value = TOP();</span><br><span class="line">    PyObject *res = PyNumber_Negative(value);</span><br><span class="line">    Py_DECREF(value);</span><br><span class="line">    SET_TOP(res);</span><br><span class="line">    <span class="keyword">if</span> (res == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">goto</span> error;</span><br><span class="line">    DISPATCH();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和 <code>UNARY_POSITIVE</code> 非常类似，获取值栈栈顶的值 <code>value</code> 并将其作为参数调用 <code>PyNumber_Negative</code>，然后减少 <code>value</code> 的引用计数并将值栈栈顶的值设置为函数 <code>PyNumber_Negative</code> 的返回值 <code>res</code>（简单来说就是弹出 <code>value</code> 并压入 <code>res</code>），如果 <code>res</code> 的值为 <code>NULL</code> 则跳转到错误处理部分，否则执行下一个操作码。这里面的关键是 <code>PyNumber_Negative</code> 函数，在 Objects/abstract.c 中定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">PyObject *</span><br><span class="line">PyNumber_Negative(PyObject *o)</span><br><span class="line">&#123;</span><br><span class="line">    PyNumberMethods *m;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (o == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> null_error();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    m = o-&gt;ob_type-&gt;tp_as_number;</span><br><span class="line">    <span class="keyword">if</span> (m &amp;&amp; m-&gt;nb_negative)</span><br><span class="line">        <span class="keyword">return</span> (*m-&gt;nb_negative)(o);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> type_error(<span class="string">"bad operand type for unary -: '%.200s'"</span>, o);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数会获取参数 <code>o</code> 的 <code>ob_type</code> 字段的 <code>tp_as_number</code> 字段的值 <code>m</code>，如果 <code>m</code> 不为 <code>NULL</code> 且 <code>m</code> 的 <code>nb_negative</code> 字段的值（一个函数指针）不为 <code>NULL</code>，则将 <code>o</code> 作为参数调用它并将结果返回。否则会设置 <code>TypeError</code> 并返回 <code>NULL</code>。</p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python操作码——UNARY_POSITIVE</title>
      <link href="/python/python-opcode-UNARY_POSITIVE.html"/>
      <url>/python/python-opcode-UNARY_POSITIVE.html</url>
      
        <content type="html"><![CDATA[<p><code>UNARY_POSITIVE</code> 的编号是10，是个不带参数的操作码。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>dis.opmap[<span class="string">'UNARY_POSITIVE'</span>]</span><br><span class="line"><span class="number">10</span></span><br></pre></td></tr></table></figure><a id="more"></a><p>这个操作码对应 Python 中的单目运算符 <code>+</code>，底层实现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">TARGET(UNARY_POSITIVE) &#123;</span><br><span class="line">    PyObject *value = TOP();</span><br><span class="line">    PyObject *res = PyNumber_Positive(value);</span><br><span class="line">    Py_DECREF(value);</span><br><span class="line">    SET_TOP(res);</span><br><span class="line">    <span class="keyword">if</span> (res == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">goto</span> error;</span><br><span class="line">    DISPATCH();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先获取值栈栈顶的值 <code>value</code>，然后将其作为参数调用 <code>PyNumber_Positive</code> 函数，这个函数在 Objects/abstract.c 中定义，来看其实现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">PyObject *</span><br><span class="line">PyNumber_Positive(PyObject *o)</span><br><span class="line">&#123;</span><br><span class="line">    PyNumberMethods *m;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (o == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> null_error();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    m = o-&gt;ob_type-&gt;tp_as_number;</span><br><span class="line">    <span class="keyword">if</span> (m &amp;&amp; m-&gt;nb_positive)</span><br><span class="line">        <span class="keyword">return</span> (*m-&gt;nb_positive)(o);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> type_error(<span class="string">"bad operand type for unary +: '%.200s'"</span>, o);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数的返回值是 <code>PyObject *</code> 类型。函数开头定义了一个 <code>PyNumberMethods *</code> 类型的变量，<code>PyNumberMethods</code> 是定义 Python 数字协议的结构体。定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    binaryfunc nb_add;</span><br><span class="line">    binaryfunc nb_subtract;</span><br><span class="line">    binaryfunc nb_multiply;</span><br><span class="line">    binaryfunc nb_remainder;</span><br><span class="line">    binaryfunc nb_divmod;</span><br><span class="line">    ternaryfunc nb_power;</span><br><span class="line">    unaryfunc nb_negative;</span><br><span class="line">    unaryfunc nb_positive;</span><br><span class="line">    unaryfunc nb_absolute;</span><br><span class="line">    inquiry nb_bool;</span><br><span class="line">    unaryfunc nb_invert;</span><br><span class="line">    binaryfunc nb_lshift;</span><br><span class="line">    binaryfunc nb_rshift;</span><br><span class="line">    binaryfunc nb_and;</span><br><span class="line">    binaryfunc nb_xor;</span><br><span class="line">    binaryfunc nb_or;</span><br><span class="line">    unaryfunc nb_int;</span><br><span class="line">    <span class="keyword">void</span> *nb_reserved;  <span class="comment">/* the slot formerly known as nb_long */</span></span><br><span class="line">    unaryfunc nb_float;</span><br><span class="line"></span><br><span class="line">    binaryfunc nb_inplace_add;</span><br><span class="line">    binaryfunc nb_inplace_subtract;</span><br><span class="line">    binaryfunc nb_inplace_multiply;</span><br><span class="line">    binaryfunc nb_inplace_remainder;</span><br><span class="line">    ternaryfunc nb_inplace_power;</span><br><span class="line">    binaryfunc nb_inplace_lshift;</span><br><span class="line">    binaryfunc nb_inplace_rshift;</span><br><span class="line">    binaryfunc nb_inplace_and;</span><br><span class="line">    binaryfunc nb_inplace_xor;</span><br><span class="line">    binaryfunc nb_inplace_or;</span><br><span class="line"></span><br><span class="line">    binaryfunc nb_floor_divide;</span><br><span class="line">    binaryfunc nb_true_divide;</span><br><span class="line">    binaryfunc nb_inplace_floor_divide;</span><br><span class="line">    binaryfunc nb_inplace_true_divide;</span><br><span class="line"></span><br><span class="line">    unaryfunc nb_index;</span><br><span class="line"></span><br><span class="line">    binaryfunc nb_matrix_multiply;</span><br><span class="line">    binaryfunc nb_inplace_matrix_multiply;</span><br><span class="line">&#125; PyNumberMethods;</span><br></pre></td></tr></table></figure><p>几乎所有字段都是函数指针，从字段的名称就可以看出它们分别对应哪些函数。这里面我们只关心 <code>nb_positive</code>，类型定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> PyObject * (*unaryfunc)(PyObject *);</span><br></pre></td></tr></table></figure><p>函数往下执行，如果参数 <code>o</code> 为 <code>NULL</code>，会调用函数 <code>null_error</code> 并返回：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> PyObject *</span><br><span class="line">null_error(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!PyErr_Occurred())</span><br><span class="line">        PyErr_SetString(PyExc_SystemError,</span><br><span class="line">                        <span class="string">"null argument to internal routine"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果没有引发异常则设置为 <code>SystemError</code> 然后返回 <code>NULL</code>。</p><p>参数 <code>o</code> 不为 <code>NULL</code>，获取它的 <code>ob_type</code> 字段的 <code>tp_as_number</code> 字段的值，也就是指向 <code>PyNumberMethods</code> 的指针，如果 <code>m</code> 不为 <code>NULL</code> 且 <code>nb_positive</code> 不为 <code>NULL</code>，则将 <code>o</code> 做为参数调用 <code>nb_positive</code> 指向的函数并将结果返回。否则说明对象 <code>o</code> 不支持单目运算符 <code>+</code>，于是返回设置 <code>TypeError</code> 并返回 <code>NULL</code>，也就是 <code>type_error</code> 函数的工作：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> PyObject *</span><br><span class="line">type_error(<span class="keyword">const</span> <span class="keyword">char</span> *msg, PyObject *obj)</span><br><span class="line">&#123;</span><br><span class="line">    PyErr_Format(PyExc_TypeError, msg, obj-&gt;ob_type-&gt;tp_name);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>PyNumber_Positive</code> 执行的结果由 <code>res</code> 接收，之后需要将 <code>value</code> 的引用计数减一，将 <code>res</code> 设置为值栈栈顶的值（相当于弹出 <code>value</code> 压入 <code>res</code>），如果 <code>res</code> 为 <code>NULL</code>，跳转到错误处理，否则执行下一个操作码。</p><p>在 Python 中，对一个不支持单目运算符 <code>+</code> 操作的对象如列表使用确实会引发 <code>TypeError</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>+[]</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">TypeError: bad operand type <span class="keyword">for</span> unary +: <span class="string">'list'</span></span><br></pre></td></tr></table></figure><p>而在一个 <code>int</code> 型数字前加上 <code>+</code> 号会返回数字本身，如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="number">5</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>+a</span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="number">-5</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>+a</span><br><span class="line"><span class="number">-5</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dis.dis(<span class="string">'a = -5;+a'</span>)</span><br><span class="line">  <span class="number">1</span>           <span class="number">0</span> LOAD_CONST               <span class="number">0</span> (<span class="number">-5</span>)</span><br><span class="line">              <span class="number">2</span> STORE_NAME               <span class="number">0</span> (a)</span><br><span class="line">              <span class="number">4</span> LOAD_NAME                <span class="number">0</span> (a)</span><br><span class="line">              <span class="number">6</span> UNARY_POSITIVE</span><br><span class="line">              <span class="number">8</span> POP_TOP</span><br><span class="line">             <span class="number">10</span> LOAD_CONST               <span class="number">1</span> (<span class="literal">None</span>)</span><br><span class="line">             <span class="number">12</span> RETURN_VALUE</span><br></pre></td></tr></table></figure><p>简单跟踪这段字节码里 <code>UNARY_POSITIVE</code> 的执行，根据上面的分析，这个操作码先获取值栈栈顶的值，在这里是-5，然后以-5作为参数调用 <code>PyNumber_Positive</code>。执行流到了 <code>PyNumber_Positive</code> 函数，-5 是 <code>int</code> 对象，所以 <code>o-&gt;ob_type</code> 是 <code>PyLong_Type</code>，来看看它的定义，位于 Objects/longobject.c 文件。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">PyTypeObject PyLong_Type = &#123;</span><br><span class="line">    PyVarObject_HEAD_INIT(&amp;PyType_Type, <span class="number">0</span>)</span><br><span class="line">    <span class="string">"int"</span>,                                      <span class="comment">/* tp_name */</span></span><br><span class="line">    offsetof(PyLongObject, ob_digit),           <span class="comment">/* tp_basicsize */</span></span><br><span class="line">    <span class="keyword">sizeof</span>(digit),                              <span class="comment">/* tp_itemsize */</span></span><br><span class="line">    long_dealloc,                               <span class="comment">/* tp_dealloc */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_print */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_getattr */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_setattr */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_reserved */</span></span><br><span class="line">    long_to_decimal_string,                     <span class="comment">/* tp_repr */</span></span><br><span class="line">    &amp;long_as_number,                            <span class="comment">/* tp_as_number */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_as_sequence */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_as_mapping */</span></span><br><span class="line">    (hashfunc)long_hash,                        <span class="comment">/* tp_hash */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_call */</span></span><br><span class="line">    long_to_decimal_string,                     <span class="comment">/* tp_str */</span></span><br><span class="line">    PyObject_GenericGetAttr,                    <span class="comment">/* tp_getattro */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_setattro */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_as_buffer */</span></span><br><span class="line">    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE |</span><br><span class="line">        Py_TPFLAGS_LONG_SUBCLASS,               <span class="comment">/* tp_flags */</span></span><br><span class="line">    long_doc,                                   <span class="comment">/* tp_doc */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_traverse */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_clear */</span></span><br><span class="line">    long_richcompare,                           <span class="comment">/* tp_richcompare */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_weaklistoffset */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_iter */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_iternext */</span></span><br><span class="line">    long_methods,                               <span class="comment">/* tp_methods */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_members */</span></span><br><span class="line">    long_getset,                                <span class="comment">/* tp_getset */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_base */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_dict */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_descr_get */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_descr_set */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_dictoffset */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_init */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_alloc */</span></span><br><span class="line">    long_new,                                   <span class="comment">/* tp_new */</span></span><br><span class="line">    PyObject_Del,                               <span class="comment">/* tp_free */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>有点长，注意 <code>tp_as_number</code> 字段位置的值 <code>long_as_number</code>，它的定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> PyNumberMethods long_as_number = &#123;</span><br><span class="line">    (binaryfunc)long_add,       <span class="comment">/*nb_add*/</span></span><br><span class="line">    (binaryfunc)long_sub,       <span class="comment">/*nb_subtract*/</span></span><br><span class="line">    (binaryfunc)long_mul,       <span class="comment">/*nb_multiply*/</span></span><br><span class="line">    long_mod,                   <span class="comment">/*nb_remainder*/</span></span><br><span class="line">    long_divmod,                <span class="comment">/*nb_divmod*/</span></span><br><span class="line">    long_pow,                   <span class="comment">/*nb_power*/</span></span><br><span class="line">    (unaryfunc)long_neg,        <span class="comment">/*nb_negative*/</span></span><br><span class="line">    (unaryfunc)long_long,       <span class="comment">/*tp_positive*/</span></span><br><span class="line">    (unaryfunc)long_abs,        <span class="comment">/*tp_absolute*/</span></span><br><span class="line">    (inquiry)long_bool,         <span class="comment">/*tp_bool*/</span></span><br><span class="line">    (unaryfunc)long_invert,     <span class="comment">/*nb_invert*/</span></span><br><span class="line">    long_lshift,                <span class="comment">/*nb_lshift*/</span></span><br><span class="line">    (binaryfunc)long_rshift,    <span class="comment">/*nb_rshift*/</span></span><br><span class="line">    long_and,                   <span class="comment">/*nb_and*/</span></span><br><span class="line">    long_xor,                   <span class="comment">/*nb_xor*/</span></span><br><span class="line">    long_or,                    <span class="comment">/*nb_or*/</span></span><br><span class="line">    long_long,                  <span class="comment">/*nb_int*/</span></span><br><span class="line">    <span class="number">0</span>,                          <span class="comment">/*nb_reserved*/</span></span><br><span class="line">    long_float,                 <span class="comment">/*nb_float*/</span></span><br><span class="line">    <span class="number">0</span>,                          <span class="comment">/* nb_inplace_add */</span></span><br><span class="line">    <span class="number">0</span>,                          <span class="comment">/* nb_inplace_subtract */</span></span><br><span class="line">    <span class="number">0</span>,                          <span class="comment">/* nb_inplace_multiply */</span></span><br><span class="line">    <span class="number">0</span>,                          <span class="comment">/* nb_inplace_remainder */</span></span><br><span class="line">    <span class="number">0</span>,                          <span class="comment">/* nb_inplace_power */</span></span><br><span class="line">    <span class="number">0</span>,                          <span class="comment">/* nb_inplace_lshift */</span></span><br><span class="line">    <span class="number">0</span>,                          <span class="comment">/* nb_inplace_rshift */</span></span><br><span class="line">    <span class="number">0</span>,                          <span class="comment">/* nb_inplace_and */</span></span><br><span class="line">    <span class="number">0</span>,                          <span class="comment">/* nb_inplace_xor */</span></span><br><span class="line">    <span class="number">0</span>,                          <span class="comment">/* nb_inplace_or */</span></span><br><span class="line">    long_div,                   <span class="comment">/* nb_floor_divide */</span></span><br><span class="line">    long_true_divide,           <span class="comment">/* nb_true_divide */</span></span><br><span class="line">    <span class="number">0</span>,                          <span class="comment">/* nb_inplace_floor_divide */</span></span><br><span class="line">    <span class="number">0</span>,                          <span class="comment">/* nb_inplace_true_divide */</span></span><br><span class="line">    long_long,                  <span class="comment">/* nb_index */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>找到 <code>nb_positive</code> 字段位置的值 <code>(unaryfunc)long_long</code>，真正完成工作的就是这个函数，来看看其定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> PyObject *</span><br><span class="line">long_long(PyObject *v)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (PyLong_CheckExact(v))</span><br><span class="line">        Py_INCREF(v);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        v = _PyLong_Copy((PyLongObject *)v);</span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>逻辑非常简单，如果参数 <code>v</code> 是 <code>int</code> 对象（不是子类），增加其引用计数，否则将其转换成 <code>int</code> 对象，这一步由 <code>_PyLong_Copy</code> 完成，最后将 <code>v</code> 返回。好，追踪到此结束。</p><p>上面说到如果是一个非 <code>int</code> 对象会被转换成一个 <code>int</code> 对象，来看一个简单的示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>type(<span class="literal">True</span>).__mro__  <span class="comment"># bool类是int的子类</span></span><br><span class="line">(&lt;class 'bool'&gt;, &lt;class 'int'&gt;, &lt;class 'object'&gt;)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>+<span class="literal">True</span>   <span class="comment"># 被转换成了1</span></span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python操作码——DUP_TOP_TWO</title>
      <link href="/python/python-opcode-DUP_TOP_TWO.html"/>
      <url>/python/python-opcode-DUP_TOP_TWO.html</url>
      
        <content type="html"><![CDATA[<p><code>DUP_TOP_TWO</code> 的编号是5，是一个不带参数的操作码。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>dis.opmap[<span class="string">'DUP_TOP_TWO'</span>]</span><br><span class="line"><span class="number">5</span></span><br></pre></td></tr></table></figure><a id="more"></a><p>底层实现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">TARGET(DUP_TOP_TWO) &#123;</span><br><span class="line">    PyObject *top = TOP();</span><br><span class="line">    PyObject *second = SECOND();</span><br><span class="line">    Py_INCREF(top);</span><br><span class="line">    Py_INCREF(second);</span><br><span class="line">    STACKADJ(<span class="number">2</span>);</span><br><span class="line">    SET_TOP(top);</span><br><span class="line">    SET_SECOND(second);</span><br><span class="line">    FAST_DISPATCH();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先获取值栈顶部的两个元素，然后分别增加它们的引用计数。然后调整 <code>stack_pointer</code> 指向的地址，<code>STACKADJ</code> 定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TOP()                   (stack_pointer[-1])</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SECOND()                (stack_pointer[-2])</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STACKADJ(n)             BASIC_STACKADJ(n)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BASIC_STACKADJ(n)       (stack_pointer += n)</span></span><br></pre></td></tr></table></figure><p>因为解释器已经提前计算好了执行一段代码块所需的值栈的大小并分配了足够的内存，所以调整后 <code>stack_pointer</code> 不会越界。接着为腾出的两个位置设置相应的值。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SET_TOP(v) (stack_pointer[-1] = (v))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SET_SECOND(v) (stack_pointer[-2] = (v))</span></span><br></pre></td></tr></table></figure><p>图解：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">|            |                      |            |                      |            |</span></span><br><span class="line"><span class="comment">+------------+                      +------------+                      +------------+           </span></span><br><span class="line"><span class="comment">|            |    stack_pointer -&gt;  |            |    stack_pointer -&gt;  |            |</span></span><br><span class="line"><span class="comment">+------------+                      +------------+                      +------------+</span></span><br><span class="line"><span class="comment">|            |                      |            |                      |    top     |</span></span><br><span class="line"><span class="comment">+------------+                      +------------+                      +------------+</span></span><br><span class="line"><span class="comment">|            |  &lt;- stack_pointer    |            |                      |   second   |</span></span><br><span class="line"><span class="comment">+------------+                      +------------+                      +------------+</span></span><br><span class="line"><span class="comment">|    top     |                      |    top     |                      |    top     |</span></span><br><span class="line"><span class="comment">+------------+     STACKADJ(2)      +------------+      SET_*           +------------+</span></span><br><span class="line"><span class="comment">|   second   |     ===========&gt;     |   second   |     =======&gt;         |   second   |</span></span><br><span class="line"><span class="comment">+------------+                      +------------+                      +------------+</span></span><br><span class="line"><span class="comment">|    ...     |                      |    ...     |                      |    ...     |</span></span><br><span class="line"><span class="comment">+------------+                      +------------+                      +------------+</span></span><br><span class="line"><span class="comment">| PyObject * | &lt;- f_valuestack -&gt;   | PyObject * |     f_valuestack -&gt;  | PyObject * |</span></span><br><span class="line"><span class="comment">+------------+                      +------------+                      +------------+</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python操作码——DUP_TOP</title>
      <link href="/python/python-opcode-DUP_TOP.html"/>
      <url>/python/python-opcode-DUP_TOP.html</url>
      
        <content type="html"><![CDATA[<p><code>DUP_TOP</code> 操作码的编号是4， 是一个不带参数的操作码。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>dis.opmap[<span class="string">'DUP_TOP'</span>]</span><br><span class="line"><span class="number">4</span></span><br></pre></td></tr></table></figure><a id="more"></a><p>底层实现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">TARGET(DUP_TOP) &#123;</span><br><span class="line">    PyObject *top = TOP();</span><br><span class="line">    Py_INCREF(top);</span><br><span class="line">    PUSH(top);</span><br><span class="line">    FAST_DISPATCH();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先获取值栈栈顶的值，增加其引用计数，再将其压入值栈中。图解：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">|            |          +---------&gt; |            |</span></span><br><span class="line"><span class="comment">+------------+          |           +------------+</span></span><br><span class="line"><span class="comment">|            |  &lt;- stack_pointer    |    top     |</span></span><br><span class="line"><span class="comment">+------------+                      +------------+</span></span><br><span class="line"><span class="comment">|    top     |                      |    top     |  </span></span><br><span class="line"><span class="comment">+------------+   ==DUP_TOP===&gt;      +------------+</span></span><br><span class="line"><span class="comment">|    ...     |                      |    ...     |</span></span><br><span class="line"><span class="comment">+------------+                      +------------+</span></span><br><span class="line"><span class="comment">| PyObject * | &lt;- f_valuestack -&gt;   | PyObject * |</span></span><br><span class="line"><span class="comment">+------------+                      +------------+</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>来看两条不同的语句：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>dis.dis(<span class="string">'a = b = []'</span>)   <span class="comment"># 1.</span></span><br><span class="line">  <span class="number">1</span>           <span class="number">0</span> BUILD_LIST               <span class="number">0</span></span><br><span class="line">              <span class="number">2</span> DUP_TOP</span><br><span class="line">              <span class="number">4</span> STORE_NAME               <span class="number">0</span> (a)</span><br><span class="line">              <span class="number">6</span> STORE_NAME               <span class="number">1</span> (b)</span><br><span class="line">              <span class="number">8</span> LOAD_CONST               <span class="number">0</span> (<span class="literal">None</span>)</span><br><span class="line">             <span class="number">10</span> RETURN_VALUE</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>            </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dis.dis(<span class="string">'a = []; b = []'</span>)   <span class="comment"># 2.</span></span><br><span class="line">  <span class="number">1</span>           <span class="number">0</span> BUILD_LIST               <span class="number">0</span></span><br><span class="line">              <span class="number">2</span> STORE_NAME               <span class="number">0</span> (a)</span><br><span class="line">              <span class="number">4</span> BUILD_LIST               <span class="number">0</span></span><br><span class="line">              <span class="number">6</span> STORE_NAME               <span class="number">1</span> (b)</span><br><span class="line">              <span class="number">8</span> LOAD_CONST               <span class="number">0</span> (<span class="literal">None</span>)</span><br><span class="line">             <span class="number">10</span> RETURN_VALUE</span><br></pre></td></tr></table></figure><p><code>BUILD_LIST</code> 是使用<code>[]</code>创建列表时使用的操作码（注意，<code>list()</code> 使用的是 <code>CALL_FUNCTION</code>，<code>[]</code> 的效率比 <code>list()</code> 高），它会将创建好的列表压入值栈中。注意，第一个语句使用了 <code>DUP_TOP</code> 操作码，此时 <code>a</code> 和 <code>b</code> 指向了同一个对象，改变列表 <code>a</code> 的内容 <code>b</code> 也会跟着改变：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = b = []</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.append(<span class="number">1</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line">[<span class="number">1</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b</span><br><span class="line">[<span class="number">1</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>id(a) == id(b)</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure><p>第二个语句分别创建了两个列表，再分配给 <code>a</code> 和 <code>b</code>，此时 <code>a</code> 和 <code>b</code> 是两个不同的列表（分别指向两个不同的地址，列表的值还是相同的），改变列表 <code>a</code> 的内容不会影响到列表 <code>b</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = []; b = []</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.append(<span class="number">1</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line">[<span class="number">1</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b</span><br><span class="line">[]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>id(a) == id(b)</span><br><span class="line"><span class="literal">False</span></span><br></pre></td></tr></table></figure><p>所以在需要两个不同的列表时不要图省事直接写类似 <code>a = b = []</code> 这样的代码。</p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python操作码——ROT_THREE</title>
      <link href="/python/python-opcode-ROT_THREE.html"/>
      <url>/python/python-opcode-ROT_THREE.html</url>
      
        <content type="html"><![CDATA[<p><code>ROT_THREE</code> 的编号是3，是一个不带参数的操作码。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>dis.opmap[<span class="string">'ROT_THREE'</span>]</span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure><a id="more"></a><p>实现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">TARGET(ROT_THREE) &#123;</span><br><span class="line">    PyObject *top = TOP();</span><br><span class="line">    PyObject *second = SECOND();</span><br><span class="line">    PyObject *third = THIRD();</span><br><span class="line">    SET_TOP(second);</span><br><span class="line">    SET_SECOND(third);</span><br><span class="line">    SET_THIRD(top);</span><br><span class="line">    FAST_DISPATCH();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看过 <code>ROT_TWO</code> 分析的话就不难理解了，几个宏：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TOP() (stack_pointer[-1])</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SECOND() (stack_pointer[-2])</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> THIRD() (stack_pointer[-3])</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SET_TOP(v) (stack_pointer[-1] = (v))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SET_SECOND(v) (stack_pointer[-2] = (v))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SET_THIRD(v) (stack_pointer[-3] = (v))</span></span><br></pre></td></tr></table></figure><p>图解：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">|            |                      |            |</span></span><br><span class="line"><span class="comment">+------------+                      +------------+</span></span><br><span class="line"><span class="comment">|            |  &lt;- stack_pointer -&gt; |            |</span></span><br><span class="line"><span class="comment">+------------+                      +------------+</span></span><br><span class="line"><span class="comment">|    top     |                      |   second   |  </span></span><br><span class="line"><span class="comment">+------------+      ROT_THREE       +------------+</span></span><br><span class="line"><span class="comment">|   second   |     ===========&gt;     |   third    |</span></span><br><span class="line"><span class="comment">+------------+                      +------------+</span></span><br><span class="line"><span class="comment">|   third    |                      |    top     |     </span></span><br><span class="line"><span class="comment">+------------+                      +------------+</span></span><br><span class="line"><span class="comment">|    ...     |                      |    ...     |</span></span><br><span class="line"><span class="comment">+------------+                      +------------+</span></span><br><span class="line"><span class="comment">| PyObject * | &lt;- f_valuestack -&gt;   | PyObject * |</span></span><br><span class="line"><span class="comment">+------------+                      +------------+</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python操作码——ROT_TWO</title>
      <link href="/python/python-opcode-ROT_TWO.html"/>
      <url>/python/python-opcode-ROT_TWO.html</url>
      
        <content type="html"><![CDATA[<p>操作码 <code>ROT_TWO</code> 的编码是2，是一个不带参数的操作码。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>dis.opmap[<span class="string">'ROT_TWO'</span>]</span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure><a id="more"></a><p>实现较为简单：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">TARGET(ROT_TWO) &#123;</span><br><span class="line">    PyObject *top = TOP();</span><br><span class="line">    PyObject *second = SECOND();</span><br><span class="line">    SET_TOP(second);</span><br><span class="line">    SET_SECOND(top);</span><br><span class="line">    FAST_DISPATCH();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先获取值栈最顶部的两个元素，由宏 <code>TOP</code> 和 <code>SECOND</code> 完成，这两个宏的定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TOP() (stack_pointer[-1])</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SECOND() (stack_pointer[-2])</span></span><br></pre></td></tr></table></figure><p>值栈不为空时，<code>stack_pointer</code> 永远指向值栈的下一个空闲槽，<code>stack_pointer[-1]</code> 取的就是栈顶的元素，依次类推。</p><p>接下来，互换 <code>second</code> 和 <code>top</code> 在值栈中的位置，宏 <code>SET_TOP</code> 和 <code>SET_SECOND</code> 的定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SET_TOP(v) (stack_pointer[-1] = (v))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SET_SECOND(v) (stack_pointer[-2] = (v))</span></span><br></pre></td></tr></table></figure><p>简单的赋值操作。以上就是这个操作码的内容，用一幅图表示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">|            |                      |            |</span></span><br><span class="line"><span class="comment">+------------+                      +------------+</span></span><br><span class="line"><span class="comment">|            |  &lt;- stack_pointer -&gt; |            |</span></span><br><span class="line"><span class="comment">+------------+                      +------------+</span></span><br><span class="line"><span class="comment">|    top     |                      |   second   |  </span></span><br><span class="line"><span class="comment">+------------+        ROT_TWO       +------------+</span></span><br><span class="line"><span class="comment">|   second   |     ===========&gt;     |    top     |</span></span><br><span class="line"><span class="comment">+------------+                      +------------+</span></span><br><span class="line"><span class="comment">|    ...     |                      |    ...     |</span></span><br><span class="line"><span class="comment">+------------+                      +------------+</span></span><br><span class="line"><span class="comment">| PyObject * | &lt;- f_valuestack -&gt;   | PyObject * |</span></span><br><span class="line"><span class="comment">+------------+                      +------------+</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>在一些讲解优化 Python 代码的文章中，常常会看到建议使用 <code>a, b = b, a</code> 交换两个变量 <code>a</code> 和 <code>b</code> 的值，而不是引入临时变量 <code>t</code>。先来看 a<code>, b = b, a</code> 这样的语句生成的 AST 树：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> ast</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(ast.dump(ast.parse(<span class="string">'a, b = b, a'</span>))) <span class="comment"># 这里对输出进行了简单的换行处理，方便查看</span></span><br><span class="line">Module(</span><br><span class="line">    body=[</span><br><span class="line">        Assign(</span><br><span class="line">            targets=[</span><br><span class="line">                Tuple(</span><br><span class="line">                    elts=[</span><br><span class="line">                        Name(id=<span class="string">'a'</span>, ctx=Store()), </span><br><span class="line">                        Name(id=<span class="string">'b'</span>, ctx=Store())</span><br><span class="line">                    ], </span><br><span class="line">                    ctx=Store()</span><br><span class="line">                )</span><br><span class="line">            ], </span><br><span class="line">            value=Tuple(</span><br><span class="line">                elts=[</span><br><span class="line">                    Name(id=<span class="string">'b'</span>, ctx=Load()), </span><br><span class="line">                    Name(id=<span class="string">'a'</span>, ctx=Load())</span><br><span class="line">                ], </span><br><span class="line">                ctx=Load()</span><br><span class="line">            )</span><br><span class="line">        )</span><br><span class="line">    ]</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>一个 <code>Assgin</code> 节点，表示赋值。属性 <code>targets</code> 表示赋值符号左侧，一个 <code>Tuple</code> 节点，属性 <code>value</code> 表示赋值符号的右侧，也是一个 <code>Tuple</code> 节点。这样看起来执行语句的时候会先创建了元组 <code>(b, a)</code>，然后再进行解包赋值，这个开销可是比引入临时变量还要大的。那么 <code>a, b = b, a</code> 为什么会比 <code>t = a; a = b; b = t</code> 快呢，来看看字节码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>dis.dis(<span class="string">'a, b = b, a'</span>)</span><br><span class="line">  <span class="number">1</span>           <span class="number">0</span> LOAD_NAME                <span class="number">0</span> (b)</span><br><span class="line">              <span class="number">2</span> LOAD_NAME                <span class="number">1</span> (a)</span><br><span class="line">              <span class="number">4</span> ROT_TWO</span><br><span class="line">              <span class="number">6</span> STORE_NAME               <span class="number">1</span> (a)</span><br><span class="line">              <span class="number">8</span> STORE_NAME               <span class="number">0</span> (b)</span><br><span class="line">             <span class="number">10</span> LOAD_CONST               <span class="number">0</span> (<span class="literal">None</span>)</span><br><span class="line">             <span class="number">12</span> RETURN_VALUE</span><br></pre></td></tr></table></figure><p>使用了 <code>ROT_TWO</code>！先将变量 <code>b</code> 的值压入值栈，再压入变量 <code>a</code> 的值。接着调换它们在值栈中的位置，再保存到 <code>a</code> 和 <code>b</code> 中。过程：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">      压入</span></span><br><span class="line"><span class="comment">    +------ b</span></span><br><span class="line"><span class="comment">    |</span></span><br><span class="line"><span class="comment">    V               </span></span><br><span class="line"><span class="comment">|       |   ===&gt;    |   b   |</span></span><br><span class="line"><span class="comment">+-------+           +-------+</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">==================================</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">      压入</span></span><br><span class="line"><span class="comment">    +------ a</span></span><br><span class="line"><span class="comment">    |</span></span><br><span class="line"><span class="comment">    V</span></span><br><span class="line"><span class="comment">|       |           |   a   |</span></span><br><span class="line"><span class="comment">+-------+   ===&gt;    +-------+</span></span><br><span class="line"><span class="comment">|   b   |           |   b   |</span></span><br><span class="line"><span class="comment">+-------+           +-------+</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">==================================</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">交换</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">|   b   |</span></span><br><span class="line"><span class="comment">+-------+   </span></span><br><span class="line"><span class="comment">|   a   |           </span></span><br><span class="line"><span class="comment">+-------+       </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">==================================</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">      弹出</span></span><br><span class="line"><span class="comment">    +-----&gt; a</span></span><br><span class="line"><span class="comment">    |</span></span><br><span class="line"><span class="comment">    V</span></span><br><span class="line"><span class="comment">|   b   |</span></span><br><span class="line"><span class="comment">+-------+   </span></span><br><span class="line"><span class="comment">|   a   |           </span></span><br><span class="line"><span class="comment">+-------+</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">==================================</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">      弹出</span></span><br><span class="line"><span class="comment">    +-----&gt; b</span></span><br><span class="line"><span class="comment">    |</span></span><br><span class="line"><span class="comment">    V  </span></span><br><span class="line"><span class="comment">|   a   |           </span></span><br><span class="line"><span class="comment">+-------+</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>和引入临时变量相比，少了一次 <code>LOAD_*</code> 和 <code>STORE_*</code> ：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>dis.dis(<span class="string">'t = a; a = b; b = t'</span>)</span><br><span class="line">  <span class="number">1</span>           <span class="number">0</span> LOAD_NAME                <span class="number">0</span> (a)</span><br><span class="line">              <span class="number">2</span> STORE_NAME               <span class="number">1</span> (t)</span><br><span class="line">              <span class="number">4</span> LOAD_NAME                <span class="number">2</span> (b)</span><br><span class="line">              <span class="number">6</span> STORE_NAME               <span class="number">0</span> (a)</span><br><span class="line">              <span class="number">8</span> LOAD_NAME                <span class="number">1</span> (t)</span><br><span class="line">             <span class="number">10</span> STORE_NAME               <span class="number">2</span> (b)</span><br><span class="line">             <span class="number">12</span> LOAD_CONST               <span class="number">0</span> (<span class="literal">None</span>)</span><br><span class="line">             <span class="number">14</span> RETURN_VALUE</span><br></pre></td></tr></table></figure><blockquote><p>在函数中使用时，<code>LOAD_NAME</code>和 <code>STORE_NAME</code> 会变成 <code>LOAD_FAST</code> 和 <code>STORE_FAST</code>，后两者是前两者的优化版本。</p></blockquote><p>那么本应该涉及元组的操作怎么会变成这样呢？答案是 Python 底层在最终生成字节码前会进行一些优化，将诸如 <code>a, = b,</code>，<code>a, b = b, a</code>，<code>a, b, c = c, a, b</code> 这样的语句生成的字节码优化，像 <code>a, b, c, d = d, c, b, a</code> 这样的语句就不会优化了，这会创建一个元组再进行解包（<code>BUILD_TUPLE</code>、<code>UNPACK_SEQUENCE</code>）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>dis.dis(<span class="string">'a, b, c, d = d, c, b, a'</span>)</span><br><span class="line">  <span class="number">1</span>           <span class="number">0</span> LOAD_NAME                <span class="number">0</span> (d)</span><br><span class="line">              <span class="number">2</span> LOAD_NAME                <span class="number">1</span> (c)</span><br><span class="line">              <span class="number">4</span> LOAD_NAME                <span class="number">2</span> (b)</span><br><span class="line">              <span class="number">6</span> LOAD_NAME                <span class="number">3</span> (a)</span><br><span class="line">              <span class="number">8</span> BUILD_TUPLE              <span class="number">4</span></span><br><span class="line">             <span class="number">10</span> UNPACK_SEQUENCE          <span class="number">4</span></span><br><span class="line">             <span class="number">12</span> STORE_NAME               <span class="number">3</span> (a)</span><br><span class="line">             <span class="number">14</span> STORE_NAME               <span class="number">2</span> (b)</span><br><span class="line">             <span class="number">16</span> STORE_NAME               <span class="number">1</span> (c)</span><br><span class="line">             <span class="number">18</span> STORE_NAME               <span class="number">0</span> (d)</span><br><span class="line">             <span class="number">20</span> LOAD_CONST               <span class="number">0</span> (<span class="literal">None</span>)</span><br><span class="line">             <span class="number">22</span> RETURN_VALUE</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python操作码——POP_TOP</title>
      <link href="/python/python-opcode-POP_TOP.html"/>
      <url>/python/python-opcode-POP_TOP.html</url>
      
        <content type="html"><![CDATA[<p><code>POP_TOP</code> 操作码的编号是1，是个不带参数的操作码。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>dis.opmap[<span class="string">'POP_TOP'</span>]</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><a id="more"></a><p>这个操作码的作用是弹出值栈栈顶的值，实现非常简单：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">TARGET(POP_TOP) &#123;</span><br><span class="line">    PyObject *value = POP();</span><br><span class="line">    Py_DECREF(value);</span><br><span class="line">    FAST_DISPATCH();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先弹出值栈栈顶的值，然后减少其引用计数。</p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python操作码——STORE_NAME</title>
      <link href="/python/python-opcode-STORE_NAME.html"/>
      <url>/python/python-opcode-STORE_NAME.html</url>
      
        <content type="html"><![CDATA[<p><code>STORE_NANE</code>操作码的编号是90，是一个带参数的操作码。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>dis.opmap[<span class="string">'STORE_NAME'</span>]</span><br><span class="line"><span class="number">90</span></span><br></pre></td></tr></table></figure><a id="more"></a><p>这个操作码的作用是将变量名和对应的值保存在局部变量字典中，来看实现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">TARGET(STORE_NAME) &#123;</span><br><span class="line">    PyObject *name = GETITEM(names, oparg);</span><br><span class="line">    PyObject *v = POP();</span><br><span class="line">    PyObject *ns = f-&gt;f_locals;</span><br><span class="line">    <span class="keyword">int</span> err;</span><br><span class="line">    <span class="keyword">if</span> (ns == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        PyErr_Format(PyExc_SystemError,</span><br><span class="line">                        <span class="string">"no locals found when storing %R"</span>, name);</span><br><span class="line">        Py_DECREF(v);</span><br><span class="line">        <span class="keyword">goto</span> error;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (PyDict_CheckExact(ns))</span><br><span class="line">        err = PyDict_SetItem(ns, name, v);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        err = PyObject_SetItem(ns, name, v);</span><br><span class="line">    Py_DECREF(v);</span><br><span class="line">    <span class="keyword">if</span> (err != <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">goto</span> error;</span><br><span class="line">    DISPATCH();</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>首先根据操作码的参数 <code>oparg</code> 在 <code>names</code> 中获取变量的字符串表示 <code>name</code>，接着弹出值栈栈顶的元素 <code>v</code>，然后定义一个 <code>PyObject *</code> 的值 <code>ns</code> 指向帧对象的 <code>f_locals</code> 字段。如果 <code>ns</code> 为 <code>NULL</code>，说明局部命名空间不存在，需要引发一个 <code>SystemError</code>，减少 <code>v</code> 的引用计数，然后跳转到错误处理。</p><p>往下执行，说明<code>ns</code> 确实存在，首先需要检查 <code>ns</code> 是否是一个 <code>dict</code> 对象，由 <code>PyDict_CheckExact</code> 完成。如果是则调用 <code>PyDict_SetItem</code> 为字典 <code>ns</code> 添加键为 <code>name</code> 值为 <code>v</code> 的值，如果 <code>ns</code> 是其它映射对象，则调用 <code>PyObject_SetItem</code> 为 <code>ns</code> 设置键值对。之后减少 <code>v</code> 的引用计数。两个函数在成功都会返回0，所以最后需要检查返回值是否为0，如果不是，则需要跳转到错误处理部分。</p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python操作码——LOAD_NAME</title>
      <link href="/python/python-opcode-LOAD_NAME.html"/>
      <url>/python/python-opcode-LOAD_NAME.html</url>
      
        <content type="html"><![CDATA[<p><code>LOAD_NAME</code> 操作码的编号为101，是一个带参数的操作码。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>dis.opmap[<span class="string">'LOAD_NAME'</span>]</span><br><span class="line"><span class="number">101</span></span><br></pre></td></tr></table></figure><a id="more"></a><p>该操作码的作用是将变量名对应的值压入值栈中，实现如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">TARGET(LOAD_NAME) &#123;</span><br><span class="line">    PyObject *name = GETITEM(names, oparg);</span><br><span class="line">    PyObject *locals = f-&gt;f_locals;</span><br><span class="line">    PyObject *v;</span><br><span class="line">    <span class="keyword">if</span> (locals == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        PyErr_Format(PyExc_SystemError,</span><br><span class="line">                        <span class="string">"no locals when loading %R"</span>, name);</span><br><span class="line">        <span class="keyword">goto</span> error;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (PyDict_CheckExact(locals)) &#123;</span><br><span class="line">        v = PyDict_GetItem(locals, name);</span><br><span class="line">        Py_XINCREF(v);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        v = PyObject_GetItem(locals, name);</span><br><span class="line">        <span class="keyword">if</span> (v == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!PyErr_ExceptionMatches(PyExc_KeyError))</span><br><span class="line">                <span class="keyword">goto</span> error;</span><br><span class="line">            PyErr_Clear();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (v == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        v = PyDict_GetItem(f-&gt;f_globals, name);</span><br><span class="line">        Py_XINCREF(v);</span><br><span class="line">        <span class="keyword">if</span> (v == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (PyDict_CheckExact(f-&gt;f_builtins)) &#123;</span><br><span class="line">                v = PyDict_GetItem(f-&gt;f_builtins, name);</span><br><span class="line">                <span class="keyword">if</span> (v == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                    format_exc_check_arg(</span><br><span class="line">                                PyExc_NameError,</span><br><span class="line">                                NAME_ERROR_MSG, name);</span><br><span class="line">                    <span class="keyword">goto</span> error;</span><br><span class="line">                &#125;</span><br><span class="line">                Py_INCREF(v);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                v = PyObject_GetItem(f-&gt;f_builtins, name);</span><br><span class="line">                <span class="keyword">if</span> (v == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (PyErr_ExceptionMatches(PyExc_KeyError))</span><br><span class="line">                        format_exc_check_arg(</span><br><span class="line">                                    PyExc_NameError,</span><br><span class="line">                                    NAME_ERROR_MSG, name);</span><br><span class="line">                    <span class="keyword">goto</span> error;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    PUSH(v);</span><br><span class="line">    DISPATCH();</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>首先根据操作码的参数 <code>oparg</code> 从 <code>names</code> 元组中获取变量名的字符串表示，<code>names</code> 指向代码对象的 <code>co_names</code> 字段。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PyObject *names;</span><br><span class="line">names = co-&gt;co_names;</span><br></pre></td></tr></table></figure><p>接着获取帧对象的 <code>f_locals</code> 也就是局部命名空间的值，如果值不存在，则表示没有局部命名空间，所以会引发一个 <code>SystemError</code>，此时需要跳转到错误处理的代码块。往下，<code>PyDict_CheckExact</code> 是一个宏，检查 <code>locals</code> 是否是一个 <code>dict</code> 对象。注意，只有 <code>locals</code> 是 <code>dict</code> 对象而不是其子类时才返回true。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#define PyDict_CheckExact(op) (Py_TYPE(op) == &amp;PyDict_Type)</span><br></pre></td></tr></table></figure><p>如果条件为真，调用 <code>PyDict_GetItem</code> 从 <code>locals</code> 字典中获取键为 <code>name</code> 的值，即 <code>locals[name]</code>，并增加其引用计数，<code>Py_XINCREF</code> 在增加引用计数前会检查参数是否为 <code>NULL</code>。条件为假则调用 <code>PyObject_GetItem</code>，这个函数的行为也类似于 <code>locals[name]</code>，不过 <code>locals</code> 可以是任意 Python 对象。在获取不到值时，会返回 <code>NULL</code> 并设置相应的异常。往下看，当 <code>v</code> 为 <code>NULL</code>，也就是引发了异常时，会调用<code>PyErr_ExceptionMatches</code> 对 <code>PyObject_GetItem</code> 设置的异常进行匹配，如果不是 <code>KeyError</code>，则直接跳到错误处理部分；而如果是 <code>KeyError</code>，则调用 <code>PyErr_Clear</code> 把异常清掉。</p><p>稍微解释一下这里为什么会这么写，在帧对象中有3个字段 <code>f_builtins</code>、<code>f_globals</code>、<code>f_locals</code>，分别表示内置符号表、全局符号表和局部符号表，前两个必须是 Python 的 <code>dict</code> 对象，而最后一个可以是任意的映射对象，包括 <code>dict</code>。所以要取 <code>f_locals</code> 中的值的时候，会先判断它是否是 <code>dict</code> 对象，如果是，则直接调用 <code>PyDict_GetItem</code>。而如果是其它映射对象，则调用 <code>PyObject_GetItem</code>，这个函数所做的工作比 <code>PyDict_GetItem</code> 复杂，效率比较低。</p><p>往下，如果 <code>v</code> 为 <code>NULL</code>，也就是说 <code>f_locals</code> 中没有找到变量，那么就到 <code>f_globals</code> 中去找。也就是 <code>v = PyDict_GetItem(f-&gt;f_globals, name)</code> 这行的工作。如果还是没找到，则继续去 <code>f_builtins</code> 中找。</p><p>注意，在 <code>f_builtins</code> 中查找的时候，会先检查 <code>f_builtins</code> 是否是 <code>dict</code> 对象，如果是，则调用 <code>PyDict_GetItem</code> 获取值，如果找到了，增加其引用计数。而如果值为 <code>NULL</code>，后面已经没有命名空间了，所以需要引发一个 <code>NameError</code> 异常。<code>NAME_ERROR_MSG</code> 定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NAME_ERROR_MSG <span class="meta-string">"name '%.200s' is not defined"</span></span></span><br></pre></td></tr></table></figure><p>如果 <code>f_builtins</code> 不是一个字典对象，会调用 <code>PyObject_GetItem</code> 获取值，如果值为 <code>NULL</code>，则先对 <code>PyObject_GetItem</code> 设置的异常进行匹配，如果是 <code>KeyError</code>，则引发一个 <code>NameError</code> 异常，否则直接跳转到错误处理。注意在这个分支里没有增加 <code>v</code> 的引用计数。</p><p>走到最后，确实找到了值 <code>v</code>，则将其压入值栈中供后面的操作码使用。</p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python操作码——LOAD_FAST</title>
      <link href="/python/python-opcode-LOAD_FAST.html"/>
      <url>/python/python-opcode-LOAD_FAST.html</url>
      
        <content type="html"><![CDATA[<p><code>LOAD_FAST</code> 操作码的编号为124，是带参数的操作码。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>dis.opmap[<span class="string">'LOAD_FAST'</span>]</span><br><span class="line"><span class="number">124</span></span><br></pre></td></tr></table></figure><a id="more"></a><p>底层实现为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">TARGET(LOAD_FAST) &#123;</span><br><span class="line">    PyObject *value = GETLOCAL(oparg);</span><br><span class="line">    <span class="keyword">if</span> (value == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        format_exc_check_arg(PyExc_UnboundLocalError,</span><br><span class="line">                             UNBOUNDLOCAL_ERROR_MSG,</span><br><span class="line">                             PyTuple_GetItem(co-&gt;co_varnames, oparg));</span><br><span class="line">        <span class="keyword">goto</span> error;</span><br><span class="line">    &#125;</span><br><span class="line">    Py_INCREF(value);</span><br><span class="line">    PUSH(value);</span><br><span class="line">    FAST_DISPATCH();</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>首先根据 <code>oparg</code> 从 <code>fastlocals</code> 数组中获取对应的值，如果值不存在，则会引发 <code>UnboundLocalError</code> 异常，并跳转到错误处理。先来看看传递给 <code>format_exc_check_arg</code> 函数的几个参数，<code>PyExc_UnboundLocalError</code>，对应 Python 中的 <code>UnboundLocalError</code> 异常。<code>UNBOUNDLOCAL_ERROR_MSG</code>，一个宏：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> UNBOUNDLOCAL_ERROR_MSG \</span></span><br><span class="line">    <span class="string">"local variable '%.200s' referenced before assignment"</span></span><br></pre></td></tr></table></figure><p>最后 <code>co_varnames</code> 是代码对象的一个字段——一个保存变量的字符串表示的元组。</p><p>考虑如下代码，变量 <code>a</code> 未进行赋值就用于增强赋值（+=）操作：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">()</span>:</span></span><br><span class="line"><span class="meta">... </span>    a += <span class="number">1</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> a</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>调用函数 <code>f</code> 就会引发 <code>UnboundLocalError</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>f()</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">2</span>, <span class="keyword">in</span> f</span><br><span class="line">UnboundLocalError: local variable <span class="string">'a'</span> referenced before assignment</span><br></pre></td></tr></table></figure><p>再来看 <code>format_exc_check_arg</code> 的定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">format_exc_check_arg(PyObject *exc, <span class="keyword">const</span> <span class="keyword">char</span> *format_str, PyObject *obj)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *obj_str;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!obj)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    obj_str = PyUnicode_AsUTF8(obj);</span><br><span class="line">    <span class="keyword">if</span> (!obj_str)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    PyErr_Format(exc, format_str, obj_str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先定义一个 <code>const char *</code> 类型的变量，然后检查 <code>obj</code> 是否为空，为 <code>NULL</code> 就直接返回。接着将 <code>PyObject *</code> 类型的 <code>obj</code> 转换为 <code>const char *</code> 类型，也就是 <code>PyUnicode_AsUTF8</code> 所做的工作。最后调用 <code>PyErr_Format</code> 设置异常信息。</p><p>回到操作码的执行。往下走，即 <code>value</code> 不为 <code>NULL</code>，此时需要增加 <code>value</code> 的引用计数，由 <code>Py_INCREF</code> 完成。然后，将 <code>value</code> 压入值栈中，供后面的操作码使用。</p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python操作码——STORE_FAST</title>
      <link href="/python/python-opcode-STORE_FAST.html"/>
      <url>/python/python-opcode-STORE_FAST.html</url>
      
        <content type="html"><![CDATA[<p><code>STORE_FAST</code> 操作码的编号是125，需要一个参数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>dis.opmap[<span class="string">'STORE_FAST'</span>]</span><br><span class="line"><span class="number">125</span></span><br></pre></td></tr></table></figure><a id="more"></a><p>来看看底层实现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">PREDICTED(STORE_FAST);</span><br><span class="line">TARGET(STORE_FAST) &#123;</span><br><span class="line">    PyObject *value = POP();</span><br><span class="line">    SETLOCAL(oparg, value);</span><br><span class="line">    FAST_DISPATCH();</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>可以看到非常简单，<code>PREDICTED</code>，跟操作码预测相关，不展开。<code>TARGET(STORE_FAST)</code>，简单地当做是 <code>case STORE_FAST:</code>。直接看花括号里的内容，<code>POP</code> 是一个宏，取值栈栈顶的元素：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BASIC_POP   (*--stack_pointer)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> POP()       BASIC_POP()</span></span><br></pre></td></tr></table></figure><p>这里的弹出操作与一般栈的弹出操作有点出入，<code>stack_pointer</code> 本来指向值栈的下一个空闲槽，这里只是简单将指针减1，于是取到了栈顶的元素，但是这个宏并没有将元素从栈中删去，值还保留在栈中。如果下一条指令是诸如 <code>LOAD_*</code> 的指令，则会直接将值覆盖。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">|            | &lt;- stack_pointer</span></span><br><span class="line"><span class="comment">+------------+</span></span><br><span class="line"><span class="comment">| PyObject * | &lt;- 栈顶</span></span><br><span class="line"><span class="comment">+------------+</span></span><br><span class="line"><span class="comment">| ...        |</span></span><br><span class="line"><span class="comment">+------------|</span></span><br><span class="line"><span class="comment">| PyObject * | </span></span><br><span class="line"><span class="comment">+------------+</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p><code>POP</code> 取出值后，下一条语句 <code>SETLOCAL</code>，也是一个宏：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SETLOCAL(i, v)     do &#123; PyObject *tmp = GETLOCAL(i); \</span></span><br><span class="line">                                GETLOCAL(i) = value; \</span><br><span class="line">                                PyXDECREF(tmp); &#125; <span class="keyword">while</span> (<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GETLOCAL(i)         (fastlocals[i])</span></span><br></pre></td></tr></table></figure><p>先来解释 <code>GETLOCAL</code>，<code>fastlocals</code> 是对帧对象的 <code>f_localsplus</code> 的引用，是一个 <code>PyObject *</code> 类型的数组。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fastlocals = f-&gt;f_localsplus;   <span class="comment">/* f是帧对象 */</span></span><br></pre></td></tr></table></figure><p><code>SETLOCAL</code> 首先获取数组中索引为 <code>oparg</code> 的旧值，其中 <code>oparg</code> 是操作码的参数。然后设置新值，再之后需要检查旧值的引用计数，<code>PyXDECREF</code> 是 <code>Py_DECREF</code> 的拓展版本，会先检查传入的参数是否为空，再调用 <code>Py_DECREF</code>。设置好值后，下一条语句 <code>FAST_DISPATCH</code>，跳到<code>fast_next_opcode</code> 执行下一条操作码。</p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python操作码——LOAD_CONST</title>
      <link href="/python/python-opcode-LOAD_CONST.html"/>
      <url>/python/python-opcode-LOAD_CONST.html</url>
      
        <content type="html"><![CDATA[<p><code>LOAD_CONST</code> 操作码编号为100，是带参数的操作码。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>dis.opmap[<span class="string">'LOAD_CONST'</span>]</span><br><span class="line"><span class="number">100</span></span><br></pre></td></tr></table></figure><a id="more"></a><p>在 Python 底层中实现如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">PREDICTED(LOAD_CONST);</span><br><span class="line">TARGET(LOAD_CONST) &#123;</span><br><span class="line">    PyObject *value = GETITEM(consts, oparg);</span><br><span class="line">    Py_INCREF(value);</span><br><span class="line">    PUSH(value);</span><br><span class="line">    FAST_DISPATCH();</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p><code>PREDICTED</code> 是用于操作码预测的宏：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PREDICTED(op) PRED_##op:</span></span><br></pre></td></tr></table></figure><p>展开为 <code>PRED_LOAD_CONST:</code>，操作码预测这里不讨论。接下来是 <code>TARGET</code> 宏：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TARGET(op) case op:</span></span><br></pre></td></tr></table></figure><p>Python 中的每个操作码都是一个 <code>switch</code> 语句的 <code>case</code> 分支。来看 <code>case</code> 里的内容，<code>GETITEM</code> 是一个宏：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GETITEM(v,i) PyTuple_GetItem((v), (i))</span></span><br></pre></td></tr></table></figure><p>其实就是元组的下标索引操作，相当于 <code>consts[oparg]</code> ，这里 <code>consts</code> 是一个元组，<code>oparg</code> 则是 <code>LOAD_CONST</code> 操作码的参数。<code>consts</code> 元组引用代码对象的 <code>co_consts</code> 字段，这个字段的值在创建代码对象时设置。在代码对象中用到的常量都会保存在这个元组里，这样就可以在常数时间获取到常量。取到的值都以 <code>PyObject *</code> 的形式操作。接下来是 <code>Py_INCREF</code>，增加值的引用计数，没啥好说的。再到 <code>PUSH</code>，操作值栈的宏：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">PyObject **stack_pointer;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BASIC_PUSH(v)   (*stack_pointer++ = (v))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PUSH(v)     BASIC_PUSH(v)</span></span><br></pre></td></tr></table></figure><p><code>stack_pointer</code> 总是指向值栈的下一个空闲槽，类似这样：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">|            | &lt;- stack_pointer</span></span><br><span class="line"><span class="comment">+------------+</span></span><br><span class="line"><span class="comment">| PyObject * |</span></span><br><span class="line"><span class="comment">+------------+</span></span><br><span class="line"><span class="comment">| ...        |</span></span><br><span class="line"><span class="comment">+------------+</span></span><br><span class="line"><span class="comment">| PyObject * |</span></span><br><span class="line"><span class="comment">+------------+</span></span><br><span class="line"><span class="comment">| PyObject * | &lt;- f_valuestack</span></span><br><span class="line"><span class="comment">+------------+</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>所以 <code>PUSH</code> 的操作就是将值压入值栈中，再将 <code>stack_pointer</code> 指针指向下一个空闲槽。最后是 <code>FAST_DISPATH</code>，也是一个宏：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FAST_DISPATCH() goto fast_next_opcode</span></span><br></pre></td></tr></table></figure><p>跳转到 <code>fast_next_opcode</code>，不检查 GIL 直接获取下一个操作码执行。</p><p>以上就是 <code>LOAD_CONST</code> 操作码的全部内容，最后来看看它对应的 Python 代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">()</span>:</span></span><br><span class="line"><span class="meta">... </span>    a = <span class="number">11</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p><code>a = 11</code>，一个简单的赋值语句，这里用函数包装起来可以方便查看它的代码对象的属性。用 <code>dis</code> 模块进行反汇编：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>dis.dis(f)</span><br><span class="line">  <span class="number">2</span>           <span class="number">0</span> LOAD_CONST               <span class="number">1</span> (<span class="number">11</span>)</span><br><span class="line">              <span class="number">2</span> STORE_FAST               <span class="number">0</span> (a)</span><br><span class="line">              <span class="number">4</span> LOAD_CONST               <span class="number">0</span> (<span class="literal">None</span>)</span><br><span class="line">              <span class="number">6</span> RETURN_VALUE</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f.__code__.co_consts</span><br><span class="line">(<span class="literal">None</span>, <span class="number">11</span>)</span><br></pre></td></tr></table></figure><p>可以看到，第一条操作码就是 <code>LOAD_CONST</code>，参数是1，将常量11加载到值栈上，然后是 <code>STORE_FAST</code>，将值11与变量 <code>a</code> 关联。最后两条操作码在函数没有显式返回值的情况下必定会出现。记住，Python 的函数必定有返回值：未显式给出返回值将返回 <code>None</code>。</p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一个格式化ast.dump返回值的函数</title>
      <link href="/python/a-function-to-format-ast-node.html"/>
      <url>/python/a-function-to-format-ast-node.html</url>
      
        <content type="html"><![CDATA[<p><code>ast.dump()</code> 函数可用于打印 Python 的 AST 节点，他接受一个 <code>ast.AST</code>类的实例，并返回节点树的字符串表示。要得到一个 <code>ast.AST</code>类的实例，可以使用 <code>ast.parse()</code> 函数，这个函数是内建函数 <code>compile()</code> 的简单包装：</p><a id="more"></a><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">parse</span><span class="params">(source, filename=<span class="string">'&lt;unknown&gt;'</span>, mode=<span class="string">'exec'</span>)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> compile(source, filename, mode, PyCF_ONLY_AST)</span><br></pre></td></tr></table></figure><p>使用起来很简单，下面定义一个函数，并打印出它的 AST 节点表示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> ast</span><br><span class="line"></span><br><span class="line">code = (</span><br><span class="line">    <span class="string">"def fs(a, b=0, *, c=2, **kwargs):\n"</span></span><br><span class="line">    <span class="string">"    res = a + b + c\n"</span></span><br><span class="line">    <span class="string">"    print(res)\n"</span></span><br><span class="line">    <span class="string">"    print(kwargs)"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">tree = ast.parse(code)</span><br><span class="line">print(ast.dump(tree))</span><br></pre></td></tr></table></figure><p>结果是：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Module(body=[FunctionDef(name=<span class="string">'fs'</span>, args=arguments(args=[arg(arg=<span class="string">'a'</span>, annotation=<span class="literal">None</span>), arg(arg=<span class="string">'b'</span>, annotation=<span class="literal">None</span>)], vararg=<span class="literal">None</span>, kwonlyargs=[arg(arg=<span class="string">'c'</span>, annotation=<span class="literal">None</span>)], kw_defaults=[Num(n=<span class="number">2</span>)], kwarg=arg(arg=<span class="string">'kwargs'</span>, annotation=<span class="literal">None</span>), defaults=[Num(n=<span class="number">0</span>)]), body=[Assign(targets=[Name(id=<span class="string">'res'</span>, ctx=Store())], value=BinOp(left=BinOp(left=Name(id=<span class="string">'a'</span>, ctx=Load()), op=Add(), right=Name(id=<span class="string">'b'</span>, ctx=Load())), op=Add(), right=Name(id=<span class="string">'c'</span>, ctx=Load()))), Expr(value=Call(func=Name(id=<span class="string">'print'</span>, ctx=Load()), args=[Name(id=<span class="string">'res'</span>, ctx=Load())], keywords=[])), Expr(value=Call(func=Name(id=<span class="string">'print'</span>, ctx=Load()), args=[Name(id=<span class="string">'kwargs'</span>, ctx=Load())], keywords=[]))], decorator_list=[], returns=<span class="literal">None</span>)])</span><br></pre></td></tr></table></figure><p>结果没有换行，对阅读一点也不友好。使用 Python 标准库的 <code>pprint</code> 打印效果也不是很理想：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pprint <span class="keyword">import</span> pprint</span><br><span class="line"></span><br><span class="line">pprint(ast.dump(tree))</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">(<span class="string">"Module(body=[FunctionDef(name='fs', args=arguments(args=[arg(arg='a', "</span></span><br><span class="line"> <span class="string">"annotation=None), arg(arg='b', annotation=None)], vararg=None, "</span></span><br><span class="line"> <span class="string">"kwonlyargs=[arg(arg='c', annotation=None)], kw_defaults=[Num(n=2)], "</span></span><br><span class="line"> <span class="string">"kwarg=arg(arg='kwargs', annotation=None), defaults=[Num(n=0)]), "</span></span><br><span class="line"> <span class="string">"body=[Assign(targets=[Name(id='res', ctx=Store())], "</span></span><br><span class="line"> <span class="string">"value=BinOp(left=BinOp(left=Name(id='a', ctx=Load()), op=Add(), "</span></span><br><span class="line"> <span class="string">"right=Name(id='b', ctx=Load())), op=Add(), right=Name(id='c', ctx=Load()))), "</span></span><br><span class="line"> <span class="string">"Expr(value=Call(func=Name(id='print', ctx=Load()), args=[Name(id='res', "</span></span><br><span class="line"> <span class="string">"ctx=Load())], keywords=[])), Expr(value=Call(func=Name(id='print', "</span></span><br><span class="line"> <span class="string">"ctx=Load()), args=[Name(id='kwargs', ctx=Load())], keywords=[]))], "</span></span><br><span class="line"> <span class="string">'decorator_list=[], returns=None)])'</span>)</span><br></pre></td></tr></table></figure><p>还是自己来写一个吧！直接上代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">format_</span><span class="params">(string, symbol, indent)</span>:</span></span><br><span class="line">    level = <span class="number">0</span></span><br><span class="line">    sep = symbol * indent</span><br><span class="line">    <span class="keyword">for</span> i, s <span class="keyword">in</span> enumerate(string):</span><br><span class="line">        <span class="keyword">if</span> s <span class="keyword">in</span> &#123;<span class="string">'('</span>, <span class="string">'['</span>&#125;:</span><br><span class="line">            <span class="keyword">yield</span> s</span><br><span class="line">            <span class="keyword">if</span> string[i + <span class="number">1</span>] <span class="keyword">not</span> <span class="keyword">in</span> &#123;<span class="string">')'</span>, <span class="string">']'</span>&#125;:</span><br><span class="line">                level += <span class="number">1</span></span><br><span class="line">                <span class="keyword">yield</span> (<span class="string">'\n'</span> + sep * level)</span><br><span class="line">        <span class="keyword">elif</span> s <span class="keyword">in</span> &#123;<span class="string">')'</span>, <span class="string">']'</span>&#125;:</span><br><span class="line">            <span class="keyword">if</span> string[i - <span class="number">1</span>] <span class="keyword">not</span> <span class="keyword">in</span> &#123;<span class="string">'('</span>, <span class="string">'['</span>&#125;:</span><br><span class="line">                level -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">yield</span> <span class="string">'\n'</span> + sep * level</span><br><span class="line">            <span class="keyword">yield</span> s</span><br><span class="line">        <span class="keyword">elif</span> s == <span class="string">','</span>:</span><br><span class="line">            <span class="keyword">yield</span> s + <span class="string">'\n'</span> + sep * level</span><br><span class="line">        <span class="keyword">elif</span> s == <span class="string">' '</span>:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">yield</span> s</span><br><span class="line">            </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">p_print</span><span class="params">(tree, symbol=<span class="string">' '</span>, indent=<span class="number">4</span>)</span>:</span></span><br><span class="line">    print(<span class="string">''</span>.join(format_(tree, symbol, indent)))</span><br></pre></td></tr></table></figure><p>代码很简单，来看看效果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line">Module(</span><br><span class="line">    body=[</span><br><span class="line">        FunctionDef(</span><br><span class="line">            name=<span class="string">'fs'</span>,</span><br><span class="line">            args=arguments(</span><br><span class="line">                args=[</span><br><span class="line">                    arg(</span><br><span class="line">                        arg=<span class="string">'a'</span>,</span><br><span class="line">                        annotation=<span class="literal">None</span></span><br><span class="line">                    ),</span><br><span class="line">                    arg(</span><br><span class="line">                        arg=<span class="string">'b'</span>,</span><br><span class="line">                        annotation=<span class="literal">None</span></span><br><span class="line">                    )</span><br><span class="line">                ],</span><br><span class="line">                vararg=<span class="literal">None</span>,</span><br><span class="line">                kwonlyargs=[</span><br><span class="line">                    arg(</span><br><span class="line">                        arg=<span class="string">'c'</span>,</span><br><span class="line">                        annotation=<span class="literal">None</span></span><br><span class="line">                    )</span><br><span class="line">                ],</span><br><span class="line">                kw_defaults=[</span><br><span class="line">                    Num(</span><br><span class="line">                        n=<span class="number">2</span></span><br><span class="line">                    )</span><br><span class="line">                ],</span><br><span class="line">                kwarg=arg(</span><br><span class="line">                    arg=<span class="string">'kwargs'</span>,</span><br><span class="line">                    annotation=<span class="literal">None</span></span><br><span class="line">                ),</span><br><span class="line">                defaults=[</span><br><span class="line">                    Num(</span><br><span class="line">                        n=<span class="number">0</span></span><br><span class="line">                    )</span><br><span class="line">                ]</span><br><span class="line">            ),</span><br><span class="line">            body=[</span><br><span class="line">                Assign(</span><br><span class="line">                    targets=[</span><br><span class="line">                        Name(</span><br><span class="line">                            id=<span class="string">'res'</span>,</span><br><span class="line">                            ctx=Store()</span><br><span class="line">                        )</span><br><span class="line">                    ],</span><br><span class="line">                    value=BinOp(</span><br><span class="line">                        left=BinOp(</span><br><span class="line">                            left=Name(</span><br><span class="line">                                id=<span class="string">'a'</span>,</span><br><span class="line">                                ctx=Load()</span><br><span class="line">                            ),</span><br><span class="line">                            op=Add(),</span><br><span class="line">                            right=Name(</span><br><span class="line">                                id=<span class="string">'b'</span>,</span><br><span class="line">                                ctx=Load()</span><br><span class="line">                            )</span><br><span class="line">                        ),</span><br><span class="line">                        op=Add(),</span><br><span class="line">                        right=Name(</span><br><span class="line">                            id=<span class="string">'c'</span>,</span><br><span class="line">                            ctx=Load()</span><br><span class="line">                        )</span><br><span class="line">                    )</span><br><span class="line">                ),</span><br><span class="line">                Expr(</span><br><span class="line">                    value=Call(</span><br><span class="line">                        func=Name(</span><br><span class="line">                            id=<span class="string">'print'</span>,</span><br><span class="line">                            ctx=Load()</span><br><span class="line">                        ),</span><br><span class="line">                        args=[</span><br><span class="line">                            Name(</span><br><span class="line">                                id=<span class="string">'res'</span>,</span><br><span class="line">                                ctx=Load()</span><br><span class="line">                            )</span><br><span class="line">                        ],</span><br><span class="line">                        keywords=[]</span><br><span class="line">                    )</span><br><span class="line">                ),</span><br><span class="line">                Expr(</span><br><span class="line">                    value=Call(</span><br><span class="line">                        func=Name(</span><br><span class="line">                            id=<span class="string">'print'</span>,</span><br><span class="line">                            ctx=Load()</span><br><span class="line">                        ),</span><br><span class="line">                        args=[</span><br><span class="line">                            Name(</span><br><span class="line">                                id=<span class="string">'kwargs'</span>,</span><br><span class="line">                                ctx=Load()</span><br><span class="line">                            )</span><br><span class="line">                        ],</span><br><span class="line">                        keywords=[]</span><br><span class="line">                    )</span><br><span class="line">                )</span><br><span class="line">            ],</span><br><span class="line">            decorator_list=[],</span><br><span class="line">            returns=<span class="literal">None</span></span><br><span class="line">        )</span><br><span class="line">    ]</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>虽然输出很长，但是层级明显，可以友好地阅读了。</p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pygame报libpng warning提示的解决方法</title>
      <link href="/python/pygame-libpng-warning.html"/>
      <url>/python/pygame-libpng-warning.html</url>
      
        <content type="html"><![CDATA[<p>最近在用 <code>pygame</code> 写小游戏时遇到一个问题，在加载 <code>.png</code> 图片的时候，控制台会一直输出 <code>libpng warning: iCCP: known incorrect sRGB profile</code>，虽然程序能跑起来但是看起来实在烦人，也影响调试。所以去搜索了相关问题，在<a href="https://blog.csdn.net/u010212648/article/details/82191419" target="_blank" rel="noopener">这篇博客</a>的评论下找到了解决办法。方法是使用 <code>PyQt5</code> 对图片进行转换。不过我自己尝试发现，直接使用 <code>pygame</code> 对图片进行转换也可以解决。</p><a id="more"></a><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> pygame</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">translate</span><span class="params">(path)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> file <span class="keyword">in</span> os.listdir(path):</span><br><span class="line">        <span class="keyword">if</span> file.endswith(<span class="string">'.png'</span>):</span><br><span class="line">            full_path = os.path.join(path, file)</span><br><span class="line">            image = pygame.image.load(full_path)</span><br><span class="line">            pygame.image.save(image, full_path)</span><br></pre></td></tr></table></figure><p>简单理解就是调用 <code>pygame.image.load()</code> 加载一遍给定路径中的图片再调用 <code>pygame.image.save()</code> 保存图片。假设图片存储在和这段程序同级的<code>images</code>目录下，调用 <code>translate(&#39;images/&#39;)</code> 就可以解决上述问题。</p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> pygame </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
