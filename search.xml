<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Python操作码——BINARY_OR</title>
      <link href="/python/python-opcode-BINARY_OR.html"/>
      <url>/python/python-opcode-BINARY_OR.html</url>
      
        <content type="html"><![CDATA[<p><code>BINARY_OR</code> 操作码的编号是66，是个不带参数的操作码。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>dis.opmap[<span class="string">'BINARY_OR'</span>]</span><br><span class="line"><span class="number">66</span></span><br></pre></td></tr></table></figure><a id="more"></a><p>这个操作码对应 Python 的双目运算符 <code>|</code>，一般用于位运算“或”操作，注意不是关键字 <code>or</code>。实现如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">TARGET(BINARY_OR) &#123;</span><br><span class="line">    PyObject *right = POP();</span><br><span class="line">    PyObject *left = TOP();</span><br><span class="line">    PyObject *res = PyNumber_Or(left, right);</span><br><span class="line">    Py_DECREF(left);</span><br><span class="line">    Py_DECREF(right);</span><br><span class="line">    SET_TOP(res);</span><br><span class="line">    <span class="keyword">if</span> (res == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">goto</span> error;</span><br><span class="line">    DISPATCH();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关键函数 <code>PyNumber_Or</code>，在 Objects/abstract.c 中定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BINARY_FUNC(func, op, op_name) \</span></span><br><span class="line">    PyObject * \</span><br><span class="line">    func(PyObject *v, PyObject *w) &#123; \</span><br><span class="line">        <span class="keyword">return</span> binary_op(v, w, NB_SLOT(op), op_name); \</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">BINARY_FUNC(PyNumber_Or, nb_or, <span class="string">"|"</span>)</span><br></pre></td></tr></table></figure><p>宏展开之后是：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NB_SLOT(x) offsetof(PyNumberMethods, x)</span></span><br><span class="line"></span><br><span class="line">PyObject *</span><br><span class="line">PyNumber_Or(PyObject *v, PyObject *w) &#123;</span><br><span class="line">    <span class="keyword">return</span> binary_op(v, w, offsetof(PyNumberMethods, nb_or), <span class="string">"|"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对 <code>binary_op</code> 的分析参考 <code>BINARY_MATRIX_MULTIPLY</code>。</p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python操作码——BINARY_XOR</title>
      <link href="/python/python-opcode-BINARY_XOR.html"/>
      <url>/python/python-opcode-BINARY_XOR.html</url>
      
        <content type="html"><![CDATA[<p><code>BINARY_XOR</code> 操作码的编号是65，是个不带参数的操作码。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>dis.opmap[<span class="string">'BINARY_XOR'</span>]</span><br><span class="line"><span class="number">65</span></span><br></pre></td></tr></table></figure><a id="more"></a><p>这个操作码对应 Python 的双目运算符 <code>^</code>，一般用于位运算“异或”操作。实现如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">TARGET(BINARY_XOR) &#123;</span><br><span class="line">    PyObject *right = POP();</span><br><span class="line">    PyObject *left = TOP();</span><br><span class="line">    PyObject *res = PyNumber_Xor(left, right);</span><br><span class="line">    Py_DECREF(left);</span><br><span class="line">    Py_DECREF(right);</span><br><span class="line">    SET_TOP(res);</span><br><span class="line">    <span class="keyword">if</span> (res == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">goto</span> error;</span><br><span class="line">    DISPATCH();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关键函数 <code>PyNumber_Xor</code>。在 Objects/abstract.c 中定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BINARY_FUNC(func, op, op_name) \</span></span><br><span class="line">    PyObject * \</span><br><span class="line">    func(PyObject *v, PyObject *w) &#123; \</span><br><span class="line">        <span class="keyword">return</span> binary_op(v, w, NB_SLOT(op), op_name); \</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">BINARY_FUNC(PyNumber_Xor, nb_xor, <span class="string">"^"</span>)</span><br></pre></td></tr></table></figure><p>宏展开之后是：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NB_SLOT(x) offsetof(PyNumberMethods, x)</span></span><br><span class="line"></span><br><span class="line">PyObject *</span><br><span class="line">PyNumber_Xor(PyObject *v, PyObject *w) &#123;</span><br><span class="line">    <span class="keyword">return</span> binary_op(v, w, offsetof(PyNumberMethods, nb_xor), <span class="string">"^"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对 <code>binary_op</code> 的分析参考 <code>BINARY_MATRIX_MULTIPLY</code>。</p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python操作码——BINARY_AND</title>
      <link href="/python/python-opcode-BINARY_AND.html"/>
      <url>/python/python-opcode-BINARY_AND.html</url>
      
        <content type="html"><![CDATA[<p><code>BINARY_AND</code> 操作码的编号是64，是个不带参数的操作码。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>dis.opmap[<span class="string">'BINARY_AND'</span>]</span><br><span class="line"><span class="number">64</span></span><br></pre></td></tr></table></figure><a id="more"></a><p>这个操作码对应 Python 的双目运算符 <code>&amp;</code>，一般用于位运算“与”操作，注意不是关键字 <code>and</code>。实现如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">TARGET(BINARY_AND) &#123;</span><br><span class="line">    PyObject *right = POP();</span><br><span class="line">    PyObject *left = TOP();</span><br><span class="line">    PyObject *res = PyNumber_And(left, right);</span><br><span class="line">    Py_DECREF(left);</span><br><span class="line">    Py_DECREF(right);</span><br><span class="line">    SET_TOP(res);</span><br><span class="line">    <span class="keyword">if</span> (res == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">goto</span> error;</span><br><span class="line">    DISPATCH();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直接来看关键的 <code>PyNumber_And</code> 函数吧。在 Objects/abstract.c 中定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BINARY_FUNC(func, op, op_name) \</span></span><br><span class="line">    PyObject * \</span><br><span class="line">    func(PyObject *v, PyObject *w) &#123; \</span><br><span class="line">        <span class="keyword">return</span> binary_op(v, w, NB_SLOT(op), op_name); \</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">BINARY_FUNC(PyNumber_And, nb_and, <span class="string">"&amp;"</span>)</span><br></pre></td></tr></table></figure><p>宏展开之后是：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NB_SLOT(x) offsetof(PyNumberMethods, x)</span></span><br><span class="line"></span><br><span class="line">PyObject *</span><br><span class="line">PyNumber_And(PyObject *v, PyObject *w) &#123;</span><br><span class="line">    <span class="keyword">return</span> binary_op(v, w, offsetof(PyNumberMethods, nb_and), <span class="string">"&amp;"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对 <code>binary_op</code> 的分析参考 <code>BINARY_MATRIX_MULTIPLY</code>。</p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python操作码——BINARY_RSHIFT</title>
      <link href="/python/python-opcode-BINARY_RSHIFT.html"/>
      <url>/python/python-opcode-BINARY_RSHIFT.html</url>
      
        <content type="html"><![CDATA[<p><code>BINARY_RSHIFT</code> 操作码的编号是63，是个不带参数的操作码。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>dis.opmap[<span class="string">'BINARY_RSHIFT'</span>]</span><br><span class="line"><span class="number">63</span></span><br></pre></td></tr></table></figure><a id="more"></a><p>这个操作码对应 Python 的双目运算符 <code>&gt;&gt;</code>，一般用于向右移位操作，实现如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">TARGET(BINARY_RSHIFT) &#123;</span><br><span class="line">    PyObject *right = POP();</span><br><span class="line">    PyObject *left = TOP();</span><br><span class="line">    PyObject *res = PyNumber_Rshift(left, right);</span><br><span class="line">    Py_DECREF(left);</span><br><span class="line">    Py_DECREF(right);</span><br><span class="line">    SET_TOP(res);</span><br><span class="line">    <span class="keyword">if</span> (res == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">goto</span> error;</span><br><span class="line">    DISPATCH();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>来看关键的 <code>PyNumber_Rshift</code> 函数，在 Objects/abstract.c 中定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BINARY_FUNC(func, op, op_name) \</span></span><br><span class="line">    PyObject * \</span><br><span class="line">    func(PyObject *v, PyObject *w) &#123; \</span><br><span class="line">        <span class="keyword">return</span> binary_op(v, w, NB_SLOT(op), op_name); \</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">BINARY_FUNC(PyNumber_Rshift, nb_rshift, <span class="string">"&gt;&gt;"</span>)</span><br></pre></td></tr></table></figure><p>宏展开之后是：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NB_SLOT(x) offsetof(PyNumberMethods, x)</span></span><br><span class="line"></span><br><span class="line">PyObject *</span><br><span class="line">PyNumber_Rshift(PyObject *v, PyObject *w) &#123;</span><br><span class="line">    <span class="keyword">return</span> binary_op(v, w, offsetof(PyNumberMethods, nb_rshift), <span class="string">"&gt;&gt;"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然已经在 <code>BINARY_MATRIX_MULTIPLY</code> 中分析过了 <code>binary_op</code>，但是这里还是要提一点，先来看这个函数的实现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> PyObject *</span><br><span class="line">binary_op(PyObject *v, PyObject *w, <span class="keyword">const</span> <span class="keyword">int</span> op_slot, <span class="keyword">const</span> <span class="keyword">char</span> *op_name)</span><br><span class="line">&#123;</span><br><span class="line">    PyObject *result = binary_op1(v, w, op_slot);</span><br><span class="line">    <span class="keyword">if</span> (result == Py_NotImplemented) &#123;</span><br><span class="line">        Py_DECREF(result);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (op_slot == NB_SLOT(nb_rshift) &amp;&amp;</span><br><span class="line">            PyCFunction_Check(v) &amp;&amp;</span><br><span class="line">            <span class="built_in">strcmp</span>(((PyCFunctionObject *)v)-&gt;m_ml-&gt;ml_name, <span class="string">"print"</span>) == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            PyErr_Format(PyExc_TypeError,</span><br><span class="line">                <span class="string">"unsupported operand type(s) for %.100s: "</span></span><br><span class="line">                <span class="string">"'%.100s' and '%.100s'. Did you mean \"print(&lt;message&gt;, "</span></span><br><span class="line">                <span class="string">"file=&lt;output_stream&gt;)\"?"</span>,</span><br><span class="line">                op_name,</span><br><span class="line">                v-&gt;ob_type-&gt;tp_name,</span><br><span class="line">                w-&gt;ob_type-&gt;tp_name);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> binop_type_error(v, w, op_name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>result == Py_NotImplemented</code> 的条件里，当运算符是 <code>&gt;&gt;</code> 且左操作数是 <code>print</code> 函数的时候，会设置一个特别的 <code>TypeError</code>，来看个示例：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> &gt;&gt; <span class="number">1</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">TypeError: unsupported operand type(s) for &gt;&gt;: 'builtin_function_or_method' and 'int'. Did you mean "print(&lt;message&gt;, file=&lt;output_stream&gt;)"?</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python操作码——BINARY_LSHIFT</title>
      <link href="/python/python-opcode-BINARY_LSHIFT.html"/>
      <url>/python/python-opcode-BINARY_LSHIFT.html</url>
      
        <content type="html"><![CDATA[<p><code>BINARY_LSHIFT</code> 操作码的编号是62，是个不带参数的操作码。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>dis.opmap[<span class="string">'BINARY_LSHIFT'</span>]</span><br><span class="line"><span class="number">62</span></span><br></pre></td></tr></table></figure><a id="more"></a><p>这个操作码对应 Python 的双目运算符 <code>&lt;&lt;</code>，一般用于向左移位操作，实现如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">TARGET(BINARY_LSHIFT) &#123;</span><br><span class="line">    PyObject *right = POP();</span><br><span class="line">    PyObject *left = TOP();</span><br><span class="line">    PyObject *res = PyNumber_Lshift(left, right);</span><br><span class="line">    Py_DECREF(left);</span><br><span class="line">    Py_DECREF(right);</span><br><span class="line">    SET_TOP(res);</span><br><span class="line">    <span class="keyword">if</span> (res == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">goto</span> error;</span><br><span class="line">    DISPATCH();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和其它二元运算符操作码的实现非常类似，关键在于 <code>PyNumber_Lshift</code>，这个函数在 Objects/abstract.c 中定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">BINARY_FUNC(PyNumber_Lshift, nb_lshift, <span class="string">"&lt;&lt;"</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BINARY_FUNC(func, op, op_name) \</span></span><br><span class="line">    PyObject * \</span><br><span class="line">    func(PyObject *v, PyObject *w) &#123; \</span><br><span class="line">        <span class="keyword">return</span> binary_op(v, w, NB_SLOT(op), op_name); \</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>宏展开后发现就是简单地调用了 <code>binary_op</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NB_SLOT(x) offsetof(PyNumberMethods, x)</span></span><br><span class="line"></span><br><span class="line">PyObject *</span><br><span class="line">PyNumber_Lshift(PyObject *v, PyObject *w) &#123;</span><br><span class="line">    <span class="keyword">return</span> binary_op(v, w, offsetof(PyNumberMethods, nb_lshift), <span class="string">"&lt;&lt;"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对 <code>binary_op</code> 的分析参考 <code>BINARY_MATRIX_MULTIPLY</code>。</p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python操作码——BINARY_SUBSCR</title>
      <link href="/python/python-opcode-BINARY_SUBSCR.html"/>
      <url>/python/python-opcode-BINARY_SUBSCR.html</url>
      
        <content type="html"><![CDATA[<p><code>BINARY_SUBSCR</code> 操作码的编号是25，是个不带参数的操作码。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>dis.opmap[<span class="string">'BINARY_SUBSCR'</span>]</span><br><span class="line"><span class="number">25</span></span><br></pre></td></tr></table></figure><a id="more"></a><p>这个操作码对应 Python 的下标运算 <code>[]</code>，左操作数一般是某个容器对象，右操作数则是方括号中的值。实现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">TARGET(BINARY_SUBSCR) &#123;</span><br><span class="line">    PyObject *sub = POP();</span><br><span class="line">    PyObject *container = TOP();</span><br><span class="line">    PyObject *res = PyObject_GetItem(container, sub);</span><br><span class="line">    Py_DECREF(container);</span><br><span class="line">    Py_DECREF(sub);</span><br><span class="line">    SET_TOP(res);</span><br><span class="line">    <span class="keyword">if</span> (res == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">goto</span> error;</span><br><span class="line">    DISPATCH();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和其它二元运算符很类似，不同之处在于 <code>PyObject_GetItem</code>，这个函数在 Objects/abstract.c 文件中定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">PyObject *</span><br><span class="line">PyObject_GetItem(PyObject *o, PyObject *key)</span><br><span class="line">&#123;</span><br><span class="line">    PyMappingMethods *m;</span><br><span class="line">    PySequenceMethods *ms;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (o == <span class="literal">NULL</span> || key == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> null_error();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    m = o-&gt;ob_type-&gt;tp_as_mapping;</span><br><span class="line">    <span class="keyword">if</span> (m &amp;&amp; m-&gt;mp_subscript) &#123;</span><br><span class="line">        PyObject *item = m-&gt;mp_subscript(o, key);</span><br><span class="line">        assert((item != <span class="literal">NULL</span>) ^ (PyErr_Occurred() != <span class="literal">NULL</span>));</span><br><span class="line">        <span class="keyword">return</span> item;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ms = o-&gt;ob_type-&gt;tp_as_sequence;</span><br><span class="line">    <span class="keyword">if</span> (ms &amp;&amp; ms-&gt;sq_item) &#123;</span><br><span class="line">        <span class="keyword">if</span> (PyIndex_Check(key)) &#123;</span><br><span class="line">            Py_ssize_t key_value;</span><br><span class="line">            key_value = PyNumber_AsSsize_t(key, PyExc_IndexError);</span><br><span class="line">            <span class="keyword">if</span> (key_value == <span class="number">-1</span> &amp;&amp; PyErr_Occurred())</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">            <span class="keyword">return</span> PySequence_GetItem(o, key_value);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> type_error(<span class="string">"sequence index must "</span></span><br><span class="line">                              <span class="string">"be integer, not '%.200s'"</span>, key);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (PyType_Check(o)) &#123;</span><br><span class="line">        PyObject *meth, *result, *<span class="built_in">stack</span>[<span class="number">1</span>] = &#123;key&#125;;</span><br><span class="line">        _Py_IDENTIFIER(__class_getitem__);</span><br><span class="line">        <span class="keyword">if</span> (_PyObject_LookupAttrId(o, &amp;PyId___class_getitem__, &amp;meth) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (meth) &#123;</span><br><span class="line">            result = _PyObject_FastCall(meth, <span class="built_in">stack</span>, <span class="number">1</span>);</span><br><span class="line">            Py_DECREF(meth);</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> type_error(<span class="string">"'%.200s' object is not subscriptable"</span>, o);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>PyMappingMethods</code> 和 <code>PySequenceMethods</code> 分别是定义映射协议和序列协议的结构体。往下，检查参数 <code>o</code> 和 <code>key</code> 的合法性，其中一个为 <code>NULL</code> 则调用 <code>null_error</code> 设置 <code>SystemError</code> 并返回 <code>NULL</code>。</p><p>接下来，获取 <code>o</code> 的 <code>ob_type</code> 的 <code>tp_as_mapping</code> 字段的值，如果 <code>m</code> 和 <code>m-&gt;mp_subscript</code> 的值不为 <code>NULL</code>，则调用 <code>mp_subscript</code> <code>指向的函数。然后，对调用的返回值进行判定，PyErr_Occurred</code> 在没有异常被设置时返回 <code>NULL</code>。注意这里用了异或运算，<code>item</code> 为 <code>NULL</code> 时表示有异常被设置，此时第一个条件为0，第二个条件为1，根据同零异一的原则，这里会返回 <code>NULL</code>（<code>item</code> 为 <code>NULL</code>）。<code>item</code> 不为 <code>NULL</code> 则表示取到了值，没有异常被设置，此时第一个条件为1，第二条件为0，返回取到的值 <code>item</code>。</p><p>往下，说明 <code>m</code> 或者 <code>m-&gt;mp_subscript</code> 的值为 <code>NULL</code>，则获取 <code>tp_as_sequence</code> 的值 <code>ms</code>。如果 <code>ms</code> 和 <code>ms-&gt;sq_item</code> 不为 <code>NULL</code>，检查参数 <code>key</code> 的是否实现了数字协议的 <code>nb_index</code> 槽：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PyIndex_Check(obj)                              \</span></span><br><span class="line">    ((obj)-&gt;ob_type-&gt;tp_as_number != <span class="literal">NULL</span> &amp;&amp;            \</span><br><span class="line">     (obj)-&gt;ob_type-&gt;tp_as_number-&gt;nb_index != <span class="literal">NULL</span>)</span><br></pre></td></tr></table></figure><p>如果条件为真，调用 <code>PyNumber_AsSsize_t</code> 将 <code>PyObject *</code> 类型的 <code>key</code> 转换为 <code>Py_ssize_t</code> <code>类型。sq_item</code> 指向的函数的签名是 <code>typedef PyObject *(*ssizeargfunc)(PyObject *, Py_ssize_t)</code>，看下面 <code>else</code> 子句就知道，序列索引值必须是整数。只要 <code>PyNumber_AsSsize_t</code> 没有发生异常，就会调用 <code>PySequence_GetItem</code>，这个函数同样在 Objects/abstract.c 中定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">PyObject *</span><br><span class="line">PySequence_GetItem(PyObject *s, Py_ssize_t i)</span><br><span class="line">&#123;</span><br><span class="line">    PySequenceMethods *m;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (s == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> null_error();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    m = s-&gt;ob_type-&gt;tp_as_sequence;</span><br><span class="line">    <span class="keyword">if</span> (m &amp;&amp; m-&gt;sq_item) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (m-&gt;sq_length) &#123;</span><br><span class="line">                Py_ssize_t l = (*m-&gt;sq_length)(s);</span><br><span class="line">                <span class="keyword">if</span> (l &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    assert(PyErr_Occurred());</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                i += l;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> m-&gt;sq_item(s, i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> type_error(<span class="string">"'%.200s' object does not support indexing"</span>, s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>忽略一些错误处理，可以看到，核心其实就是在处理索引值为负数的情况，索引值为负数时，会加上序列的长度，序列长度由 <code>sq_length</code> 指向的函数计算，之后再调用 <code>sq_item</code> 指向的函数取值。</p><p>回到 <code>PyObject_GetItem</code>，往下执行说明该对象可能没有实现映射协议或者序列协议对应的方法，或者协议方法没有返回期望的值。接着，使用 <code>PyType_Check</code> 宏检查参数 <code>o</code> 的类型是否是 <code>type</code> 的子类，宏定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PyType_Check(op) \</span></span><br><span class="line">    PyType_FastSubclass(Py_TYPE(op), Py_TPFLAGS_TYPE_SUBCLASS)</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Py_TYPE(ob)             (((PyObject*)(ob))-&gt;ob_type)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Py_TPFLAGS_TYPE_SUBCLASS        (1UL &lt;&lt; 31)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PyType_FastSubclass(t,f)  PyType_HasFeature(t,f)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PyType_HasFeature(t,f)  (((t)-&gt;tp_flags &amp; (f)) != 0)</span></span><br></pre></td></tr></table></figure><p>条件为真，进入 <code>if</code> 语句块，<code>_Py_IDENTIFIER</code> 是一个宏，用于初始化一个 <code>_Py_Identifier</code> 类型的静态变量：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _Py_IDENTIFIER(varname) _Py_static_string(PyId_##varname, #varname)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _Py_static_string_init(value) &#123; .next = NULL, .string = value, .object = NULL &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _Py_static_string(varname, value)  static _Py_Identifier varname = _Py_static_string_init(value)</span></span><br></pre></td></tr></table></figure><p>宏展开相当于：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> _Py_Identifier PyId___class_getitem__ = &#123; .next = <span class="literal">NULL</span>, .<span class="built_in">string</span> = <span class="string">"__class_getitem__"</span>, .object = <span class="literal">NULL</span> &#125;</span><br></pre></td></tr></table></figure><p><code>_Py_Identifier</code> 是一个结构体，在 Include/object.h 中声明，用于帮助管理静态字符串。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">Py_Identifier</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">Py_Identifier</span> *<span class="title">next</span>;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* <span class="built_in">string</span>;</span><br><span class="line">    PyObject *object;</span><br><span class="line">&#125; _Py_Identifier;</span><br></pre></td></tr></table></figure><p>由这个结构体管理的字符串会进行驻留操作，并且使用 <code>next</code> 字段连接在一起，只有在解释器关闭时才会进行释放。<code>__class_getitem__</code> 在 Python 中是一个魔法方法，也是一个类方法，用于模拟泛型类型。关于这个方法的详情参考 <a href="https://www.python.org/dev/peps/pep-0484" target="_blank" rel="noopener">PEP 484</a>。</p><p>接下来将调用位于 Objects/object.c 中的 <code>_PyObject_LookupAttrId</code> 函数进行属性查找，注意这里传入了 <code>meth</code> 的地址接收查找到的方法，如果函数返回值小于0，说明函数调用链中引生了异常，直接返回 <code>NULL</code>。否则，检查 <code>meth</code> 是否为 <code>NULL</code>，不为 <code>NULL</code> 则调用 <code>_PyObject_FastCall</code> 执行 <code>meth</code> 方法，最后减少 <code>meth</code> 的引用计数并将结果返回。</p><p>函数走到最后，说明对象不支持下标运算，调用 <code>type_error</code> 函数设置 <code>TypeError</code> 并返回 <code>NULL</code>。</p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python操作码——BINARY_SUBTRACT</title>
      <link href="/python/python-opcode-BINARY_SUBTRACT.html"/>
      <url>/python/python-opcode-BINARY_SUBTRACT.html</url>
      
        <content type="html"><![CDATA[<p><code>BINARY_SUBTRACT</code> 操作码的编号是24，是个不带参数的操作码。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>dis.opmap[<span class="string">'BINARY_SUBTRACT'</span>]</span><br><span class="line"><span class="number">24</span></span><br></pre></td></tr></table></figure><a id="more"></a><p>这个操作码对应 Python 中的双目运算符 <code>-</code>，实现如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">TARGET(BINARY_SUBTRACT) &#123;</span><br><span class="line">    PyObject *right = POP();</span><br><span class="line">    PyObject *left = TOP();</span><br><span class="line">    PyObject *diff = PyNumber_Subtract(left, right);</span><br><span class="line">    Py_DECREF(right);</span><br><span class="line">    Py_DECREF(left);</span><br><span class="line">    SET_TOP(diff);</span><br><span class="line">    <span class="keyword">if</span> (diff == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">goto</span> error;</span><br><span class="line">    DISPATCH();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个操作码与其它的二元运算操作码如 <code>BINARY_MULTIPLY</code> 的区别就是 <code>PyNumber_Subtract</code> 函数，来看这个函数，同样是在 Objects/abstract.c 中定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">BINARY_FUNC(PyNumber_Subtract, nb_subtract, <span class="string">"-"</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BINARY_FUNC(func, op, op_name) \</span></span><br><span class="line">    PyObject * \</span><br><span class="line">    func(PyObject *v, PyObject *w) &#123; \</span><br><span class="line">        <span class="keyword">return</span> binary_op(v, w, NB_SLOT(op), op_name); \</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>宏展开之后就变成了：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">PyObject *</span><br><span class="line">PyNumber_Subtract(PyObject *v, PyObject *w) &#123;</span><br><span class="line">    <span class="keyword">return</span> binary_op(v, w, NB_SLOT(nb_subtract), <span class="string">"-"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就是对 <code>binary_op</code> 函数的包装，这个函数已经在 <code>BINARY_MATRIX_MULTIPLY</code> 中分析过了，这里不再重复。<code>NB_SLOT(nb_subtract)</code> 求的是 <code>nb_subtract</code> 字段在 <code>PyNumberMethods</code> 结构体中的偏移量。</p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python操作码——BINARY_ADD</title>
      <link href="/python/python-opcode-BINARY_ADD.html"/>
      <url>/python/python-opcode-BINARY_ADD.html</url>
      
        <content type="html"><![CDATA[<p><code>BINARY_ADD</code> 操作码的编号是23，是个不带参数的操作码。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>dis.opmap[<span class="string">'BINARY_ADD'</span>]</span><br><span class="line"><span class="number">23</span></span><br></pre></td></tr></table></figure><a id="more"></a><p>这个操作码对应 Python 的双目运算符 <code>+</code>，实现如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">TARGET(BINARY_ADD) &#123;</span><br><span class="line">    PyObject *right = POP();</span><br><span class="line">    PyObject *left = TOP();</span><br><span class="line">    PyObject *sum;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (PyUnicode_CheckExact(left) &amp;&amp;</span><br><span class="line">                PyUnicode_CheckExact(right)) &#123;</span><br><span class="line">        sum = unicode_concatenate(left, right, f, next_instr);</span><br><span class="line">        <span class="comment">/* unicode_concatenate consumed the ref to left */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        sum = PyNumber_Add(left, right);</span><br><span class="line">        Py_DECREF(left);</span><br><span class="line">    &#125;</span><br><span class="line">    Py_DECREF(right);</span><br><span class="line">    SET_TOP(sum);</span><br><span class="line">    <span class="keyword">if</span> (sum == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">goto</span> error;</span><br><span class="line">    DISPATCH();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先从值栈中获取左右操作数 <code>left</code> 和 <code>right</code>，并定义了一个变量 <code>sum</code> 用于接收结果。接下来，和其它二元运算的操作码不同的是，这里会判断左右操作数是否都是字符串对象，如果是，则调用 <code>unicode_concatenate</code> 进行字符串拼接操作，否则调用 <code>PyNumber_Add</code>，接下来的操作与其它二元运算的操作码非常类似，减少引用计数，设置值栈栈顶值为 <code>sum</code>，如果 <code>sum</code> 为 <code>NULL</code> 就跳转到错误处理，否则执行下一个操作码。</p><p><code>unicode_concatenate</code> 的分析参考 <code>INPLACE_ADD</code>，这个函数会消耗掉 <code>left</code> 的引用计数，所以这里没有再减少 <code>left</code> 的引用计数。</p><p>下面来看 <code>PyNumber_Add</code>，在 Objects/abstract.c 中定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">PyObject *</span><br><span class="line">PyNumber_Add(PyObject *v, PyObject *w)</span><br><span class="line">&#123;</span><br><span class="line">    PyObject *result = binary_op1(v, w, NB_SLOT(nb_add));</span><br><span class="line">    <span class="keyword">if</span> (result == Py_NotImplemented) &#123;</span><br><span class="line">        PySequenceMethods *m = v-&gt;ob_type-&gt;tp_as_sequence;</span><br><span class="line">        Py_DECREF(result);</span><br><span class="line">        <span class="keyword">if</span> (m &amp;&amp; m-&gt;sq_concat) &#123;</span><br><span class="line">            <span class="keyword">return</span> (*m-&gt;sq_concat)(v, w);</span><br><span class="line">        &#125;</span><br><span class="line">        result = binop_type_error(v, w, <span class="string">"+"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数首先调用 <code>binary_op1</code>，<code>NB_SLOT(nb_add)</code> 是求 <code>nb_add</code> 字段在 <code>PyNumberMethods</code> 结构体中的偏移量。在这个函数已经在 <code>BINARY_MULTIPLY</code> 中分析过了，这里不再重复。如果返回值 <code>result</code> 是 <code>NotImplemented</code>，说明有可能是列表拼接（列表的 <code>tp_as_number</code> 字段为 <code>NULL</code>），接下来获取左操作数的 <code>ob_type</code> 的 <code>tp_as_sequence</code> 字段的值 <code>m</code>，并减少 <code>result</code> 的引用计数。然后，检查 <code>m</code> 和 <code>m-&gt;sq_concat</code> 字段是否为 <code>NULL</code>，不是则调用它指向的函数（列表的这个字段指向的函数是<code>list_concat</code>），并将拼接的值返回。如果 <code>m</code> 或者 <code>m-&gt;sq_concat</code> 为 <code>NULL</code>，调用 <code>binop_type_error</code> 设置 <code>TypeError</code>，最后将值返回。</p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python操作码——BINARY_MODULO</title>
      <link href="/python/python-opcode-BINARY_MODULO.html"/>
      <url>/python/python-opcode-BINARY_MODULO.html</url>
      
        <content type="html"><![CDATA[<p><code>BINARY_MODULO</code> 的编号是22，是个不带参数的操作码。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>dis.opmap[<span class="string">'BINARY_MODULO'</span>]</span><br><span class="line"><span class="number">22</span></span><br></pre></td></tr></table></figure><a id="more"></a><p>这个操作码对应 Python 的双目运算符 <code>%</code>，一般用于取模运算或者字符串格式化。实现如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">TARGET(BINARY_MODULO) &#123;</span><br><span class="line">    PyObject *divisor = POP();</span><br><span class="line">    PyObject *dividend = TOP();</span><br><span class="line">    PyObject *res;</span><br><span class="line">    <span class="keyword">if</span> (PyUnicode_CheckExact(dividend) &amp;&amp; (</span><br><span class="line">            !PyUnicode_Check(divisor) || PyUnicode_CheckExact(divisor))) &#123;</span><br><span class="line">        <span class="comment">// fast path; string formatting, but not if the RHS is a str subclass</span></span><br><span class="line">        <span class="comment">// (see issue28598)</span></span><br><span class="line">        res = PyUnicode_Format(dividend, divisor);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        res = PyNumber_Remainder(dividend, divisor);</span><br><span class="line">    &#125;</span><br><span class="line">    Py_DECREF(divisor);</span><br><span class="line">    Py_DECREF(dividend);</span><br><span class="line">    SET_TOP(res);</span><br><span class="line">    <span class="keyword">if</span> (res == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">goto</span> error;</span><br><span class="line">    DISPATCH();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>按照惯例，首先获取左右操作数。接下来，和其它双目运算符不同的是，这里会进行判断，是否左操作数是一个字符串对象且右操作数是一个字符串或者是非字符串子类的对象，注意 <code>PyUnicode_Check</code> 和 <code>PyUnicode_CheckExact</code> 的区别（<em>exact</em> 有“精确的”意思）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PyUnicode_CheckExact(op) (Py_TYPE(op) == &amp;PyUnicode_Type)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PyUnicode_Check(op) \</span></span><br><span class="line">    PyType_FastSubclass(Py_TYPE(op), Py_TPFLAGS_UNICODE_SUBCLASS)</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PyType_FastSubclass(t,f)  PyType_HasFeature(t,f)    </span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PyType_HasFeature(t,f)  (((t)-&gt;tp_flags &amp; (f)) != 0)</span></span><br></pre></td></tr></table></figure><p>如果整个 <code>if</code> 条件为真，将会调用 <code>PyUnicode_Format</code> 进行字符串格式化，否则调用 <code>PyNumber_Remainder</code> 进行运算。往下，减少左右操作数的引用计数，将值栈栈顶的值设为函数的返回值 <code>res</code>，接着检查 <code>res</code> 以确定是跳转到错误处理还是执行下一个操作码。</p><p><code>PyUnicode_Format</code> 在 Objects/unicodeobject.c 中定义，这里不展开。主要来看 <code>PyNumber_Remainder</code>，在 Objects/abstract.c 中定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">PyObject *</span><br><span class="line">PyNumber_Remainder(PyObject *v, PyObject *w)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> binary_op(v, w, NB_SLOT(nb_remainder), <span class="string">"%"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，这个函数就是对 <code>binary_op</code> 的包装，<code>NB_SLOT(nb_remainder)</code> 是获取 <code>nb_remainder</code> 在 <code>PyNumberMethods</code> 结构体中的偏移量。对 <code>binary_op</code> 的分析参考 <code>BINARY_MATRIX_MULTIPLY</code>。</p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python操作码——BINARY_FLOOR_DIVIDE</title>
      <link href="/python/python-opcode-BINARY_FLOOR_DIVIDE.html"/>
      <url>/python/python-opcode-BINARY_FLOOR_DIVIDE.html</url>
      
        <content type="html"><![CDATA[<p><code>BINARY_FLOOR_DIVIDE</code> 操作码的编号是26，是个不带参数的操作码。</p><a id="more"></a><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>dis.opmap[<span class="string">'BINARY_FLOOR_DIVIDE'</span>]</span><br><span class="line"><span class="number">26</span></span><br></pre></td></tr></table></figure><p>这个操作码对应 Python 的双目运算符 <code>//</code>，一般用于整除操作，实现如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">TARGET(BINARY_FLOOR_DIVIDE) &#123;</span><br><span class="line">    PyObject *divisor = POP();</span><br><span class="line">    PyObject *dividend = TOP();</span><br><span class="line">    PyObject *quotient = PyNumber_FloorDivide(dividend, divisor);</span><br><span class="line">    Py_DECREF(dividend);</span><br><span class="line">    Py_DECREF(divisor);</span><br><span class="line">    SET_TOP(quotient);</span><br><span class="line">    <span class="keyword">if</span> (quotient == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">goto</span> error;</span><br><span class="line">    DISPATCH();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和 <code>BINARY_TRUE_DIVIDE</code> 的唯一区别就是 <code>PyNumber_FloorDivide</code>，来看这个函数，在 Objects/abstract.c 中实现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">PyObject *</span><br><span class="line">PyNumber_FloorDivide(PyObject *v, PyObject *w)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> binary_op(v, w, NB_SLOT(nb_floor_divide), <span class="string">"//"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也是对 <code>binary_op</code> 的包装，<code>NB_SLOT(nb_floor_divide)</code> 获取 <code>nb_floor_divide</code> 字段在结构体 <code>PyNumberMethods</code> 中的偏移量。</p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python操作码——BINARY_TRUE_DIVIDE</title>
      <link href="/python/python-opcode-BINARY_TRUE_DIVIDE.html"/>
      <url>/python/python-opcode-BINARY_TRUE_DIVIDE.html</url>
      
        <content type="html"><![CDATA[<p><code>BINARY_TRUE_DIVIDE</code> 操作码的编号是27， 是个不带参数的操作码。</p><a id="more"></a><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>dis.opmap[<span class="string">'BINARY_TRUE_DIVIDE'</span>]</span><br><span class="line"><span class="number">27</span></span><br></pre></td></tr></table></figure><p>这个操作码对应 Python 的双目运算符 <code>/</code>，实现如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">TARGET(BINARY_TRUE_DIVIDE) &#123;</span><br><span class="line">    PyObject *divisor = POP();</span><br><span class="line">    PyObject *dividend = TOP();</span><br><span class="line">    PyObject *quotient = PyNumber_TrueDivide(dividend, divisor);</span><br><span class="line">    Py_DECREF(dividend);</span><br><span class="line">    Py_DECREF(divisor);</span><br><span class="line">    SET_TOP(quotient);</span><br><span class="line">    <span class="keyword">if</span> (quotient == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">goto</span> error;</span><br><span class="line">    DISPATCH();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>与其它双目运算符的实现非常类似，直接来看关键函数 <code>PyNumber_TrueDivide</code>，在 Objects/abstract.c 中实现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">PyObject *</span><br><span class="line">PyNumber_TrueDivide(PyObject *v, PyObject *w)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> binary_op(v, w, NB_SLOT(nb_true_divide), <span class="string">"/"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也是对 <code>binary_op</code> 的包装，<code>NB_SLOT(nb_true_divide)</code> 求 <code>nb_true_divide</code> 字段在结构体 <code>PyNumberMethods</code> 中的偏移量。对 <code>binary_op</code> 函数的分析参考 <code>BINARY_MATRIX_MULTIPLY</code>。</p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python操作码——BINARY_MATRIX_MULTIPLY</title>
      <link href="/python/python-opcode-BINARY_MATRIX_MULTIPLY.html"/>
      <url>/python/python-opcode-BINARY_MATRIX_MULTIPLY.html</url>
      
        <content type="html"><![CDATA[<p><code>BINARY_MATRIX_MULTIPLY</code> 操作码的编号是16， 是个不带参数的操作码。</p><a id="more"></a><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>dis.opmap[<span class="string">'BINARY_MATRIX_MULTIPLY'</span>]</span><br><span class="line"><span class="number">16</span></span><br></pre></td></tr></table></figure><p>这个操作码对象 Python 的双目运算符 <code>@</code>，一般用于矩阵点乘。实现如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">TARGET(BINARY_MATRIX_MULTIPLY) &#123;</span><br><span class="line">    PyObject *right = POP();</span><br><span class="line">    PyObject *left = TOP();</span><br><span class="line">    PyObject *res = PyNumber_MatrixMultiply(left, right);</span><br><span class="line">    Py_DECREF(left);</span><br><span class="line">    Py_DECREF(right);</span><br><span class="line">    SET_TOP(res);</span><br><span class="line">    <span class="keyword">if</span> (res == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">goto</span> error;</span><br><span class="line">    DISPATCH();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从值栈中获取左右操作数 <code>left</code> 和 <code>right</code>，将它们作为参数调用 <code>PyNumber_MatrixMultiply</code> 函数，减少 <code>left</code> 和 <code>right</code> 的引用计数，将值栈栈顶的值设为函数的返回值 <code>res</code>，如果 <code>res</code> 为 <code>NULL</code> 就跳转到错误处理，否则执行下一个操作码。可以看到，<code>PyNumber_MatrixMultiply</code> 是这段代码的关键，它在 Objects/abstract.c 中定义，实现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">PyObject *</span><br><span class="line">PyNumber_MatrixMultiply(PyObject *v, PyObject *w)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> binary_op(v, w, NB_SLOT(nb_matrix_multiply), <span class="string">"@"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数是对 <code>binary_op</code> 的包装，<code>NB_SLOT(nb_matrix_multiply)</code> 是获取 <code>nb_matrix_multiply</code> 字段在 <code>PyNumberMethods</code> 结构体中的偏移量。来看 <code>binary_op</code> 的实现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> PyObject *</span><br><span class="line">binary_op(PyObject *v, PyObject *w, <span class="keyword">const</span> <span class="keyword">int</span> op_slot, <span class="keyword">const</span> <span class="keyword">char</span> *op_name)</span><br><span class="line">&#123;</span><br><span class="line">    PyObject *result = binary_op1(v, w, op_slot);</span><br><span class="line">    <span class="keyword">if</span> (result == Py_NotImplemented) &#123;</span><br><span class="line">        Py_DECREF(result);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (op_slot == NB_SLOT(nb_rshift) &amp;&amp;</span><br><span class="line">            PyCFunction_Check(v) &amp;&amp;</span><br><span class="line">            <span class="built_in">strcmp</span>(((PyCFunctionObject *)v)-&gt;m_ml-&gt;ml_name, <span class="string">"print"</span>) == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            PyErr_Format(PyExc_TypeError,</span><br><span class="line">                <span class="string">"unsupported operand type(s) for %.100s: "</span></span><br><span class="line">                <span class="string">"'%.100s' and '%.100s'. Did you mean \"print(&lt;message&gt;, "</span></span><br><span class="line">                <span class="string">"file=&lt;output_stream&gt;)\"?"</span>,</span><br><span class="line">                op_name,</span><br><span class="line">                v-&gt;ob_type-&gt;tp_name,</span><br><span class="line">                w-&gt;ob_type-&gt;tp_name);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> binop_type_error(v, w, op_name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数开头会调用 <code>binary_op1</code>，这个函数在 <code>BINARY_MULTIPLY</code> 中已经分析过了，这里不再重复。如果返回值 <code>result</code> 是 <code>NotImplemented</code>，减少 <code>result</code> 的引用计数，接着检查 <code>opslot</code> 是否是 <code>nb_rshift</code> 且 <code>v</code> 是内置的 <code>print</code> 函数，如果条件为真，设置 <code>TypeError</code>，返回 <code>NULL</code>，不为真则通过 <code>binop_type_error</code> 设置 <code>TypeError</code> 并返回 <code>NULL</code>。注意这两个 <code>TypeError</code> 的提示信息是不一样的。最后，如果 <code>result</code> 不是 <code>NotImplemented</code> 就直接返回 <code>result</code>。</p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python操作码——BINARY_MULTIPLY</title>
      <link href="/python/python-opcode-BINARY_MULTIPLY.html"/>
      <url>/python/python-opcode-BINARY_MULTIPLY.html</url>
      
        <content type="html"><![CDATA[<p><code>BINARY_MULTIPLY</code> 的编号是20，是一个不带参数的操作码。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>dis.opmap[<span class="string">'BINARY_MULTIPLY'</span>]</span><br><span class="line"><span class="number">20</span></span><br></pre></td></tr></table></figure><a id="more"></a><p>这个操作码对应 Python 的双目运算符 <code>*</code>，实现如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">TARGET(BINARY_MULTIPLY) &#123;</span><br><span class="line">    PyObject *right = POP();</span><br><span class="line">    PyObject *left = TOP();</span><br><span class="line">    PyObject *res = PyNumber_Multiply(left, right);</span><br><span class="line">    Py_DECREF(left);</span><br><span class="line">    Py_DECREF(right);</span><br><span class="line">    SET_TOP(res);</span><br><span class="line">    <span class="keyword">if</span> (res == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">goto</span> error;</span><br><span class="line">    DISPATCH();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先从值栈获取双目运算的右操作数 <code>right</code> 和 左操作数 <code>left</code>，将它们作为参数调用 <code>PyNumber_Multiply</code>，这个是实际执行 <code>*</code> 操作的函数，在 Objects/abstract.c 文件中定义，实现如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">PyObject *</span><br><span class="line">PyNumber_Multiply(PyObject *v, PyObject *w)</span><br><span class="line">&#123;</span><br><span class="line">    PyObject *result = binary_op1(v, w, NB_SLOT(nb_multiply));</span><br><span class="line">    <span class="keyword">if</span> (result == Py_NotImplemented) &#123;</span><br><span class="line">        PySequenceMethods *mv = v-&gt;ob_type-&gt;tp_as_sequence;</span><br><span class="line">        PySequenceMethods *mw = w-&gt;ob_type-&gt;tp_as_sequence;</span><br><span class="line">        Py_DECREF(result);</span><br><span class="line">        <span class="keyword">if</span>  (mv &amp;&amp; mv-&gt;sq_repeat) &#123;</span><br><span class="line">            <span class="keyword">return</span> sequence_repeat(mv-&gt;sq_repeat, v, w);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (mw &amp;&amp; mw-&gt;sq_repeat) &#123;</span><br><span class="line">            <span class="keyword">return</span> sequence_repeat(mw-&gt;sq_repeat, w, v);</span><br><span class="line">        &#125;</span><br><span class="line">        result = binop_type_error(v, w, <span class="string">"*"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数一开始会调用 <code>binary_op1</code>，<code>NB_SLOT</code> 宏定义为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NB_SLOT(x) offsetof(PyNumberMethods, x)</span></span><br></pre></td></tr></table></figure><p><code>NB_SLOT(nb_multiply)</code> 就是求 <code>nb_multiply</code> 字段在 <code>PyNumberMethods</code> 结构体中的偏移量。来看 <code>binary_op1</code> 的实现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> PyObject *</span><br><span class="line">binary_op1(PyObject *v, PyObject *w, <span class="keyword">const</span> <span class="keyword">int</span> op_slot)</span><br><span class="line">&#123;</span><br><span class="line">    PyObject *x;</span><br><span class="line">    binaryfunc slotv = <span class="literal">NULL</span>;</span><br><span class="line">    binaryfunc slotw = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (v-&gt;ob_type-&gt;tp_as_number != <span class="literal">NULL</span>)</span><br><span class="line">        slotv = NB_BINOP(v-&gt;ob_type-&gt;tp_as_number, op_slot);</span><br><span class="line">    <span class="keyword">if</span> (w-&gt;ob_type != v-&gt;ob_type &amp;&amp;</span><br><span class="line">        w-&gt;ob_type-&gt;tp_as_number != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        slotw = NB_BINOP(w-&gt;ob_type-&gt;tp_as_number, op_slot);</span><br><span class="line">        <span class="keyword">if</span> (slotw == slotv)</span><br><span class="line">            slotw = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (slotv) &#123;</span><br><span class="line">        <span class="keyword">if</span> (slotw &amp;&amp; PyType_IsSubtype(w-&gt;ob_type, v-&gt;ob_type)) &#123;</span><br><span class="line">            x = slotw(v, w);</span><br><span class="line">            <span class="keyword">if</span> (x != Py_NotImplemented)</span><br><span class="line">                <span class="keyword">return</span> x;</span><br><span class="line">            Py_DECREF(x); <span class="comment">/* can't do it */</span></span><br><span class="line">            slotw = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        x = slotv(v, w);</span><br><span class="line">        <span class="keyword">if</span> (x != Py_NotImplemented)</span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        Py_DECREF(x); <span class="comment">/* can't do it */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (slotw) &#123;</span><br><span class="line">        x = slotw(v, w);</span><br><span class="line">        <span class="keyword">if</span> (x != Py_NotImplemented)</span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        Py_DECREF(x); <span class="comment">/* can't do it */</span></span><br><span class="line">    &#125;</span><br><span class="line">    Py_RETURN_NOTIMPLEMENTED;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数先检查 <code>v</code> 的 <code>ob_type</code> 字段的 <code>tp_as_number</code> 是否为 <code>NULL</code>， 不是则通过宏 <code>NB_BINOP</code> 获取其 <code>nb_multiply</code> 字段指向的函数赋给 <code>slotv</code>。<code>NB_BINOP</code> 定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NB_BINOP(nb_methods, slot) \</span></span><br><span class="line">        (*(binaryfunc*)(&amp; ((<span class="keyword">char</span>*)nb_methods)[slot]))</span><br></pre></td></tr></table></figure><p>接着判断 <code>w</code> 和 <code>v</code> 是否不是同一类型且 <code>w</code> 的 <code>ob_type</code> 字段的 <code>tp_as_number</code> 字段不为 <code>NULL</code>，条件为真则也获取其 <code>nb_multiply</code> 字段 指向的函数赋给 <code>slotw</code>，如果两个值相等，则将 <code>slotw</code> 设为 <code>NULL</code>。</p><p>往下，如果 <code>slotv</code> 不为 <code>NULL</code>，再进一步判断，如果 <code>slotw</code> 不为 <code>NULL</code> 且 <code>w</code> 是 <code>v</code> 的子类，调用 <code>slotw</code>。如果返回值 <code>x</code> 不是 <code>NotImplemented</code>，返回 <code>x</code>。否则减少 <code>x</code> 的引用计数，将 <code>slotw</code> 设为 <code>NULL</code>。既然没返回，接着调用 <code>slotv</code> 再像前面一样判断返回值。</p><p>如果再往下执行，说明前面 <code>v-&gt;ob_type-&gt;tp_as_number</code> 为 <code>NULL</code>，接下来要判断 <code>w</code>，如果不为 <code>NULL</code>，调用 <code>slotw</code>，再对返回值做同样的判断处理。到了这里还是没返回的话，最后只能返回 <code>NotImplemented</code> 了。<code>Py_RETURN_NOTIMPLEMENTED</code> 宏做的事就是增加 <code>NotImplemented</code> 的引用计数并返回它，定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Py_RETURN_NOTIMPLEMENTED return Py_INCREF(Py_NotImplemented), Py_NotImplemented</span></span><br></pre></td></tr></table></figure><p>回到 <code>PyNumber_Multiply</code>，如果返回值是 <code>NotImplemented</code>，获取 <code>v</code> 和 <code>w</code> 的 <code>ob_type</code> 的 <code>tp_as_sequence</code> 字段的值，这是 <code>PySequenceMethods *</code> 类型的值，<code>PySequenceMethods</code> 结构体是定义序列协议的结构体，由一系列的函数指针类型和 <code>void *</code> 类型的字段组成：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    lenfunc sq_length;</span><br><span class="line">    binaryfunc sq_concat;</span><br><span class="line">    ssizeargfunc sq_repeat;</span><br><span class="line">    ssizeargfunc sq_item;</span><br><span class="line">    <span class="keyword">void</span> *was_sq_slice;</span><br><span class="line">    ssizeobjargproc sq_ass_item;</span><br><span class="line">    <span class="keyword">void</span> *was_sq_ass_slice;</span><br><span class="line">    objobjproc sq_contains;</span><br><span class="line"></span><br><span class="line">    binaryfunc sq_inplace_concat;</span><br><span class="line">    ssizeargfunc sq_inplace_repeat;</span><br><span class="line">&#125; PySequenceMethods;</span><br></pre></td></tr></table></figure><p>往下，减少 <code>result</code> （这里是 <code>NotImplemented</code>）的引用计数。接着，检查 <code>sq_repeat</code> 字段的值，不为 <code>NULL</code> 则调用 <code>sequence_repeat</code> 并将结果返回，这个函数定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> PyObject *</span><br><span class="line">sequence_repeat(ssizeargfunc repeatfunc, PyObject *seq, PyObject *n)</span><br><span class="line">&#123;</span><br><span class="line">    Py_ssize_t count;</span><br><span class="line">    <span class="keyword">if</span> (PyIndex_Check(n)) &#123;</span><br><span class="line">        count = PyNumber_AsSsize_t(n, PyExc_OverflowError);</span><br><span class="line">        <span class="keyword">if</span> (count == <span class="number">-1</span> &amp;&amp; PyErr_Occurred())</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> type_error(<span class="string">"can't multiply sequence by "</span></span><br><span class="line">                          <span class="string">"non-int of type '%.200s'"</span>, n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (*repeatfunc)(seq, count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>PyIndex_Check</code> 是一个宏，定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PyIndex_Check(obj)                              \</span></span><br><span class="line">    ((obj)-&gt;ob_type-&gt;tp_as_number != <span class="literal">NULL</span> &amp;&amp;            \</span><br><span class="line">     (obj)-&gt;ob_type-&gt;tp_as_number-&gt;nb_index != <span class="literal">NULL</span>)</span><br></pre></td></tr></table></figure><p>对参数 <code>n</code>（这里是传入的 <code>w</code>）进行检查，为真则调用 <code>PyNumber_AsSsize_t</code> 检查 <code>n</code> 是否溢出，溢出则设置 <code>OverflowError</code> 并返回 <code>NULL</code>；为假说明 <code>n</code> 不是 <code>int</code> 类型，将返回 <code>TypeError</code>，最后，没有异常发生，调用 <code>repeatfunc</code> 并返回结果。</p><p>再次回到 <code>PyNumber_Multiply</code>，往下执行说明 <code>mv</code> 和 <code>mw</code> 或者它们的 <code>sq_repeat</code> 字段都是 <code>NULL</code>，调用 <code>binop_type_error</code> 设置 <code>TypeError</code> 异常并将 <code>result</code> 设为 <code>NULL</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> PyObject *</span><br><span class="line">binop_type_error(PyObject *v, PyObject *w, <span class="keyword">const</span> <span class="keyword">char</span> *op_name)</span><br><span class="line">&#123;</span><br><span class="line">    PyErr_Format(PyExc_TypeError,</span><br><span class="line">                 <span class="string">"unsupported operand type(s) for %.100s: "</span></span><br><span class="line">                 <span class="string">"'%.100s' and '%.100s'"</span>,</span><br><span class="line">                 op_name,</span><br><span class="line">                 v-&gt;ob_type-&gt;tp_name,</span><br><span class="line">                 w-&gt;ob_type-&gt;tp_name);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到了这里说明左右操作数都不支持双目运算符 <code>*</code>。最后，将 <code>result</code> 返回， <code>PyNumber_Multiply</code> 函数就此结束。</p><p>回到操作码的执行，<code>res</code> 接收返回值，接着减少 <code>left</code> 和 <code>right</code> 的引用计数，并将值栈栈顶值设为 <code>res</code>，如果 <code>res</code> 为 <code>NULL</code>，跳转到错误处理，否则执行下一个操作码。</p><p>试着用一个实例简单走一遍执行过程，Python 的列表支持 <code>*</code> 操作，如 <code>[1] * 5</code> 的结果是 <code>[1, 1, 1, 1, 1]</code>，这个例子中，左操作数是列表对象 <code>[1]</code>，右操作数是 <code>int</code> 对象 <code>5</code>，传入 <code>PyNumber_Multiply</code>，然后来到 <code>binary_op1</code>，列表的 <code>tp_as_number</code> 字段为 <code>NULL</code>，所以 <code>slotv</code> 为 <code>NULL</code>，<code>int</code> 对象的 <code>tp_as_number</code> 对象有值，<code>slotw</code> 不为 <code>NULL</code>。于是直接跳过了 <code>if (slotv)</code> 的分支，进入 <code>if (slotw)</code> 的分支。调用 <code>slotw</code>，对应 Objects/longobject.c 文件中的 <code>long_mul</code> 函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> PyObject *</span><br><span class="line">long_mul(PyLongObject *a, PyLongObject *b)</span><br><span class="line">&#123;</span><br><span class="line">    PyLongObject *z;</span><br><span class="line"></span><br><span class="line">    CHECK_BINOP(a, b);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 后面的省略...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>CHECK_BINOP</code> 是一个宏，检查两个操作数的类型：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CHECK_BINOP(v,w) do &#123; <span class="meta-keyword">if</span> (!PyLong_Check(v) || !PyLong_Check(w)) Py_RETURN_NOTIMPLEMENTED; &#125; while(0)</span></span><br></pre></td></tr></table></figure><p>两个操作数都必须是 <code>int</code> 对象（<code>int</code> 对象在 Python 底层叫 <code>PyLongObject</code>）。很明显 <code>v</code> 是不是 <code>int</code> 对象，于是返回 <code>NotImplemented</code>。回到 <code>binary_op1</code>，它也返回 <code>NotImplemented</code>，再回到 <code>PyNumber_Multiply</code>，获取 <code>ob_type</code> 的 <code>tp_as_sequence</code> 的值，列表对象存在这个值而 <code>int</code> 对象的这个值为 <code>NULL</code>，于是进入 <code>sequence_repeat</code> 函数。检查 <code>n</code>，这里 <code>n</code> 为 <code>5</code>，所以直接调用 <code>sq_repeat</code> 指向的函数，对应 Objects/listobject.c 的 <code>list_repeat</code>，就是这个函数实现了列表的双目运算符 <code>*</code> 操作。这里不再列出该函数，有兴趣的自行查看。分析至此结束。</p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python操作码——BINARY_POWER</title>
      <link href="/python/python-opcode-BINARY_POWER.html"/>
      <url>/python/python-opcode-BINARY_POWER.html</url>
      
        <content type="html"><![CDATA[<p><code>BINARY_POWER</code> 操作码的编号是19，是个不带参数的操作码。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>dis.opmap[<span class="string">'BINARY_POWER'</span>]</span><br><span class="line"><span class="number">19</span></span><br></pre></td></tr></table></figure><a id="more"></a><p>这个操作码对应 Python 的双目运算符 <code>**</code>，常用于数字的幂运算。底层实现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">TARGET(BINARY_POWER) &#123;</span><br><span class="line">    PyObject *<span class="built_in">exp</span> = POP();</span><br><span class="line">    PyObject *base = TOP();</span><br><span class="line">    PyObject *res = PyNumber_Power(base, <span class="built_in">exp</span>, Py_None);</span><br><span class="line">    Py_DECREF(base);</span><br><span class="line">    Py_DECREF(<span class="built_in">exp</span>);</span><br><span class="line">    SET_TOP(res);</span><br><span class="line">    <span class="keyword">if</span> (res == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">goto</span> error;</span><br><span class="line">    DISPATCH();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先从值栈中获取幂运算的指数 <code>exp</code> 和底数 <code>base</code>，它们被压入值栈中的顺序是先底数后指数，所以获取时顺序相反，看个例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>dis.dis(<span class="string">'a = 2; a**2'</span>)</span><br><span class="line">  <span class="number">1</span>           <span class="number">0</span> LOAD_CONST               <span class="number">0</span> (<span class="number">2</span>)</span><br><span class="line">              <span class="number">2</span> STORE_NAME               <span class="number">0</span> (a)</span><br><span class="line">              <span class="number">4</span> LOAD_NAME                <span class="number">0</span> (a)</span><br><span class="line">              <span class="number">6</span> LOAD_CONST               <span class="number">0</span> (<span class="number">2</span>)</span><br><span class="line">              <span class="number">8</span> BINARY_POWER</span><br><span class="line">             <span class="number">10</span> POP_TOP</span><br><span class="line">             <span class="number">12</span> LOAD_CONST               <span class="number">1</span> (<span class="literal">None</span>)</span><br><span class="line">             <span class="number">14</span> RETURN_VALUE</span><br></pre></td></tr></table></figure><p>从第三列开始，<code>LOAD_NAME</code> 将底数 <code>a</code> 对应的值压入值栈中，<code>LOAD_CONST</code> 将指数2压入值栈中。接着执行 <code>BINARY_POWER</code>。</p><p>往下，获取底数和指数之后，将它们作为参数调用 <code>PyNumber_Power</code>，这个函数在 Objects/abstract.c 中定义，具体实现如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">PyObject *</span><br><span class="line">PyNumber_Power(PyObject *v, PyObject *w, PyObject *z)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> PyNumberMethods(v, w, z, NB_SLOT(nb_power), <span class="string">"** or pow()"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到这个函数就是对 <code>ternary_op</code> 的简单包装，先来看传给 <code>ternary_op</code> 函数的参数。<code>v</code> 是底数，<code>w</code> 是指数，<code>z</code> 是 <code>None</code>，<code>NB_SLOT</code>，一个宏，定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NB_SLOT(x) offsetof(PyNumberMethods, x)</span></span><br></pre></td></tr></table></figure><p>使用 C 库的 <code>offsetof</code> 宏求 <code>x</code> 在 <code>PyNumberMethods</code> 结构体中的偏移量，这里求的是 <code>nb_power</code>。最后一个参数是一个常量字符串。接下来来看看 <code>ternary_op</code> 函数的实现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> PyObject *</span><br><span class="line">ternary_op(PyObject *v,</span><br><span class="line">           PyObject *w,</span><br><span class="line">           PyObject *z,</span><br><span class="line">           <span class="keyword">const</span> <span class="keyword">int</span> op_slot,</span><br><span class="line">           <span class="keyword">const</span> <span class="keyword">char</span> *op_name)</span><br><span class="line">&#123;</span><br><span class="line">    PyNumberMethods *mv, *mw, *mz;</span><br><span class="line">    PyObject *x = <span class="literal">NULL</span>;</span><br><span class="line">    ternaryfunc slotv = <span class="literal">NULL</span>;</span><br><span class="line">    ternaryfunc slotw = <span class="literal">NULL</span>;</span><br><span class="line">    ternaryfunc slotz = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    mv = v-&gt;ob_type-&gt;tp_as_number;</span><br><span class="line">    mw = w-&gt;ob_type-&gt;tp_as_number;</span><br><span class="line">    <span class="keyword">if</span> (mv != <span class="literal">NULL</span>)</span><br><span class="line">        slotv = NB_TERNOP(mv, op_slot);</span><br><span class="line">    <span class="keyword">if</span> (w-&gt;ob_type != v-&gt;ob_type &amp;&amp;</span><br><span class="line">        mw != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        slotw = NB_TERNOP(mw, op_slot);</span><br><span class="line">        <span class="keyword">if</span> (slotw == slotv)</span><br><span class="line">            slotw = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (slotv) &#123;</span><br><span class="line">        <span class="keyword">if</span> (slotw &amp;&amp; PyType_IsSubtype(w-&gt;ob_type, v-&gt;ob_type)) &#123;</span><br><span class="line">            x = slotw(v, w, z);</span><br><span class="line">            <span class="keyword">if</span> (x != Py_NotImplemented)</span><br><span class="line">                <span class="keyword">return</span> x;</span><br><span class="line">            Py_DECREF(x); <span class="comment">/* can't do it */</span></span><br><span class="line">            slotw = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        x = slotv(v, w, z);</span><br><span class="line">        <span class="keyword">if</span> (x != Py_NotImplemented)</span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        Py_DECREF(x); <span class="comment">/* can't do it */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (slotw) &#123;</span><br><span class="line">        x = slotw(v, w, z);</span><br><span class="line">        <span class="keyword">if</span> (x != Py_NotImplemented)</span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        Py_DECREF(x); <span class="comment">/* can't do it */</span></span><br><span class="line">    &#125;</span><br><span class="line">    mz = z-&gt;ob_type-&gt;tp_as_number;</span><br><span class="line">    <span class="keyword">if</span> (mz != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        slotz = NB_TERNOP(mz, op_slot);</span><br><span class="line">        <span class="keyword">if</span> (slotz == slotv || slotz == slotw)</span><br><span class="line">            slotz = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">if</span> (slotz) &#123;</span><br><span class="line">            x = slotz(v, w, z);</span><br><span class="line">            <span class="keyword">if</span> (x != Py_NotImplemented)</span><br><span class="line">                <span class="keyword">return</span> x;</span><br><span class="line">            Py_DECREF(x); <span class="comment">/* can't do it */</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (z == Py_None)</span><br><span class="line">        PyErr_Format(</span><br><span class="line">            PyExc_TypeError,</span><br><span class="line">            <span class="string">"unsupported operand type(s) for ** or pow(): "</span></span><br><span class="line">            <span class="string">"'%.100s' and '%.100s'"</span>,</span><br><span class="line">            v-&gt;ob_type-&gt;tp_name,</span><br><span class="line">            w-&gt;ob_type-&gt;tp_name);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        PyErr_Format(</span><br><span class="line">            PyExc_TypeError,</span><br><span class="line">            <span class="string">"unsupported operand type(s) for pow(): "</span></span><br><span class="line">            <span class="string">"'%.100s', '%.100s', '%.100s'"</span>,</span><br><span class="line">            v-&gt;ob_type-&gt;tp_name,</span><br><span class="line">            w-&gt;ob_type-&gt;tp_name,</span><br><span class="line">            z-&gt;ob_type-&gt;tp_name);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数开头定义了三个 <code>PyNumberMethods *</code> 类型的变量 <code>mv</code>、<code>mw</code>、<code>mz</code>，一个 <code>PyObject *</code> 类型的变量 <code>x</code> 和三个 <code>ternaryfunc</code> 函数指针类型的变量 <code>slotv</code>、<code>slotw</code>、<code>slotz</code>。接下来分别获取 <code>v</code> 和 <code>w</code> 的 <code>ob_type</code> 的 <code>tp_as_number</code> 字段的值。如果 <code>mv</code> 不为 <code>NULL</code>，使用 <code>NB_TERNOP</code> 宏获取它的 <code>nb_power</code> 字段指向的函数并赋值给 slotv。宏的定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NB_TERNOP(nb_methods,slot) \</span></span><br><span class="line">        (*(ternaryfunc*)(&amp; ((<span class="keyword">char</span>*)nb_methods)[slot]))</span><br></pre></td></tr></table></figure><blockquote><p>简单解释这个宏，这里传进来的 <code>nb_methods</code> 是一个 <code>PyNumberMethods *</code> 类型的值，而 <code>slot</code> 是个 <code>int</code> 类型的值，表示偏移量。<code>(char *)nb_methods</code> 将 <code>nb_methods</code> 转换成了 <code>char *</code> 类型，后面的下标运算相当于 <code>((char *)nb_methods) + slot</code>，于是取到了 <code>nb_power</code> 在 <code>PyNumberMethods</code> 的首地址对应的值。但是，这里需要的是地址，所以就有了 <code>&amp;</code> 取地址符。拿到了地址之后，转换成 <code>ternaryfunc *</code> 的形式读取，最后用 <code>*</code> 解引用得到了 <code>nb_power</code> 指向的那个函数。</p></blockquote><p>接下来判断 <code>w</code> 和 <code>v</code> 是否是不同类型，如果不是且 <code>mv</code> 不为 <code>NULL</code>，同样使用宏获取它的 <code>nb_power</code> 指向的函数并赋值给 <code>slotw</code>，如果 <code>slotw</code> 和 <code>slotv</code> 是同一个函数，就将 <code>slotw</code> 设为 <code>NULL</code>。</p><p>往下，<code>slotv</code> 不为 <code>NULL</code> 的情况，如果 <code>slotw</code> 也不为 <code>NULL</code> 且 <code>w</code> 是 <code>v</code> 的子类，直接将 <code>v</code>、<code>w</code>、<code>z</code> 作为参数调用 <code>slotw</code>，如果返回值 <code>x</code> 不是 <code>NotImplemented</code>，直接将 <code>x</code> 返回。否则，减少 <code>x</code> 的引用计数并将 <code>slotw</code> 设为 <code>NULL</code>。再往下，调用 <code>slotv</code>，然后再次判断结果决定是否返回。</p><p>没有返回，继续往下执行，如果 <code>slotw</code> 不为 <code>NULL</code>，调用 <code>slotw</code> 然后重复上述过程。如果函数还是没返回，获取 <code>z</code> 的 <code>ob_type</code> 的 <code>tp_as_number</code> 字段的值 <code>mz</code>，接下来的工作和前面非常类似，这里不再解释。如果函数还是没返回，接下来将检查 <code>z</code> 是否为 <code>None</code> 以设置不同提示的 <code>TypeError</code>，最后返回 <code>NULL</code>。</p><p>回到操作码的执行，结果由 <code>res</code> 接收。接下来减少 <code>base</code> 和 <code>exp</code> 的引用计数，并将值栈栈顶值设为 <code>res</code>，如果 <code>res</code> 为 <code>NULL</code>，跳转到错误处理部分，否则执行下一个操作码。</p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python操作码——UNARY_INVERT</title>
      <link href="/python/python-opcode-UNARY_INVERT.html"/>
      <url>/python/python-opcode-UNARY_INVERT.html</url>
      
        <content type="html"><![CDATA[<p><code>UNARY_INVERT</code> 操作码的编号是15，是个不带参数的操作码。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>dis.opmap[<span class="string">'UNARY_INVERT'</span>]</span><br><span class="line"><span class="number">15</span></span><br></pre></td></tr></table></figure><a id="more"></a><p>这个操作码对应 Python 的单目运算符 <code>~</code>，底层实现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">TARGET(UNARY_INVERT) &#123;</span><br><span class="line">    PyObject *value = TOP();</span><br><span class="line">    PyObject *res = PyNumber_Invert(value);</span><br><span class="line">    Py_DECREF(value);</span><br><span class="line">    SET_TOP(res);</span><br><span class="line">    <span class="keyword">if</span> (res == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">goto</span> error;</span><br><span class="line">    DISPATCH();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先获取值栈栈顶的值 <code>value</code>，然后将其作为参数调用 <code>PyNumber_Invert</code>，在 Objects/abstract.c 中定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">PyObject *</span><br><span class="line">PyNumber_Invert(PyObject *o)</span><br><span class="line">&#123;</span><br><span class="line">    PyNumberMethods *m;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (o == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> null_error();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    m = o-&gt;ob_type-&gt;tp_as_number;</span><br><span class="line">    <span class="keyword">if</span> (m &amp;&amp; m-&gt;nb_invert)</span><br><span class="line">        <span class="keyword">return</span> (*m-&gt;nb_invert)(o);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> type_error(<span class="string">"bad operand type for unary ~: '%.200s'"</span>, o);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数的核心是检查对象 <code>o</code> 的 <code>ob_type</code> 字段的 <code>tp_as_number</code> 的 <code>nb_invert</code> 字段的值是否为 <code>NULL</code>，这个字段的值是一个函数指针，如果不为 <code>NULL</code> 则调用它并将结果返回，否则设置 <code>TypeError</code> 并返回 <code>NULL</code>。</p><p>回到操作码的执行，返回值由 <code>res</code> 接收，往下会减少 <code>value</code> 的引用计数，并将值栈栈顶的值设置成 <code>res</code>， 如果 <code>res</code> 为 <code>NULL</code>，跳转到错误处理，否则执行下一个操作码。</p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python操作码——UNARY_NOT</title>
      <link href="/python/python-opcode-UNARY_NOT.html"/>
      <url>/python/python-opcode-UNARY_NOT.html</url>
      
        <content type="html"><![CDATA[<p>操作码 <code>UNARY_NOT</code> 的编号是12，是一个不带参数的操作码。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>dis.opmap[<span class="string">'UNARY_NOT'</span>]</span><br><span class="line"><span class="number">12</span></span><br></pre></td></tr></table></figure><a id="more"></a><p>这个操作码对应 Python 的 <code>not</code> 运算符，实现如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">TARGET(UNARY_NOT) &#123;</span><br><span class="line">    PyObject *value = TOP();</span><br><span class="line">    <span class="keyword">int</span> err = PyObject_IsTrue(value);</span><br><span class="line">    Py_DECREF(value);</span><br><span class="line">    <span class="keyword">if</span> (err == <span class="number">0</span>) &#123;</span><br><span class="line">        Py_INCREF(Py_True);</span><br><span class="line">        SET_TOP(Py_True);</span><br><span class="line">        DISPATCH();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (err &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        Py_INCREF(Py_False);</span><br><span class="line">        SET_TOP(Py_False);</span><br><span class="line">        DISPATCH();</span><br><span class="line">    &#125;</span><br><span class="line">    STACKADJ(<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">goto</span> error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先获取值栈栈顶的值 <code>value</code>，然后将其作为参数调用 <code>PyObject_IsTrue</code>，这个函数位于 Objects/object.c，实现如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span></span><br><span class="line">PyObject_IsTrue(PyObject *v)</span><br><span class="line">&#123;</span><br><span class="line">    Py_ssize_t res;</span><br><span class="line">    <span class="keyword">if</span> (v == Py_True)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (v == Py_False)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (v == Py_None)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (v-&gt;ob_type-&gt;tp_as_number != <span class="literal">NULL</span> &amp;&amp;</span><br><span class="line">             v-&gt;ob_type-&gt;tp_as_number-&gt;nb_bool != <span class="literal">NULL</span>)</span><br><span class="line">        res = (*v-&gt;ob_type-&gt;tp_as_number-&gt;nb_bool)(v);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (v-&gt;ob_type-&gt;tp_as_mapping != <span class="literal">NULL</span> &amp;&amp;</span><br><span class="line">             v-&gt;ob_type-&gt;tp_as_mapping-&gt;mp_length != <span class="literal">NULL</span>)</span><br><span class="line">        res = (*v-&gt;ob_type-&gt;tp_as_mapping-&gt;mp_length)(v);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (v-&gt;ob_type-&gt;tp_as_sequence != <span class="literal">NULL</span> &amp;&amp;</span><br><span class="line">             v-&gt;ob_type-&gt;tp_as_sequence-&gt;sq_length != <span class="literal">NULL</span>)</span><br><span class="line">        res = (*v-&gt;ob_type-&gt;tp_as_sequence-&gt;sq_length)(v);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="comment">/* if it is negative, it should be either -1 or -2 */</span></span><br><span class="line">    <span class="keyword">return</span> (res &gt; <span class="number">0</span>) ? <span class="number">1</span> : Py_SAFE_DOWNCAST(res, Py_ssize_t, <span class="keyword">int</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数的逻辑比较简单，如果参数 <code>v</code> 是 <code>True</code> 返回1，是 <code>False</code> 返回0。如果是 <code>None</code> 也返回0，否则会依序检查参数的 <code>ob_type</code> 的 <code>tp_as_number</code> 的 <code>nb_bool</code> 字段（一个函数指针），<code>tp_as_mapping</code> 的 <code>mp_length</code> 字段和 <code>tp_as_sequence</code> 的 <code>sq_length</code> 字段，不为 <code>NULL</code> 则调用它们指向的函数。如果以上条件都不符合，则认为这个对象是真值，直接返回1。最后，如果上述的某个函数指针不为 <code>NULL</code>，会对其函数调用的结果 <code>res</code> 进行判断，如果 <code>res</code> 大于0，则认为这个对象是真值，返回1。如果 <code>res</code> 小于0，那么它应该是-1或者-2，将 <code>res</code> 转换成 <code>int</code> 类型返回。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> Py_DEBUG</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Py_SAFE_DOWNCAST(VALUE, WIDE, NARROW) \</span></span><br><span class="line">    (assert((WIDE)(NARROW)(VALUE) == (VALUE)), (NARROW)(VALUE))</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Py_SAFE_DOWNCAST(VALUE, WIDE, NARROW) (NARROW)(VALUE)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>回到操作码的执行，首先会减少 <code>value</code> 的引用计数，接着对调用 <code>PyObject_IsTrue</code> 的结果 <code>err</code> 进行判断，如果为0，说明 <code>value</code> 是假值，对假值进行 <code>not</code> 操作，那么结果是一个真值，所以这里会增加 <code>True</code> 的引用计数并将其设置为值栈栈顶的值。同理，如果 <code>err</code> 大于0，说明 <code>value</code> 是真值，对真值进行 <code>not</code> 操作，结果就是假值，所以要增加 <code>False</code> 的引用计数并将其设为值栈栈顶的值。<code>Py_True</code> 和 <code>Py_False</code> 是 <code>True</code> 和 <code>False</code> 在 Python 底层的表示。最后如果以上结果都不是，调整 <code>stack_pointer</code> 指针，跳转到错误处理。</p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python操作码——UNARY_NEGATIVE</title>
      <link href="/python/python-opcode-UNARY_NEGATIVE.html"/>
      <url>/python/python-opcode-UNARY_NEGATIVE.html</url>
      
        <content type="html"><![CDATA[<p><code>UNARY_NEGATIVE</code> 的编号是11，是一个不带参数的操作码。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>dis.opmap[<span class="string">'UNARY_NEGATIVE'</span>]</span><br><span class="line"><span class="number">11</span></span><br></pre></td></tr></table></figure><a id="more"></a><p>这个操作码对应 Python 的单目运算符 <code>-</code>，底层实现如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">TARGET(UNARY_NEGATIVE) &#123;</span><br><span class="line">    PyObject *value = TOP();</span><br><span class="line">    PyObject *res = PyNumber_Negative(value);</span><br><span class="line">    Py_DECREF(value);</span><br><span class="line">    SET_TOP(res);</span><br><span class="line">    <span class="keyword">if</span> (res == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">goto</span> error;</span><br><span class="line">    DISPATCH();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和 <code>UNARY_POSITIVE</code> 非常类似，获取值栈栈顶的值 <code>value</code> 并将其作为参数调用 <code>PyNumber_Negative</code>，然后减少 <code>value</code> 的引用计数并将值栈栈顶的值设置为函数 <code>PyNumber_Negative</code> 的返回值 <code>res</code>（简单来说就是弹出 <code>value</code> 并压入 <code>res</code>），如果 <code>res</code> 的值为 <code>NULL</code> 则跳转到错误处理部分，否则执行下一个操作码。这里面的关键是 <code>PyNumber_Negative</code> 函数，在 Objects/abstract.c 中定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">PyObject *</span><br><span class="line">PyNumber_Negative(PyObject *o)</span><br><span class="line">&#123;</span><br><span class="line">    PyNumberMethods *m;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (o == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> null_error();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    m = o-&gt;ob_type-&gt;tp_as_number;</span><br><span class="line">    <span class="keyword">if</span> (m &amp;&amp; m-&gt;nb_negative)</span><br><span class="line">        <span class="keyword">return</span> (*m-&gt;nb_negative)(o);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> type_error(<span class="string">"bad operand type for unary -: '%.200s'"</span>, o);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数会获取参数 <code>o</code> 的 <code>ob_type</code> 字段的 <code>tp_as_number</code> 字段的值 <code>m</code>，如果 <code>m</code> 不为 <code>NULL</code> 且 <code>m</code> 的 <code>nb_negative</code> 字段的值（一个函数指针）不为 <code>NULL</code>，则将 <code>o</code> 作为参数调用它并将结果返回。否则会设置 <code>TypeError</code> 并返回 <code>NULL</code>。</p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python操作码——UNARY_POSITIVE</title>
      <link href="/python/python-opcode-UNARY_POSITIVE.html"/>
      <url>/python/python-opcode-UNARY_POSITIVE.html</url>
      
        <content type="html"><![CDATA[<p><code>UNARY_POSITIVE</code> 的编号是10，是个不带参数的操作码。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>dis.opmap[<span class="string">'UNARY_POSITIVE'</span>]</span><br><span class="line"><span class="number">10</span></span><br></pre></td></tr></table></figure><a id="more"></a><p>这个操作码对应 Python 中的单目运算符 <code>+</code>，底层实现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">TARGET(UNARY_POSITIVE) &#123;</span><br><span class="line">    PyObject *value = TOP();</span><br><span class="line">    PyObject *res = PyNumber_Positive(value);</span><br><span class="line">    Py_DECREF(value);</span><br><span class="line">    SET_TOP(res);</span><br><span class="line">    <span class="keyword">if</span> (res == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">goto</span> error;</span><br><span class="line">    DISPATCH();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先获取值栈栈顶的值 <code>value</code>，然后将其作为参数调用 <code>PyNumber_Positive</code> 函数，这个函数在 Objects/abstract.c 中定义，来看其实现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">PyObject *</span><br><span class="line">PyNumber_Positive(PyObject *o)</span><br><span class="line">&#123;</span><br><span class="line">    PyNumberMethods *m;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (o == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> null_error();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    m = o-&gt;ob_type-&gt;tp_as_number;</span><br><span class="line">    <span class="keyword">if</span> (m &amp;&amp; m-&gt;nb_positive)</span><br><span class="line">        <span class="keyword">return</span> (*m-&gt;nb_positive)(o);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> type_error(<span class="string">"bad operand type for unary +: '%.200s'"</span>, o);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数的返回值是 <code>PyObject *</code> 类型。函数开头定义了一个 <code>PyNumberMethods *</code> 类型的变量，<code>PyNumberMethods</code> 是定义 Python 数字协议的结构体。定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    binaryfunc nb_add;</span><br><span class="line">    binaryfunc nb_subtract;</span><br><span class="line">    binaryfunc nb_multiply;</span><br><span class="line">    binaryfunc nb_remainder;</span><br><span class="line">    binaryfunc nb_divmod;</span><br><span class="line">    ternaryfunc nb_power;</span><br><span class="line">    unaryfunc nb_negative;</span><br><span class="line">    unaryfunc nb_positive;</span><br><span class="line">    unaryfunc nb_absolute;</span><br><span class="line">    inquiry nb_bool;</span><br><span class="line">    unaryfunc nb_invert;</span><br><span class="line">    binaryfunc nb_lshift;</span><br><span class="line">    binaryfunc nb_rshift;</span><br><span class="line">    binaryfunc nb_and;</span><br><span class="line">    binaryfunc nb_xor;</span><br><span class="line">    binaryfunc nb_or;</span><br><span class="line">    unaryfunc nb_int;</span><br><span class="line">    <span class="keyword">void</span> *nb_reserved;  <span class="comment">/* the slot formerly known as nb_long */</span></span><br><span class="line">    unaryfunc nb_float;</span><br><span class="line"></span><br><span class="line">    binaryfunc nb_inplace_add;</span><br><span class="line">    binaryfunc nb_inplace_subtract;</span><br><span class="line">    binaryfunc nb_inplace_multiply;</span><br><span class="line">    binaryfunc nb_inplace_remainder;</span><br><span class="line">    ternaryfunc nb_inplace_power;</span><br><span class="line">    binaryfunc nb_inplace_lshift;</span><br><span class="line">    binaryfunc nb_inplace_rshift;</span><br><span class="line">    binaryfunc nb_inplace_and;</span><br><span class="line">    binaryfunc nb_inplace_xor;</span><br><span class="line">    binaryfunc nb_inplace_or;</span><br><span class="line"></span><br><span class="line">    binaryfunc nb_floor_divide;</span><br><span class="line">    binaryfunc nb_true_divide;</span><br><span class="line">    binaryfunc nb_inplace_floor_divide;</span><br><span class="line">    binaryfunc nb_inplace_true_divide;</span><br><span class="line"></span><br><span class="line">    unaryfunc nb_index;</span><br><span class="line"></span><br><span class="line">    binaryfunc nb_matrix_multiply;</span><br><span class="line">    binaryfunc nb_inplace_matrix_multiply;</span><br><span class="line">&#125; PyNumberMethods;</span><br></pre></td></tr></table></figure><p>几乎所有字段都是函数指针，从字段的名称就可以看出它们分别对应哪些函数。这里面我们只关心 <code>nb_positive</code>，类型定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> PyObject * (*unaryfunc)(PyObject *);</span><br></pre></td></tr></table></figure><p>函数往下执行，如果参数 <code>o</code> 为 <code>NULL</code>，会调用函数 <code>null_error</code> 并返回：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> PyObject *</span><br><span class="line">null_error(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!PyErr_Occurred())</span><br><span class="line">        PyErr_SetString(PyExc_SystemError,</span><br><span class="line">                        <span class="string">"null argument to internal routine"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果没有引发异常则设置为 <code>SystemError</code> 然后返回 <code>NULL</code>。</p><p>参数 <code>o</code> 不为 <code>NULL</code>，获取它的 <code>ob_type</code> 字段的 <code>tp_as_number</code> 字段的值，也就是指向 <code>PyNumberMethods</code> 的指针，如果 <code>m</code> 不为 <code>NULL</code> 且 <code>nb_positive</code> 不为 <code>NULL</code>，则将 <code>o</code> 做为参数调用 <code>nb_positive</code> 指向的函数并将结果返回。否则说明对象 <code>o</code> 不支持单目运算符 <code>+</code>，于是返回设置 <code>TypeError</code> 并返回 <code>NULL</code>，也就是 <code>type_error</code> 函数的工作：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> PyObject *</span><br><span class="line">type_error(<span class="keyword">const</span> <span class="keyword">char</span> *msg, PyObject *obj)</span><br><span class="line">&#123;</span><br><span class="line">    PyErr_Format(PyExc_TypeError, msg, obj-&gt;ob_type-&gt;tp_name);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>PyNumber_Positive</code> 执行的结果由 <code>res</code> 接收，之后需要将 <code>value</code> 的引用计数减一，将 <code>res</code> 设置为值栈栈顶的值（相当于弹出 <code>value</code> 压入 <code>res</code>），如果 <code>res</code> 为 <code>NULL</code>，跳转到错误处理，否则执行下一个操作码。</p><p>在 Python 中，对一个不支持单目运算符 <code>+</code> 操作的对象如列表使用确实会引发 <code>TypeError</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>+[]</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">TypeError: bad operand type <span class="keyword">for</span> unary +: <span class="string">'list'</span></span><br></pre></td></tr></table></figure><p>而在一个 <code>int</code> 型数字前加上 <code>+</code> 号会返回数字本身，如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="number">5</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>+a</span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="number">-5</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>+a</span><br><span class="line"><span class="number">-5</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dis.dis(<span class="string">'a = -5;+a'</span>)</span><br><span class="line">  <span class="number">1</span>           <span class="number">0</span> LOAD_CONST               <span class="number">0</span> (<span class="number">-5</span>)</span><br><span class="line">              <span class="number">2</span> STORE_NAME               <span class="number">0</span> (a)</span><br><span class="line">              <span class="number">4</span> LOAD_NAME                <span class="number">0</span> (a)</span><br><span class="line">              <span class="number">6</span> UNARY_POSITIVE</span><br><span class="line">              <span class="number">8</span> POP_TOP</span><br><span class="line">             <span class="number">10</span> LOAD_CONST               <span class="number">1</span> (<span class="literal">None</span>)</span><br><span class="line">             <span class="number">12</span> RETURN_VALUE</span><br></pre></td></tr></table></figure><p>简单跟踪这段字节码里 <code>UNARY_POSITIVE</code> 的执行，根据上面的分析，这个操作码先获取值栈栈顶的值，在这里是-5，然后以-5作为参数调用 <code>PyNumber_Positive</code>。执行流到了 <code>PyNumber_Positive</code> 函数，-5 是 <code>int</code> 对象，所以 <code>o-&gt;ob_type</code> 是 <code>PyLong_Type</code>，来看看它的定义，位于 Objects/longobject.c 文件。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">PyTypeObject PyLong_Type = &#123;</span><br><span class="line">    PyVarObject_HEAD_INIT(&amp;PyType_Type, <span class="number">0</span>)</span><br><span class="line">    <span class="string">"int"</span>,                                      <span class="comment">/* tp_name */</span></span><br><span class="line">    offsetof(PyLongObject, ob_digit),           <span class="comment">/* tp_basicsize */</span></span><br><span class="line">    <span class="keyword">sizeof</span>(digit),                              <span class="comment">/* tp_itemsize */</span></span><br><span class="line">    long_dealloc,                               <span class="comment">/* tp_dealloc */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_print */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_getattr */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_setattr */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_reserved */</span></span><br><span class="line">    long_to_decimal_string,                     <span class="comment">/* tp_repr */</span></span><br><span class="line">    &amp;long_as_number,                            <span class="comment">/* tp_as_number */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_as_sequence */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_as_mapping */</span></span><br><span class="line">    (hashfunc)long_hash,                        <span class="comment">/* tp_hash */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_call */</span></span><br><span class="line">    long_to_decimal_string,                     <span class="comment">/* tp_str */</span></span><br><span class="line">    PyObject_GenericGetAttr,                    <span class="comment">/* tp_getattro */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_setattro */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_as_buffer */</span></span><br><span class="line">    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE |</span><br><span class="line">        Py_TPFLAGS_LONG_SUBCLASS,               <span class="comment">/* tp_flags */</span></span><br><span class="line">    long_doc,                                   <span class="comment">/* tp_doc */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_traverse */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_clear */</span></span><br><span class="line">    long_richcompare,                           <span class="comment">/* tp_richcompare */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_weaklistoffset */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_iter */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_iternext */</span></span><br><span class="line">    long_methods,                               <span class="comment">/* tp_methods */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_members */</span></span><br><span class="line">    long_getset,                                <span class="comment">/* tp_getset */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_base */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_dict */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_descr_get */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_descr_set */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_dictoffset */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_init */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_alloc */</span></span><br><span class="line">    long_new,                                   <span class="comment">/* tp_new */</span></span><br><span class="line">    PyObject_Del,                               <span class="comment">/* tp_free */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>有点长，注意 <code>tp_as_number</code> 字段位置的值 <code>long_as_number</code>，它的定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> PyNumberMethods long_as_number = &#123;</span><br><span class="line">    (binaryfunc)long_add,       <span class="comment">/*nb_add*/</span></span><br><span class="line">    (binaryfunc)long_sub,       <span class="comment">/*nb_subtract*/</span></span><br><span class="line">    (binaryfunc)long_mul,       <span class="comment">/*nb_multiply*/</span></span><br><span class="line">    long_mod,                   <span class="comment">/*nb_remainder*/</span></span><br><span class="line">    long_divmod,                <span class="comment">/*nb_divmod*/</span></span><br><span class="line">    long_pow,                   <span class="comment">/*nb_power*/</span></span><br><span class="line">    (unaryfunc)long_neg,        <span class="comment">/*nb_negative*/</span></span><br><span class="line">    (unaryfunc)long_long,       <span class="comment">/*tp_positive*/</span></span><br><span class="line">    (unaryfunc)long_abs,        <span class="comment">/*tp_absolute*/</span></span><br><span class="line">    (inquiry)long_bool,         <span class="comment">/*tp_bool*/</span></span><br><span class="line">    (unaryfunc)long_invert,     <span class="comment">/*nb_invert*/</span></span><br><span class="line">    long_lshift,                <span class="comment">/*nb_lshift*/</span></span><br><span class="line">    (binaryfunc)long_rshift,    <span class="comment">/*nb_rshift*/</span></span><br><span class="line">    long_and,                   <span class="comment">/*nb_and*/</span></span><br><span class="line">    long_xor,                   <span class="comment">/*nb_xor*/</span></span><br><span class="line">    long_or,                    <span class="comment">/*nb_or*/</span></span><br><span class="line">    long_long,                  <span class="comment">/*nb_int*/</span></span><br><span class="line">    <span class="number">0</span>,                          <span class="comment">/*nb_reserved*/</span></span><br><span class="line">    long_float,                 <span class="comment">/*nb_float*/</span></span><br><span class="line">    <span class="number">0</span>,                          <span class="comment">/* nb_inplace_add */</span></span><br><span class="line">    <span class="number">0</span>,                          <span class="comment">/* nb_inplace_subtract */</span></span><br><span class="line">    <span class="number">0</span>,                          <span class="comment">/* nb_inplace_multiply */</span></span><br><span class="line">    <span class="number">0</span>,                          <span class="comment">/* nb_inplace_remainder */</span></span><br><span class="line">    <span class="number">0</span>,                          <span class="comment">/* nb_inplace_power */</span></span><br><span class="line">    <span class="number">0</span>,                          <span class="comment">/* nb_inplace_lshift */</span></span><br><span class="line">    <span class="number">0</span>,                          <span class="comment">/* nb_inplace_rshift */</span></span><br><span class="line">    <span class="number">0</span>,                          <span class="comment">/* nb_inplace_and */</span></span><br><span class="line">    <span class="number">0</span>,                          <span class="comment">/* nb_inplace_xor */</span></span><br><span class="line">    <span class="number">0</span>,                          <span class="comment">/* nb_inplace_or */</span></span><br><span class="line">    long_div,                   <span class="comment">/* nb_floor_divide */</span></span><br><span class="line">    long_true_divide,           <span class="comment">/* nb_true_divide */</span></span><br><span class="line">    <span class="number">0</span>,                          <span class="comment">/* nb_inplace_floor_divide */</span></span><br><span class="line">    <span class="number">0</span>,                          <span class="comment">/* nb_inplace_true_divide */</span></span><br><span class="line">    long_long,                  <span class="comment">/* nb_index */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>找到 <code>nb_positive</code> 字段位置的值 <code>(unaryfunc)long_long</code>，真正完成工作的就是这个函数，来看看其定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> PyObject *</span><br><span class="line">long_long(PyObject *v)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (PyLong_CheckExact(v))</span><br><span class="line">        Py_INCREF(v);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        v = _PyLong_Copy((PyLongObject *)v);</span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>逻辑非常简单，如果参数 <code>v</code> 是 <code>int</code> 对象（不是子类），增加其引用计数，否则将其转换成 <code>int</code> 对象，这一步由 <code>_PyLong_Copy</code> 完成，最后将 <code>v</code> 返回。好，追踪到此结束。</p><p>上面说到如果是一个非 <code>int</code> 对象会被转换成一个 <code>int</code> 对象，来看一个简单的示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>type(<span class="literal">True</span>).__mro__  <span class="comment"># bool类是int的子类</span></span><br><span class="line">(&lt;class 'bool'&gt;, &lt;class 'int'&gt;, &lt;class 'object'&gt;)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>+<span class="literal">True</span>   <span class="comment"># 被转换成了1</span></span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python操作码——DUP_TOP_TWO</title>
      <link href="/python/python-opcode-DUP_TOP_TWO.html"/>
      <url>/python/python-opcode-DUP_TOP_TWO.html</url>
      
        <content type="html"><![CDATA[<p><code>DUP_TOP_TWO</code> 的编号是5，是一个不带参数的操作码。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>dis.opmap[<span class="string">'DUP_TOP_TWO'</span>]</span><br><span class="line"><span class="number">5</span></span><br></pre></td></tr></table></figure><a id="more"></a><p>底层实现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">TARGET(DUP_TOP_TWO) &#123;</span><br><span class="line">    PyObject *top = TOP();</span><br><span class="line">    PyObject *second = SECOND();</span><br><span class="line">    Py_INCREF(top);</span><br><span class="line">    Py_INCREF(second);</span><br><span class="line">    STACKADJ(<span class="number">2</span>);</span><br><span class="line">    SET_TOP(top);</span><br><span class="line">    SET_SECOND(second);</span><br><span class="line">    FAST_DISPATCH();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先获取值栈顶部的两个元素，然后分别增加它们的引用计数。然后调整 <code>stack_pointer</code> 指向的地址，<code>STACKADJ</code> 定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TOP()                   (stack_pointer[-1])</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SECOND()                (stack_pointer[-2])</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STACKADJ(n)             BASIC_STACKADJ(n)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BASIC_STACKADJ(n)       (stack_pointer += n)</span></span><br></pre></td></tr></table></figure><p>因为解释器已经提前计算好了执行一段代码块所需的值栈的大小并分配了足够的内存，所以调整后 <code>stack_pointer</code> 不会越界。接着为腾出的两个位置设置相应的值。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SET_TOP(v) (stack_pointer[-1] = (v))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SET_SECOND(v) (stack_pointer[-2] = (v))</span></span><br></pre></td></tr></table></figure><p>图解：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">|            |                      |            |                      |            |</span></span><br><span class="line"><span class="comment">+------------+                      +------------+                      +------------+           </span></span><br><span class="line"><span class="comment">|            |    stack_pointer -&gt;  |            |    stack_pointer -&gt;  |            |</span></span><br><span class="line"><span class="comment">+------------+                      +------------+                      +------------+</span></span><br><span class="line"><span class="comment">|            |                      |            |                      |    top     |</span></span><br><span class="line"><span class="comment">+------------+                      +------------+                      +------------+</span></span><br><span class="line"><span class="comment">|            |  &lt;- stack_pointer    |            |                      |   second   |</span></span><br><span class="line"><span class="comment">+------------+                      +------------+                      +------------+</span></span><br><span class="line"><span class="comment">|    top     |                      |    top     |                      |    top     |</span></span><br><span class="line"><span class="comment">+------------+     STACKADJ(2)      +------------+      SET_*           +------------+</span></span><br><span class="line"><span class="comment">|   second   |     ===========&gt;     |   second   |     =======&gt;         |   second   |</span></span><br><span class="line"><span class="comment">+------------+                      +------------+                      +------------+</span></span><br><span class="line"><span class="comment">|    ...     |                      |    ...     |                      |    ...     |</span></span><br><span class="line"><span class="comment">+------------+                      +------------+                      +------------+</span></span><br><span class="line"><span class="comment">| PyObject * | &lt;- f_valuestack -&gt;   | PyObject * |     f_valuestack -&gt;  | PyObject * |</span></span><br><span class="line"><span class="comment">+------------+                      +------------+                      +------------+</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python操作码——DUP_TOP</title>
      <link href="/python/python-opcode-DUP_TOP.html"/>
      <url>/python/python-opcode-DUP_TOP.html</url>
      
        <content type="html"><![CDATA[<p><code>DUP_TOP</code> 操作码的编号是4， 是一个不带参数的操作码。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>dis.opmap[<span class="string">'DUP_TOP'</span>]</span><br><span class="line"><span class="number">4</span></span><br></pre></td></tr></table></figure><a id="more"></a><p>底层实现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">TARGET(DUP_TOP) &#123;</span><br><span class="line">    PyObject *top = TOP();</span><br><span class="line">    Py_INCREF(top);</span><br><span class="line">    PUSH(top);</span><br><span class="line">    FAST_DISPATCH();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先获取值栈栈顶的值，增加其引用计数，再将其压入值栈中。图解：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">|            |          +---------&gt; |            |</span></span><br><span class="line"><span class="comment">+------------+          |           +------------+</span></span><br><span class="line"><span class="comment">|            |  &lt;- stack_pointer    |    top     |</span></span><br><span class="line"><span class="comment">+------------+                      +------------+</span></span><br><span class="line"><span class="comment">|    top     |                      |    top     |  </span></span><br><span class="line"><span class="comment">+------------+   ==DUP_TOP===&gt;      +------------+</span></span><br><span class="line"><span class="comment">|    ...     |                      |    ...     |</span></span><br><span class="line"><span class="comment">+------------+                      +------------+</span></span><br><span class="line"><span class="comment">| PyObject * | &lt;- f_valuestack -&gt;   | PyObject * |</span></span><br><span class="line"><span class="comment">+------------+                      +------------+</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>来看两条不同的语句：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>dis.dis(<span class="string">'a = b = []'</span>)   <span class="comment"># 1.</span></span><br><span class="line">  <span class="number">1</span>           <span class="number">0</span> BUILD_LIST               <span class="number">0</span></span><br><span class="line">              <span class="number">2</span> DUP_TOP</span><br><span class="line">              <span class="number">4</span> STORE_NAME               <span class="number">0</span> (a)</span><br><span class="line">              <span class="number">6</span> STORE_NAME               <span class="number">1</span> (b)</span><br><span class="line">              <span class="number">8</span> LOAD_CONST               <span class="number">0</span> (<span class="literal">None</span>)</span><br><span class="line">             <span class="number">10</span> RETURN_VALUE</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>            </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dis.dis(<span class="string">'a = []; b = []'</span>)   <span class="comment"># 2.</span></span><br><span class="line">  <span class="number">1</span>           <span class="number">0</span> BUILD_LIST               <span class="number">0</span></span><br><span class="line">              <span class="number">2</span> STORE_NAME               <span class="number">0</span> (a)</span><br><span class="line">              <span class="number">4</span> BUILD_LIST               <span class="number">0</span></span><br><span class="line">              <span class="number">6</span> STORE_NAME               <span class="number">1</span> (b)</span><br><span class="line">              <span class="number">8</span> LOAD_CONST               <span class="number">0</span> (<span class="literal">None</span>)</span><br><span class="line">             <span class="number">10</span> RETURN_VALUE</span><br></pre></td></tr></table></figure><p><code>BUILD_LIST</code> 是使用<code>[]</code>创建列表时使用的操作码（注意，<code>list()</code> 使用的是 <code>CALL_FUNCTION</code>，<code>[]</code> 的效率比 <code>list()</code> 高），它会将创建好的列表压入值栈中。注意，第一个语句使用了 <code>DUP_TOP</code> 操作码，此时 <code>a</code> 和 <code>b</code> 指向了同一个对象，改变列表 <code>a</code> 的内容 <code>b</code> 也会跟着改变：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = b = []</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.append(<span class="number">1</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line">[<span class="number">1</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b</span><br><span class="line">[<span class="number">1</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>id(a) == id(b)</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure><p>第二个语句分别创建了两个列表，再分配给 <code>a</code> 和 <code>b</code>，此时 <code>a</code> 和 <code>b</code> 是两个不同的列表（分别指向两个不同的地址，列表的值还是相同的），改变列表 <code>a</code> 的内容不会影响到列表 <code>b</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = []; b = []</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.append(<span class="number">1</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line">[<span class="number">1</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b</span><br><span class="line">[]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>id(a) == id(b)</span><br><span class="line"><span class="literal">False</span></span><br></pre></td></tr></table></figure><p>所以在需要两个不同的列表时不要图省事直接写类似 <code>a = b = []</code> 这样的代码。</p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python操作码——ROT_THREE</title>
      <link href="/python/python-opcode-ROT_THREE.html"/>
      <url>/python/python-opcode-ROT_THREE.html</url>
      
        <content type="html"><![CDATA[<p><code>ROT_THREE</code> 的编号是3，是一个不带参数的操作码。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>dis.opmap[<span class="string">'ROT_THREE'</span>]</span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure><a id="more"></a><p>实现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">TARGET(ROT_THREE) &#123;</span><br><span class="line">    PyObject *top = TOP();</span><br><span class="line">    PyObject *second = SECOND();</span><br><span class="line">    PyObject *third = THIRD();</span><br><span class="line">    SET_TOP(second);</span><br><span class="line">    SET_SECOND(third);</span><br><span class="line">    SET_THIRD(top);</span><br><span class="line">    FAST_DISPATCH();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看过 <code>ROT_TWO</code> 分析的话就不难理解了，几个宏：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TOP() (stack_pointer[-1])</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SECOND() (stack_pointer[-2])</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> THIRD() (stack_pointer[-3])</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SET_TOP(v) (stack_pointer[-1] = (v))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SET_SECOND(v) (stack_pointer[-2] = (v))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SET_THIRD(v) (stack_pointer[-3] = (v))</span></span><br></pre></td></tr></table></figure><p>图解：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">|            |                      |            |</span></span><br><span class="line"><span class="comment">+------------+                      +------------+</span></span><br><span class="line"><span class="comment">|            |  &lt;- stack_pointer -&gt; |            |</span></span><br><span class="line"><span class="comment">+------------+                      +------------+</span></span><br><span class="line"><span class="comment">|    top     |                      |   second   |  </span></span><br><span class="line"><span class="comment">+------------+      ROT_THREE       +------------+</span></span><br><span class="line"><span class="comment">|   second   |     ===========&gt;     |   third    |</span></span><br><span class="line"><span class="comment">+------------+                      +------------+</span></span><br><span class="line"><span class="comment">|   third    |                      |    top     |     </span></span><br><span class="line"><span class="comment">+------------+                      +------------+</span></span><br><span class="line"><span class="comment">|    ...     |                      |    ...     |</span></span><br><span class="line"><span class="comment">+------------+                      +------------+</span></span><br><span class="line"><span class="comment">| PyObject * | &lt;- f_valuestack -&gt;   | PyObject * |</span></span><br><span class="line"><span class="comment">+------------+                      +------------+</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python操作码——ROT_TWO</title>
      <link href="/python/python-opcode-ROT_TWO.html"/>
      <url>/python/python-opcode-ROT_TWO.html</url>
      
        <content type="html"><![CDATA[<p>操作码 <code>ROT_TWO</code> 的编码是2，是一个不带参数的操作码。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>dis.opmap[<span class="string">'ROT_TWO'</span>]</span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure><a id="more"></a><p>实现较为简单：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">TARGET(ROT_TWO) &#123;</span><br><span class="line">    PyObject *top = TOP();</span><br><span class="line">    PyObject *second = SECOND();</span><br><span class="line">    SET_TOP(second);</span><br><span class="line">    SET_SECOND(top);</span><br><span class="line">    FAST_DISPATCH();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先获取值栈最顶部的两个元素，由宏 <code>TOP</code> 和 <code>SECOND</code> 完成，这两个宏的定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TOP() (stack_pointer[-1])</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SECOND() (stack_pointer[-2])</span></span><br></pre></td></tr></table></figure><p>值栈不为空时，<code>stack_pointer</code> 永远指向值栈的下一个空闲槽，<code>stack_pointer[-1]</code> 取的就是栈顶的元素，依次类推。</p><p>接下来，互换 <code>second</code> 和 <code>top</code> 在值栈中的位置，宏 <code>SET_TOP</code> 和 <code>SET_SECOND</code> 的定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SET_TOP(v) (stack_pointer[-1] = (v))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SET_SECOND(v) (stack_pointer[-2] = (v))</span></span><br></pre></td></tr></table></figure><p>简单的赋值操作。以上就是这个操作码的内容，用一幅图表示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">|            |                      |            |</span></span><br><span class="line"><span class="comment">+------------+                      +------------+</span></span><br><span class="line"><span class="comment">|            |  &lt;- stack_pointer -&gt; |            |</span></span><br><span class="line"><span class="comment">+------------+                      +------------+</span></span><br><span class="line"><span class="comment">|    top     |                      |   second   |  </span></span><br><span class="line"><span class="comment">+------------+        ROT_TWO       +------------+</span></span><br><span class="line"><span class="comment">|   second   |     ===========&gt;     |    top     |</span></span><br><span class="line"><span class="comment">+------------+                      +------------+</span></span><br><span class="line"><span class="comment">|    ...     |                      |    ...     |</span></span><br><span class="line"><span class="comment">+------------+                      +------------+</span></span><br><span class="line"><span class="comment">| PyObject * | &lt;- f_valuestack -&gt;   | PyObject * |</span></span><br><span class="line"><span class="comment">+------------+                      +------------+</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>在一些讲解优化 Python 代码的文章中，常常会看到建议使用 <code>a, b = b, a</code> 交换两个变量 <code>a</code> 和 <code>b</code> 的值，而不是引入临时变量 <code>t</code>。先来看 a<code>, b = b, a</code> 这样的语句生成的 AST 树：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> ast</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(ast.dump(ast.parse(<span class="string">'a, b = b, a'</span>))) <span class="comment"># 这里对输出进行了简单的换行处理，方便查看</span></span><br><span class="line">Module(</span><br><span class="line">    body=[</span><br><span class="line">        Assign(</span><br><span class="line">            targets=[</span><br><span class="line">                Tuple(</span><br><span class="line">                    elts=[</span><br><span class="line">                        Name(id=<span class="string">'a'</span>, ctx=Store()), </span><br><span class="line">                        Name(id=<span class="string">'b'</span>, ctx=Store())</span><br><span class="line">                    ], </span><br><span class="line">                    ctx=Store()</span><br><span class="line">                )</span><br><span class="line">            ], </span><br><span class="line">            value=Tuple(</span><br><span class="line">                elts=[</span><br><span class="line">                    Name(id=<span class="string">'b'</span>, ctx=Load()), </span><br><span class="line">                    Name(id=<span class="string">'a'</span>, ctx=Load())</span><br><span class="line">                ], </span><br><span class="line">                ctx=Load()</span><br><span class="line">            )</span><br><span class="line">        )</span><br><span class="line">    ]</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>一个 <code>Assgin</code> 节点，表示赋值。属性 <code>targets</code> 表示赋值符号左侧，一个 <code>Tuple</code> 节点，属性 <code>value</code> 表示赋值符号的右侧，也是一个 <code>Tuple</code> 节点。这样看起来执行语句的时候会先创建了元组 <code>(b, a)</code>，然后再进行解包赋值，这个开销可是比引入临时变量还要大的。那么 <code>a, b = b, a</code> 为什么会比 <code>t = a; a = b; b = t</code> 快呢，来看看字节码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>dis.dis(<span class="string">'a, b = b, a'</span>)</span><br><span class="line">  <span class="number">1</span>           <span class="number">0</span> LOAD_NAME                <span class="number">0</span> (b)</span><br><span class="line">              <span class="number">2</span> LOAD_NAME                <span class="number">1</span> (a)</span><br><span class="line">              <span class="number">4</span> ROT_TWO</span><br><span class="line">              <span class="number">6</span> STORE_NAME               <span class="number">1</span> (a)</span><br><span class="line">              <span class="number">8</span> STORE_NAME               <span class="number">0</span> (b)</span><br><span class="line">             <span class="number">10</span> LOAD_CONST               <span class="number">0</span> (<span class="literal">None</span>)</span><br><span class="line">             <span class="number">12</span> RETURN_VALUE</span><br></pre></td></tr></table></figure><p>使用了 <code>ROT_TWO</code>！先将变量 <code>b</code> 的值压入值栈，再压入变量 <code>a</code> 的值。接着调换它们在值栈中的位置，再保存到 <code>a</code> 和 <code>b</code> 中。过程：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">      压入</span></span><br><span class="line"><span class="comment">    +------ b</span></span><br><span class="line"><span class="comment">    |</span></span><br><span class="line"><span class="comment">    V               </span></span><br><span class="line"><span class="comment">|       |   ===&gt;    |   b   |</span></span><br><span class="line"><span class="comment">+-------+           +-------+</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">==================================</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">      压入</span></span><br><span class="line"><span class="comment">    +------ a</span></span><br><span class="line"><span class="comment">    |</span></span><br><span class="line"><span class="comment">    V</span></span><br><span class="line"><span class="comment">|       |           |   a   |</span></span><br><span class="line"><span class="comment">+-------+   ===&gt;    +-------+</span></span><br><span class="line"><span class="comment">|   b   |           |   b   |</span></span><br><span class="line"><span class="comment">+-------+           +-------+</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">==================================</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">交换</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">|   b   |</span></span><br><span class="line"><span class="comment">+-------+   </span></span><br><span class="line"><span class="comment">|   a   |           </span></span><br><span class="line"><span class="comment">+-------+       </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">==================================</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">      弹出</span></span><br><span class="line"><span class="comment">    +-----&gt; a</span></span><br><span class="line"><span class="comment">    |</span></span><br><span class="line"><span class="comment">    V</span></span><br><span class="line"><span class="comment">|   b   |</span></span><br><span class="line"><span class="comment">+-------+   </span></span><br><span class="line"><span class="comment">|   a   |           </span></span><br><span class="line"><span class="comment">+-------+</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">==================================</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">      弹出</span></span><br><span class="line"><span class="comment">    +-----&gt; b</span></span><br><span class="line"><span class="comment">    |</span></span><br><span class="line"><span class="comment">    V  </span></span><br><span class="line"><span class="comment">|   a   |           </span></span><br><span class="line"><span class="comment">+-------+</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>和引入临时变量相比，少了一次 <code>LOAD_*</code> 和 <code>STORE_*</code> ：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>dis.dis(<span class="string">'t = a; a = b; b = t'</span>)</span><br><span class="line">  <span class="number">1</span>           <span class="number">0</span> LOAD_NAME                <span class="number">0</span> (a)</span><br><span class="line">              <span class="number">2</span> STORE_NAME               <span class="number">1</span> (t)</span><br><span class="line">              <span class="number">4</span> LOAD_NAME                <span class="number">2</span> (b)</span><br><span class="line">              <span class="number">6</span> STORE_NAME               <span class="number">0</span> (a)</span><br><span class="line">              <span class="number">8</span> LOAD_NAME                <span class="number">1</span> (t)</span><br><span class="line">             <span class="number">10</span> STORE_NAME               <span class="number">2</span> (b)</span><br><span class="line">             <span class="number">12</span> LOAD_CONST               <span class="number">0</span> (<span class="literal">None</span>)</span><br><span class="line">             <span class="number">14</span> RETURN_VALUE</span><br></pre></td></tr></table></figure><blockquote><p>在函数中使用时，<code>LOAD_NAME</code>和 <code>STORE_NAME</code> 会变成 <code>LOAD_FAST</code> 和 <code>STORE_FAST</code>，后两者是前两者的优化版本。</p></blockquote><p>那么本应该涉及元组的操作怎么会变成这样呢？答案是 Python 底层在最终生成字节码前会进行一些优化，将诸如 <code>a, = b,</code>，<code>a, b = b, a</code>，<code>a, b, c = c, a, b</code> 这样的语句生成的字节码优化，像 <code>a, b, c, d = d, c, b, a</code> 这样的语句就不会优化了，这会创建一个元组再进行解包（<code>BUILD_TUPLE</code>、<code>UNPACK_SEQUENCE</code>）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>dis.dis(<span class="string">'a, b, c, d = d, c, b, a'</span>)</span><br><span class="line">  <span class="number">1</span>           <span class="number">0</span> LOAD_NAME                <span class="number">0</span> (d)</span><br><span class="line">              <span class="number">2</span> LOAD_NAME                <span class="number">1</span> (c)</span><br><span class="line">              <span class="number">4</span> LOAD_NAME                <span class="number">2</span> (b)</span><br><span class="line">              <span class="number">6</span> LOAD_NAME                <span class="number">3</span> (a)</span><br><span class="line">              <span class="number">8</span> BUILD_TUPLE              <span class="number">4</span></span><br><span class="line">             <span class="number">10</span> UNPACK_SEQUENCE          <span class="number">4</span></span><br><span class="line">             <span class="number">12</span> STORE_NAME               <span class="number">3</span> (a)</span><br><span class="line">             <span class="number">14</span> STORE_NAME               <span class="number">2</span> (b)</span><br><span class="line">             <span class="number">16</span> STORE_NAME               <span class="number">1</span> (c)</span><br><span class="line">             <span class="number">18</span> STORE_NAME               <span class="number">0</span> (d)</span><br><span class="line">             <span class="number">20</span> LOAD_CONST               <span class="number">0</span> (<span class="literal">None</span>)</span><br><span class="line">             <span class="number">22</span> RETURN_VALUE</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python操作码——POP_TOP</title>
      <link href="/python/python-opcode-POP_TOP.html"/>
      <url>/python/python-opcode-POP_TOP.html</url>
      
        <content type="html"><![CDATA[<p><code>POP_TOP</code> 操作码的编号是1，是个不带参数的操作码。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>dis.opmap[<span class="string">'POP_TOP'</span>]</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><a id="more"></a><p>这个操作码的作用是弹出值栈栈顶的值，实现非常简单：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">TARGET(POP_TOP) &#123;</span><br><span class="line">    PyObject *value = POP();</span><br><span class="line">    Py_DECREF(value);</span><br><span class="line">    FAST_DISPATCH();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先弹出值栈栈顶的值，然后减少其引用计数。</p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python操作码——STORE_NAME</title>
      <link href="/python/python-opcode-STORE_NAME.html"/>
      <url>/python/python-opcode-STORE_NAME.html</url>
      
        <content type="html"><![CDATA[<p><code>STORE_NANE</code>操作码的编号是90，是一个带参数的操作码。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>dis.opmap[<span class="string">'STORE_NAME'</span>]</span><br><span class="line"><span class="number">90</span></span><br></pre></td></tr></table></figure><a id="more"></a><p>这个操作码的作用是将变量名和对应的值保存在局部变量字典中，来看实现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">TARGET(STORE_NAME) &#123;</span><br><span class="line">    PyObject *name = GETITEM(names, oparg);</span><br><span class="line">    PyObject *v = POP();</span><br><span class="line">    PyObject *ns = f-&gt;f_locals;</span><br><span class="line">    <span class="keyword">int</span> err;</span><br><span class="line">    <span class="keyword">if</span> (ns == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        PyErr_Format(PyExc_SystemError,</span><br><span class="line">                        <span class="string">"no locals found when storing %R"</span>, name);</span><br><span class="line">        Py_DECREF(v);</span><br><span class="line">        <span class="keyword">goto</span> error;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (PyDict_CheckExact(ns))</span><br><span class="line">        err = PyDict_SetItem(ns, name, v);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        err = PyObject_SetItem(ns, name, v);</span><br><span class="line">    Py_DECREF(v);</span><br><span class="line">    <span class="keyword">if</span> (err != <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">goto</span> error;</span><br><span class="line">    DISPATCH();</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>首先根据操作码的参数 <code>oparg</code> 在 <code>names</code> 中获取变量的字符串表示 <code>name</code>，接着弹出值栈栈顶的元素 <code>v</code>，然后定义一个 <code>PyObject *</code> 的值 <code>ns</code> 指向帧对象的 <code>f_locals</code> 字段。如果 <code>ns</code> 为 <code>NULL</code>，说明局部命名空间不存在，需要引发一个 <code>SystemError</code>，减少 <code>v</code> 的引用计数，然后跳转到错误处理。</p><p>往下执行，说明<code>ns</code> 确实存在，首先需要检查 <code>ns</code> 是否是一个 <code>dict</code> 对象，由 <code>PyDict_CheckExact</code> 完成。如果是则调用 <code>PyDict_SetItem</code> 为字典 <code>ns</code> 添加键为 <code>name</code> 值为 <code>v</code> 的值，如果 <code>ns</code> 是其它映射对象，则调用 <code>PyObject_SetItem</code> 为 <code>ns</code> 设置键值对。之后减少 <code>v</code> 的引用计数。两个函数在成功都会返回0，所以最后需要检查返回值是否为0，如果不是，则需要跳转到错误处理部分。</p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python操作码——LOAD_NAME</title>
      <link href="/python/python-opcode-LOAD_NAME.html"/>
      <url>/python/python-opcode-LOAD_NAME.html</url>
      
        <content type="html"><![CDATA[<p><code>LOAD_NAME</code> 操作码的编号为101，是一个带参数的操作码。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>dis.opmap[<span class="string">'LOAD_NAME'</span>]</span><br><span class="line"><span class="number">101</span></span><br></pre></td></tr></table></figure><a id="more"></a><p>该操作码的作用是将变量名对应的值压入值栈中，实现如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">TARGET(LOAD_NAME) &#123;</span><br><span class="line">    PyObject *name = GETITEM(names, oparg);</span><br><span class="line">    PyObject *locals = f-&gt;f_locals;</span><br><span class="line">    PyObject *v;</span><br><span class="line">    <span class="keyword">if</span> (locals == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        PyErr_Format(PyExc_SystemError,</span><br><span class="line">                        <span class="string">"no locals when loading %R"</span>, name);</span><br><span class="line">        <span class="keyword">goto</span> error;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (PyDict_CheckExact(locals)) &#123;</span><br><span class="line">        v = PyDict_GetItem(locals, name);</span><br><span class="line">        Py_XINCREF(v);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        v = PyObject_GetItem(locals, name);</span><br><span class="line">        <span class="keyword">if</span> (v == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!PyErr_ExceptionMatches(PyExc_KeyError))</span><br><span class="line">                <span class="keyword">goto</span> error;</span><br><span class="line">            PyErr_Clear();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (v == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        v = PyDict_GetItem(f-&gt;f_globals, name);</span><br><span class="line">        Py_XINCREF(v);</span><br><span class="line">        <span class="keyword">if</span> (v == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (PyDict_CheckExact(f-&gt;f_builtins)) &#123;</span><br><span class="line">                v = PyDict_GetItem(f-&gt;f_builtins, name);</span><br><span class="line">                <span class="keyword">if</span> (v == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                    format_exc_check_arg(</span><br><span class="line">                                PyExc_NameError,</span><br><span class="line">                                NAME_ERROR_MSG, name);</span><br><span class="line">                    <span class="keyword">goto</span> error;</span><br><span class="line">                &#125;</span><br><span class="line">                Py_INCREF(v);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                v = PyObject_GetItem(f-&gt;f_builtins, name);</span><br><span class="line">                <span class="keyword">if</span> (v == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (PyErr_ExceptionMatches(PyExc_KeyError))</span><br><span class="line">                        format_exc_check_arg(</span><br><span class="line">                                    PyExc_NameError,</span><br><span class="line">                                    NAME_ERROR_MSG, name);</span><br><span class="line">                    <span class="keyword">goto</span> error;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    PUSH(v);</span><br><span class="line">    DISPATCH();</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>首先根据操作码的参数 <code>oparg</code> 从 <code>names</code> 元组中获取变量名的字符串表示，<code>names</code> 指向代码对象的 <code>co_names</code> 字段。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PyObject *names;</span><br><span class="line">names = co-&gt;co_names;</span><br></pre></td></tr></table></figure><p>接着获取帧对象的 <code>f_locals</code> 也就是局部命名空间的值，如果值不存在，则表示没有局部命名空间，所以会引发一个 <code>SystemError</code>，此时需要跳转到错误处理的代码块。往下，<code>PyDict_CheckExact</code> 是一个宏，检查 <code>locals</code> 是否是一个 <code>dict</code> 对象。注意，只有 <code>locals</code> 是 <code>dict</code> 对象而不是其子类时才返回true。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#define PyDict_CheckExact(op) (Py_TYPE(op) == &amp;PyDict_Type)</span><br></pre></td></tr></table></figure><p>如果条件为真，调用 <code>PyDict_GetItem</code> 从 <code>locals</code> 字典中获取键为 <code>name</code> 的值，即 <code>locals[name]</code>，并增加其引用计数，<code>Py_XINCREF</code> 在增加引用计数前会检查参数是否为 <code>NULL</code>。条件为假则调用 <code>PyObject_GetItem</code>，这个函数的行为也类似于 <code>locals[name]</code>，不过 <code>locals</code> 可以是任意 Python 对象。在获取不到值时，会返回 <code>NULL</code> 并设置相应的异常。往下看，当 <code>v</code> 为 <code>NULL</code>，也就是引发了异常时，会调用<code>PyErr_ExceptionMatches</code> 对 <code>PyObject_GetItem</code> 设置的异常进行匹配，如果不是 <code>KeyError</code>，则直接跳到错误处理部分；而如果是 <code>KeyError</code>，则调用 <code>PyErr_Clear</code> 把异常清掉。</p><p>稍微解释一下这里为什么会这么写，在帧对象中有3个字段 <code>f_builtins</code>、<code>f_globals</code>、<code>f_locals</code>，分别表示内置符号表、全局符号表和局部符号表，前两个必须是 Python 的 <code>dict</code> 对象，而最后一个可以是任意的映射对象，包括 <code>dict</code>。所以要取 <code>f_locals</code> 中的值的时候，会先判断它是否是 <code>dict</code> 对象，如果是，则直接调用 <code>PyDict_GetItem</code>。而如果是其它映射对象，则调用 <code>PyObject_GetItem</code>，这个函数所做的工作比 <code>PyDict_GetItem</code> 复杂，效率比较低。</p><p>往下，如果 <code>v</code> 为 <code>NULL</code>，也就是说 <code>f_locals</code> 中没有找到变量，那么就到 <code>f_globals</code> 中去找。也就是 <code>v = PyDict_GetItem(f-&gt;f_globals, name)</code> 这行的工作。如果还是没找到，则继续去 <code>f_builtins</code> 中找。</p><p>注意，在 <code>f_builtins</code> 中查找的时候，会先检查 <code>f_builtins</code> 是否是 <code>dict</code> 对象，如果是，则调用 <code>PyDict_GetItem</code> 获取值，如果找到了，增加其引用计数。而如果值为 <code>NULL</code>，后面已经没有命名空间了，所以需要引发一个 <code>NameError</code> 异常。<code>NAME_ERROR_MSG</code> 定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NAME_ERROR_MSG <span class="meta-string">"name '%.200s' is not defined"</span></span></span><br></pre></td></tr></table></figure><p>如果 <code>f_builtins</code> 不是一个字典对象，会调用 <code>PyObject_GetItem</code> 获取值，如果值为 <code>NULL</code>，则先对 <code>PyObject_GetItem</code> 设置的异常进行匹配，如果是 <code>KeyError</code>，则引发一个 <code>NameError</code> 异常，否则直接跳转到错误处理。注意在这个分支里没有增加 <code>v</code> 的引用计数。</p><p>走到最后，确实找到了值 <code>v</code>，则将其压入值栈中供后面的操作码使用。</p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python操作码——LOAD_FAST</title>
      <link href="/python/python-opcode-LOAD_FAST.html"/>
      <url>/python/python-opcode-LOAD_FAST.html</url>
      
        <content type="html"><![CDATA[<p><code>LOAD_FAST</code> 操作码的编号为124，是带参数的操作码。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>dis.opmap[<span class="string">'LOAD_FAST'</span>]</span><br><span class="line"><span class="number">124</span></span><br></pre></td></tr></table></figure><a id="more"></a><p>底层实现为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">TARGET(LOAD_FAST) &#123;</span><br><span class="line">    PyObject *value = GETLOCAL(oparg);</span><br><span class="line">    <span class="keyword">if</span> (value == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        format_exc_check_arg(PyExc_UnboundLocalError,</span><br><span class="line">                             UNBOUNDLOCAL_ERROR_MSG,</span><br><span class="line">                             PyTuple_GetItem(co-&gt;co_varnames, oparg));</span><br><span class="line">        <span class="keyword">goto</span> error;</span><br><span class="line">    &#125;</span><br><span class="line">    Py_INCREF(value);</span><br><span class="line">    PUSH(value);</span><br><span class="line">    FAST_DISPATCH();</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>首先根据 <code>oparg</code> 从 <code>fastlocals</code> 数组中获取对应的值，如果值不存在，则会引发 <code>UnboundLocalError</code> 异常，并跳转到错误处理。先来看看传递给 <code>format_exc_check_arg</code> 函数的几个参数，<code>PyExc_UnboundLocalError</code>，对应 Python 中的 <code>UnboundLocalError</code> 异常。<code>UNBOUNDLOCAL_ERROR_MSG</code>，一个宏：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> UNBOUNDLOCAL_ERROR_MSG \</span></span><br><span class="line">    <span class="string">"local variable '%.200s' referenced before assignment"</span></span><br></pre></td></tr></table></figure><p>最后 <code>co_varnames</code> 是代码对象的一个字段——一个保存变量的字符串表示的元组。</p><p>考虑如下代码，变量 <code>a</code> 未进行赋值就用于增强赋值（+=）操作：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">()</span>:</span></span><br><span class="line"><span class="meta">... </span>    a += <span class="number">1</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> a</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>调用函数 <code>f</code> 就会引发 <code>UnboundLocalError</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>f()</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">2</span>, <span class="keyword">in</span> f</span><br><span class="line">UnboundLocalError: local variable <span class="string">'a'</span> referenced before assignment</span><br></pre></td></tr></table></figure><p>再来看 <code>format_exc_check_arg</code> 的定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">format_exc_check_arg(PyObject *exc, <span class="keyword">const</span> <span class="keyword">char</span> *format_str, PyObject *obj)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *obj_str;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!obj)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    obj_str = PyUnicode_AsUTF8(obj);</span><br><span class="line">    <span class="keyword">if</span> (!obj_str)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    PyErr_Format(exc, format_str, obj_str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先定义一个 <code>const char *</code> 类型的变量，然后检查 <code>obj</code> 是否为空，为 <code>NULL</code> 就直接返回。接着将 <code>PyObject *</code> 类型的 <code>obj</code> 转换为 <code>const char *</code> 类型，也就是 <code>PyUnicode_AsUTF8</code> 所做的工作。最后调用 <code>PyErr_Format</code> 设置异常信息。</p><p>回到操作码的执行。往下走，即 <code>value</code> 不为 <code>NULL</code>，此时需要增加 <code>value</code> 的引用计数，由 <code>Py_INCREF</code> 完成。然后，将 <code>value</code> 压入值栈中，供后面的操作码使用。</p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python操作码——STORE_FAST</title>
      <link href="/python/python-opcode-STORE_FAST.html"/>
      <url>/python/python-opcode-STORE_FAST.html</url>
      
        <content type="html"><![CDATA[<p><code>STORE_FAST</code> 操作码的编号是125，需要一个参数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>dis.opmap[<span class="string">'STORE_FAST'</span>]</span><br><span class="line"><span class="number">125</span></span><br></pre></td></tr></table></figure><a id="more"></a><p>来看看底层实现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">PREDICTED(STORE_FAST);</span><br><span class="line">TARGET(STORE_FAST) &#123;</span><br><span class="line">    PyObject *value = POP();</span><br><span class="line">    SETLOCAL(oparg, value);</span><br><span class="line">    FAST_DISPATCH();</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>可以看到非常简单，<code>PREDICTED</code>，跟操作码预测相关，不展开。<code>TARGET(STORE_FAST)</code>，简单地当做是 <code>case STORE_FAST:</code>。直接看花括号里的内容，<code>POP</code> 是一个宏，取值栈栈顶的元素：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BASIC_POP   (*--stack_pointer)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> POP()       BASIC_POP()</span></span><br></pre></td></tr></table></figure><p>这里的弹出操作与一般栈的弹出操作有点出入，<code>stack_pointer</code> 本来指向值栈的下一个空闲槽，这里只是简单将指针减1，于是取到了栈顶的元素，但是这个宏并没有将元素从栈中删去，值还保留在栈中。如果下一条指令是诸如 <code>LOAD_*</code> 的指令，则会直接将值覆盖。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">|            | &lt;- stack_pointer</span></span><br><span class="line"><span class="comment">+------------+</span></span><br><span class="line"><span class="comment">| PyObject * | &lt;- 栈顶</span></span><br><span class="line"><span class="comment">+------------+</span></span><br><span class="line"><span class="comment">| ...        |</span></span><br><span class="line"><span class="comment">+------------|</span></span><br><span class="line"><span class="comment">| PyObject * | </span></span><br><span class="line"><span class="comment">+------------+</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p><code>POP</code> 取出值后，下一条语句 <code>SETLOCAL</code>，也是一个宏：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SETLOCAL(i, v)     do &#123; PyObject *tmp = GETLOCAL(i); \</span></span><br><span class="line">                                GETLOCAL(i) = value; \</span><br><span class="line">                                PyXDECREF(tmp); &#125; <span class="keyword">while</span> (<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GETLOCAL(i)         (fastlocals[i])</span></span><br></pre></td></tr></table></figure><p>先来解释 <code>GETLOCAL</code>，<code>fastlocals</code> 是对帧对象的 <code>f_localsplus</code> 的引用，是一个 <code>PyObject *</code> 类型的数组。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fastlocals = f-&gt;f_localsplus;   <span class="comment">/* f是帧对象 */</span></span><br></pre></td></tr></table></figure><p><code>SETLOCAL</code> 首先获取数组中索引为 <code>oparg</code> 的旧值，其中 <code>oparg</code> 是操作码的参数。然后设置新值，再之后需要检查旧值的引用计数，<code>PyXDECREF</code> 是 <code>Py_DECREF</code> 的拓展版本，会先检查传入的参数是否为空，再调用 <code>Py_DECREF</code>。设置好值后，下一条语句 <code>FAST_DISPATCH</code>，跳到<code>fast_next_opcode</code> 执行下一条操作码。</p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python操作码——LOAD_CONST</title>
      <link href="/python/python-opcode-LOAD_CONST.html"/>
      <url>/python/python-opcode-LOAD_CONST.html</url>
      
        <content type="html"><![CDATA[<p><code>LOAD_CONST</code> 操作码编号为100，是带参数的操作码。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>dis.opmap[<span class="string">'LOAD_CONST'</span>]</span><br><span class="line"><span class="number">100</span></span><br></pre></td></tr></table></figure><a id="more"></a><p>在 Python 底层中实现如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">PREDICTED(LOAD_CONST);</span><br><span class="line">TARGET(LOAD_CONST) &#123;</span><br><span class="line">    PyObject *value = GETITEM(consts, oparg);</span><br><span class="line">    Py_INCREF(value);</span><br><span class="line">    PUSH(value);</span><br><span class="line">    FAST_DISPATCH();</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p><code>PREDICTED</code> 是用于操作码预测的宏：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PREDICTED(op) PRED_##op:</span></span><br></pre></td></tr></table></figure><p>展开为 <code>PRED_LOAD_CONST:</code>，操作码预测这里不讨论。接下来是 <code>TARGET</code> 宏：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TARGET(op) case op:</span></span><br></pre></td></tr></table></figure><p>Python 中的每个操作码都是一个 <code>switch</code> 语句的 <code>case</code> 分支。来看 <code>case</code> 里的内容，<code>GETITEM</code> 是一个宏：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GETITEM(v,i) PyTuple_GetItem((v), (i))</span></span><br></pre></td></tr></table></figure><p>其实就是元组的下标索引操作，相当于 <code>consts[oparg]</code> ，这里 <code>consts</code> 是一个元组，<code>oparg</code> 则是 <code>LOAD_CONST</code> 操作码的参数。<code>consts</code> 元组引用代码对象的 <code>co_consts</code> 字段，这个字段的值在创建代码对象时设置。在代码对象中用到的常量都会保存在这个元组里，这样就可以在常数时间获取到常量。取到的值都以 <code>PyObject *</code> 的形式操作。接下来是 <code>Py_INCREF</code>，增加值的引用计数，没啥好说的。再到 <code>PUSH</code>，操作值栈的宏：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">PyObject **stack_pointer;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BASIC_PUSH(v)   (*stack_pointer++ = (v))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PUSH(v)     BASIC_PUSH(v)</span></span><br></pre></td></tr></table></figure><p><code>stack_pointer</code> 总是指向值栈的下一个空闲槽，类似这样：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">|            | &lt;- stack_pointer</span></span><br><span class="line"><span class="comment">+------------+</span></span><br><span class="line"><span class="comment">| PyObject * |</span></span><br><span class="line"><span class="comment">+------------+</span></span><br><span class="line"><span class="comment">| ...        |</span></span><br><span class="line"><span class="comment">+------------+</span></span><br><span class="line"><span class="comment">| PyObject * |</span></span><br><span class="line"><span class="comment">+------------+</span></span><br><span class="line"><span class="comment">| PyObject * | &lt;- f_valuestack</span></span><br><span class="line"><span class="comment">+------------+</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>所以 <code>PUSH</code> 的操作就是将值压入值栈中，再将 <code>stack_pointer</code> 指针指向下一个空闲槽。最后是 <code>FAST_DISPATH</code>，也是一个宏：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FAST_DISPATCH() goto fast_next_opcode</span></span><br></pre></td></tr></table></figure><p>跳转到 <code>fast_next_opcode</code>，不检查 GIL 直接获取下一个操作码执行。</p><p>以上就是 <code>LOAD_CONST</code> 操作码的全部内容，最后来看看它对应的 Python 代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">()</span>:</span></span><br><span class="line"><span class="meta">... </span>    a = <span class="number">11</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p><code>a = 11</code>，一个简单的赋值语句，这里用函数包装起来可以方便查看它的代码对象的属性。用 <code>dis</code> 模块进行反汇编：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>dis.dis(f)</span><br><span class="line">  <span class="number">2</span>           <span class="number">0</span> LOAD_CONST               <span class="number">1</span> (<span class="number">11</span>)</span><br><span class="line">              <span class="number">2</span> STORE_FAST               <span class="number">0</span> (a)</span><br><span class="line">              <span class="number">4</span> LOAD_CONST               <span class="number">0</span> (<span class="literal">None</span>)</span><br><span class="line">              <span class="number">6</span> RETURN_VALUE</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f.__code__.co_consts</span><br><span class="line">(<span class="literal">None</span>, <span class="number">11</span>)</span><br></pre></td></tr></table></figure><p>可以看到，第一条操作码就是 <code>LOAD_CONST</code>，参数是1，将常量11加载到值栈上，然后是 <code>STORE_FAST</code>，将值11与变量 <code>a</code> 关联。最后两条操作码在函数没有显式返回值的情况下必定会出现。记住，Python 的函数必定有返回值：未显式给出返回值将返回 <code>None</code>。</p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一个格式化ast.dump返回值的函数</title>
      <link href="/python/a-function-to-format-ast-node.html"/>
      <url>/python/a-function-to-format-ast-node.html</url>
      
        <content type="html"><![CDATA[<p><code>ast.dump()</code> 函数可用于打印 Python 的 AST 节点，他接受一个 <code>ast.AST</code>类的实例，并返回节点树的字符串表示。要得到一个 <code>ast.AST</code>类的实例，可以使用 <code>ast.parse()</code> 函数，这个函数是内建函数 <code>compile()</code> 的简单包装：</p><a id="more"></a><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">parse</span><span class="params">(source, filename=<span class="string">'&lt;unknown&gt;'</span>, mode=<span class="string">'exec'</span>)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> compile(source, filename, mode, PyCF_ONLY_AST)</span><br></pre></td></tr></table></figure><p>使用起来很简单，下面定义一个函数，并打印出它的 AST 节点表示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> ast</span><br><span class="line"></span><br><span class="line">code = (</span><br><span class="line">    <span class="string">"def fs(a, b=0, *, c=2, **kwargs):\n"</span></span><br><span class="line">    <span class="string">"    res = a + b + c\n"</span></span><br><span class="line">    <span class="string">"    print(res)\n"</span></span><br><span class="line">    <span class="string">"    print(kwargs)"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">tree = ast.parse(code)</span><br><span class="line">print(ast.dump(tree))</span><br></pre></td></tr></table></figure><p>结果是：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Module(body=[FunctionDef(name=<span class="string">'fs'</span>, args=arguments(args=[arg(arg=<span class="string">'a'</span>, annotation=<span class="literal">None</span>), arg(arg=<span class="string">'b'</span>, annotation=<span class="literal">None</span>)], vararg=<span class="literal">None</span>, kwonlyargs=[arg(arg=<span class="string">'c'</span>, annotation=<span class="literal">None</span>)], kw_defaults=[Num(n=<span class="number">2</span>)], kwarg=arg(arg=<span class="string">'kwargs'</span>, annotation=<span class="literal">None</span>), defaults=[Num(n=<span class="number">0</span>)]), body=[Assign(targets=[Name(id=<span class="string">'res'</span>, ctx=Store())], value=BinOp(left=BinOp(left=Name(id=<span class="string">'a'</span>, ctx=Load()), op=Add(), right=Name(id=<span class="string">'b'</span>, ctx=Load())), op=Add(), right=Name(id=<span class="string">'c'</span>, ctx=Load()))), Expr(value=Call(func=Name(id=<span class="string">'print'</span>, ctx=Load()), args=[Name(id=<span class="string">'res'</span>, ctx=Load())], keywords=[])), Expr(value=Call(func=Name(id=<span class="string">'print'</span>, ctx=Load()), args=[Name(id=<span class="string">'kwargs'</span>, ctx=Load())], keywords=[]))], decorator_list=[], returns=<span class="literal">None</span>)])</span><br></pre></td></tr></table></figure><p>结果没有换行，对阅读一点也不友好。使用 Python 标准库的 <code>pprint</code> 打印效果也不是很理想：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pprint <span class="keyword">import</span> pprint</span><br><span class="line"></span><br><span class="line">pprint(ast.dump(tree))</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">(<span class="string">"Module(body=[FunctionDef(name='fs', args=arguments(args=[arg(arg='a', "</span></span><br><span class="line"> <span class="string">"annotation=None), arg(arg='b', annotation=None)], vararg=None, "</span></span><br><span class="line"> <span class="string">"kwonlyargs=[arg(arg='c', annotation=None)], kw_defaults=[Num(n=2)], "</span></span><br><span class="line"> <span class="string">"kwarg=arg(arg='kwargs', annotation=None), defaults=[Num(n=0)]), "</span></span><br><span class="line"> <span class="string">"body=[Assign(targets=[Name(id='res', ctx=Store())], "</span></span><br><span class="line"> <span class="string">"value=BinOp(left=BinOp(left=Name(id='a', ctx=Load()), op=Add(), "</span></span><br><span class="line"> <span class="string">"right=Name(id='b', ctx=Load())), op=Add(), right=Name(id='c', ctx=Load()))), "</span></span><br><span class="line"> <span class="string">"Expr(value=Call(func=Name(id='print', ctx=Load()), args=[Name(id='res', "</span></span><br><span class="line"> <span class="string">"ctx=Load())], keywords=[])), Expr(value=Call(func=Name(id='print', "</span></span><br><span class="line"> <span class="string">"ctx=Load()), args=[Name(id='kwargs', ctx=Load())], keywords=[]))], "</span></span><br><span class="line"> <span class="string">'decorator_list=[], returns=None)])'</span>)</span><br></pre></td></tr></table></figure><p>还是自己来写一个吧！直接上代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">format_</span><span class="params">(string, symbol, indent)</span>:</span></span><br><span class="line">    level = <span class="number">0</span></span><br><span class="line">    sep = symbol * indent</span><br><span class="line">    <span class="keyword">for</span> i, s <span class="keyword">in</span> enumerate(string):</span><br><span class="line">        <span class="keyword">if</span> s <span class="keyword">in</span> &#123;<span class="string">'('</span>, <span class="string">'['</span>&#125;:</span><br><span class="line">            <span class="keyword">yield</span> s</span><br><span class="line">            <span class="keyword">if</span> string[i + <span class="number">1</span>] <span class="keyword">not</span> <span class="keyword">in</span> &#123;<span class="string">')'</span>, <span class="string">']'</span>&#125;:</span><br><span class="line">                level += <span class="number">1</span></span><br><span class="line">                <span class="keyword">yield</span> (<span class="string">'\n'</span> + sep * level)</span><br><span class="line">        <span class="keyword">elif</span> s <span class="keyword">in</span> &#123;<span class="string">')'</span>, <span class="string">']'</span>&#125;:</span><br><span class="line">            <span class="keyword">if</span> string[i - <span class="number">1</span>] <span class="keyword">not</span> <span class="keyword">in</span> &#123;<span class="string">'('</span>, <span class="string">'['</span>&#125;:</span><br><span class="line">                level -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">yield</span> <span class="string">'\n'</span> + sep * level</span><br><span class="line">            <span class="keyword">yield</span> s</span><br><span class="line">        <span class="keyword">elif</span> s == <span class="string">','</span>:</span><br><span class="line">            <span class="keyword">yield</span> s + <span class="string">'\n'</span> + sep * level</span><br><span class="line">        <span class="keyword">elif</span> s == <span class="string">' '</span>:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">yield</span> s</span><br><span class="line">            </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">p_print</span><span class="params">(tree, symbol=<span class="string">' '</span>, indent=<span class="number">4</span>)</span>:</span></span><br><span class="line">    print(<span class="string">''</span>.join(format_(tree, symbol, indent)))</span><br></pre></td></tr></table></figure><p>代码很简单，来看看效果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line">Module(</span><br><span class="line">    body=[</span><br><span class="line">        FunctionDef(</span><br><span class="line">            name=<span class="string">'fs'</span>,</span><br><span class="line">            args=arguments(</span><br><span class="line">                args=[</span><br><span class="line">                    arg(</span><br><span class="line">                        arg=<span class="string">'a'</span>,</span><br><span class="line">                        annotation=<span class="literal">None</span></span><br><span class="line">                    ),</span><br><span class="line">                    arg(</span><br><span class="line">                        arg=<span class="string">'b'</span>,</span><br><span class="line">                        annotation=<span class="literal">None</span></span><br><span class="line">                    )</span><br><span class="line">                ],</span><br><span class="line">                vararg=<span class="literal">None</span>,</span><br><span class="line">                kwonlyargs=[</span><br><span class="line">                    arg(</span><br><span class="line">                        arg=<span class="string">'c'</span>,</span><br><span class="line">                        annotation=<span class="literal">None</span></span><br><span class="line">                    )</span><br><span class="line">                ],</span><br><span class="line">                kw_defaults=[</span><br><span class="line">                    Num(</span><br><span class="line">                        n=<span class="number">2</span></span><br><span class="line">                    )</span><br><span class="line">                ],</span><br><span class="line">                kwarg=arg(</span><br><span class="line">                    arg=<span class="string">'kwargs'</span>,</span><br><span class="line">                    annotation=<span class="literal">None</span></span><br><span class="line">                ),</span><br><span class="line">                defaults=[</span><br><span class="line">                    Num(</span><br><span class="line">                        n=<span class="number">0</span></span><br><span class="line">                    )</span><br><span class="line">                ]</span><br><span class="line">            ),</span><br><span class="line">            body=[</span><br><span class="line">                Assign(</span><br><span class="line">                    targets=[</span><br><span class="line">                        Name(</span><br><span class="line">                            id=<span class="string">'res'</span>,</span><br><span class="line">                            ctx=Store()</span><br><span class="line">                        )</span><br><span class="line">                    ],</span><br><span class="line">                    value=BinOp(</span><br><span class="line">                        left=BinOp(</span><br><span class="line">                            left=Name(</span><br><span class="line">                                id=<span class="string">'a'</span>,</span><br><span class="line">                                ctx=Load()</span><br><span class="line">                            ),</span><br><span class="line">                            op=Add(),</span><br><span class="line">                            right=Name(</span><br><span class="line">                                id=<span class="string">'b'</span>,</span><br><span class="line">                                ctx=Load()</span><br><span class="line">                            )</span><br><span class="line">                        ),</span><br><span class="line">                        op=Add(),</span><br><span class="line">                        right=Name(</span><br><span class="line">                            id=<span class="string">'c'</span>,</span><br><span class="line">                            ctx=Load()</span><br><span class="line">                        )</span><br><span class="line">                    )</span><br><span class="line">                ),</span><br><span class="line">                Expr(</span><br><span class="line">                    value=Call(</span><br><span class="line">                        func=Name(</span><br><span class="line">                            id=<span class="string">'print'</span>,</span><br><span class="line">                            ctx=Load()</span><br><span class="line">                        ),</span><br><span class="line">                        args=[</span><br><span class="line">                            Name(</span><br><span class="line">                                id=<span class="string">'res'</span>,</span><br><span class="line">                                ctx=Load()</span><br><span class="line">                            )</span><br><span class="line">                        ],</span><br><span class="line">                        keywords=[]</span><br><span class="line">                    )</span><br><span class="line">                ),</span><br><span class="line">                Expr(</span><br><span class="line">                    value=Call(</span><br><span class="line">                        func=Name(</span><br><span class="line">                            id=<span class="string">'print'</span>,</span><br><span class="line">                            ctx=Load()</span><br><span class="line">                        ),</span><br><span class="line">                        args=[</span><br><span class="line">                            Name(</span><br><span class="line">                                id=<span class="string">'kwargs'</span>,</span><br><span class="line">                                ctx=Load()</span><br><span class="line">                            )</span><br><span class="line">                        ],</span><br><span class="line">                        keywords=[]</span><br><span class="line">                    )</span><br><span class="line">                )</span><br><span class="line">            ],</span><br><span class="line">            decorator_list=[],</span><br><span class="line">            returns=<span class="literal">None</span></span><br><span class="line">        )</span><br><span class="line">    ]</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>虽然输出很长，但是层级明显，可以友好地阅读了。</p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pygame报libpng warning提示的解决方法</title>
      <link href="/python/pygame-libpng-warning.html"/>
      <url>/python/pygame-libpng-warning.html</url>
      
        <content type="html"><![CDATA[<p>最近在用 <code>pygame</code> 写小游戏时遇到一个问题，在加载 <code>.png</code> 图片的时候，控制台会一直输出 <code>libpng warning: iCCP: known incorrect sRGB profile</code>，虽然程序能跑起来但是看起来实在烦人，也影响调试。所以去搜索了相关问题，在<a href="https://blog.csdn.net/u010212648/article/details/82191419" target="_blank" rel="noopener">这篇博客</a>的评论下找到了解决办法。方法是使用 <code>PyQt5</code> 对图片进行转换。不过我自己尝试发现，直接使用 <code>pygame</code> 对图片进行转换也可以解决。</p><a id="more"></a><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> pygame</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">translate</span><span class="params">(path)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> file <span class="keyword">in</span> os.listdir(path):</span><br><span class="line">        <span class="keyword">if</span> file.endswith(<span class="string">'.png'</span>):</span><br><span class="line">            full_path = os.path.join(path, file)</span><br><span class="line">            image = pygame.image.load(full_path)</span><br><span class="line">            pygame.image.save(image, full_path)</span><br></pre></td></tr></table></figure><p>简单理解就是调用 <code>pygame.image.load()</code> 加载一遍给定路径中的图片再调用 <code>pygame.image.save()</code> 保存图片。假设图片存储在和这段程序同级的<code>images</code>目录下，调用 <code>translate(&#39;images/&#39;)</code> 就可以解决上述问题。</p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> pygame </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
